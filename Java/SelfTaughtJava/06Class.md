# 클래스





> 이 문서는 [<혼자 공부하는 자바 - 신용권>](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791162241875&orderClick=LAG&Kc=) 책을 보고 정리한 문서입니다.





## 1. 객체 지향 프로그래밍

- 객체(object) : 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있으면서 식별 가능한 것.
- 객체는 속성과 동작으로 구성됨. 자바는 속성은 필드(field), 동작은 메소드(method)라고 부름.
- 객체 모델링(object modeling) : 현실 세계의 객체를 소프트웨어 객체로 설계하는 것. 현실 세계 객체의 속성과 동작을 추려내어 소프트웨어 객체의 필드와 메소드로 정의하는 과정.
- 객체 지향 프로그래밍(OOP: Object-Oriented Programming) : 부품에 해당하는 객체를 먼저 만든 뒤 객체를 하나씩 조립해서 완성된 프로그램을 만드는 기법.



### 1.1. 객체의 상호작용

- 객체들은 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용하면서 동작함.

- 객체들 사이의 상호작용 수단은 메소드.

- 메소드 호출 : 객체가 다른 객체의 기능을 이용하는 것.

- 메소드 호출 방법은 객체에 도트(.) 연산자를 붙이고 메소드 이름을 기술하면 됨.

- 도트 연산자는 객체의 필드와 메소드에 접근할 때 사용함.

- 매개값 : 메소드를 실행하기 위해 필요한 데이터.

- 리턴값 : 메소드가 실행되고 난 후 호출한 곳으로 돌려주는(리턴하는) 값.

  ```java
  int result = Calculator.add(10, 20);
  ```

  - 계산기 객체의 add 메소드를 10, 20 값을 매개로 호출하여 리턴한 값을 int 변수에 저장하는 코드

- 객체의 상호작용은 객체 간의 메소드 호출을 의미하며 매개값과 리턴값을 통해서 데이터를 주고 받음.



### 1.2. 객체 간의 관계

### 집합 관계

- 객체 하나는 부품이고, 다른 하나는 완성품에 해당함.
- 자동차는 엔진, 타이어, 핸들 등으로 구성되므로 자동차와 이 부품들은 집합 관계라고 볼 수 있음.



### 사용 관계

- 객체 간의 상호작용을 말함.
- 객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어냄.
- 사람은 자동차를 사용하므로 사람과 자동차는 사용 관계라고 볼 수 있음.
- 사람은 자동차를 사용할 때 달린다, 멈춘다 등의 메소드를 호출하는 것임.



### 상속 관계

- 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계를 말함.
- 일반적으로 상위 객체는 종류를 의미하고, 하위 객체는 구체적인 사물에 해당함.
- "자동차는 기계의 한 종류이다."에서 기계(상위)와 자동차(하위)는 상속 관계에 있다고 볼 수 있음.



### 1.3. 객체와 클래스

- 클래스(class) : 객체의 설계도. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있음.
- 인스턴스(instance) : 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 함.
  - 자동차 객체는 자동차 클래스의 인스턴스임.
- 인스턴스화 : 클래스로부터 객체를 만들어내는 과정.
- 하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있음.
- 객체 지향 프로그래밍 개발의 세 단계
  - 1단계 : 클래스 설계
  - 2단계 : 설계된 클래스를 가지고 사용할 객체를 생성
  - 3단계 : 생성된 객체를 이용
- main() 메소드가 없는 클래스는 객체 생성 과정을 거쳐 사용해야 함.



### 1.4. 클래스 선언

- 클래스 이름은 자바의 식별자 작성 규칙에 따름.

- '클래스 이름.java'로 소스 파일 생성.

- 클래스 이름과 소스 파일 이름 대소문자가 같도록 해야 함.

- 일반적으로 소스 파일 하나당 하나의 클래스를 선언함. 2개 이상의 클래스 선언도 가능함.

- 클래스가 선언된 소스 파일을 컴파일하면 클래스를 선언한 개수만큼 바이트 코드 파일(.class)가 생성됨.

- ```java
  public class Car {
  
  }
  
  class Tire {
  
  }
  ```

  - 위의 코드를 컴파일하면 Car.class와 Tire.class 가 각각 생성됨.

- public 접근 제한자 : 파일 이름과 동일한 이름의 클래스 선언에만 붙일 수 있음. 파일 이름과 일치하지 않는 클래스 선언에 public 접근 제한자를 붙이면 컴파일 에러 발생. 위의 코드에서도 소스 파일 이름이 'Car.java'이기 때문에 Tire 클래스에는 public 접근 제한자를 붙이지 않았음.



### 1.5. 객체 생성과 클래스 변수

- new : 클래스로부터 객체를 생성시키는 연산자.
- new 연산자 뒤에는 생성자가 옴. 생성자는 클래스() 형태를 가지고 있음.
- new 연산자로 생성된 객체는 메모리의 힙(heap) 영역에 생성됨.
- new 연산자는 힙 영역에 객체를 생성시킨 후 객체의 번지를 리턴함.
- 이 주소를 참조 타입인 클래스 변수에 저장해두면 변수를 통해 객체를 사용할 수 있음.

```java
Student s1 = new Student();

Student s2;
s2 = new Student();
// 실행문 1개, 2개 둘 다 가능함.
```

- 클래스가 1개뿐이어도 new 연산자를 사용한 만큼 객체를 메모리에 생성할 수 있음. 이러한 객체들은 Student 클래스의 인스턴스임.
- 비록 같은 클래스로부터 생성되었지만 각각의 Student 객체는 자신만의 고유 데이터를 가지면서 메모리에서 활동함. s1과 s2가 참조하는 Student 객체는 완전히 독립된 서로 다른 객체임.



#### Student와 StudentExample 클래스의 용도

- 클래스의 용도는 두 가지로, 하나는 라이브러리(API: Application Program Interface)용이고 다른 하나는 실행용임.
- 라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계됨. 프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리 클래스임.
- 실행 클래스는 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할을 함.
- 대부분의 객체 지향 프로그램은 라이브러리(부품 객체 및 완성 객체)와 실행 클래스가 분리되어 있음.



### 1.6. 클래스의 구성 멤버

- 클래스에는 객체가 가져야 할 구성 멤버가 선언됨.
- 구성 멤버에는 필드(Field), 생성자(Constructor), 메소드(Method)가 있음.
- 구성 멤버들은 생략되거나 복수의 개수로 작성될 수 있음.



#### 필드

- 필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳.
- 선언 형태는 변수와 비슷하지만, 필드를 변수라고 부르지는 않음.
- 변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸되지만, 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재함.



#### 생성자

- 생성자는 new 연산자로 호출되는 특별한 중괄호 {} 블록임.
- 생성자의 역할은 객체 생성 시 초기화를 담당함.
- 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 함.
- 생성자는 메소드와 비슷하게 생겼지만, 클래스 이름으로 되어 있고 리턴 타입이 없음.



#### 메소드

- 메소드는 객체의 동작에 해당하는 중괄호 {} 블록을 말함.
- 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행됨.
- 메소드는 객체 간의 데이터를 전달하는 수단.



## 2. 필드

- 필드 : 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳
- 자동차 객체
  - 제작회사, 모델, 색깔, 최고 속도는 고유 데이터에 해당함.
  - 현재 속도, 엔진 회전 수는 상태 데이터에 해당함.
  - 차체, 엔진, 타이어는 부품에 해당함.



### 2.1. 필드 선언

- 필드 선언은 클래스 중괄호 {} 블록 어디서든 존재할 수 있지만, 생성자와 메소드 중괄호 {} 블록 내부에는 선언될 수 없음.
- 필드의 선언 형태는 변수와 비슷하지만, 필드를 변수라고 부르지는 않음. 구분해야 함.
- 초기값이 지정되지 않은 필드는 객체 생성 시 자동으로 기본 초기값으로 설정됨.



### 2.2. 필드 사용

- 필드를 사용한다는 것은 필드값을 읽고 변경하는 작업을 말함.
- 클래스 외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야 함.
- 필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않음.

```java
//Car 클래스
int speed; // 필드
Car(){ // 생성자
	speed = 0; // 생성자에서 필드값 변경 가능함.
}
void method(...){
	speed = 10; // 메소드에서 필드값 변경 가능함.
}
// 필드는 생성자와 모든 메소드에서 사용이 가능함.
```

```java
//Person 클래스
void method(){
	//1) Car 객체 생성
	Car myCar = new Car();
	
	//2) 필드 사용
	myCar.speed = 60;
}
//외부 Person 클래스에서 Car 클래스의 speed 필드값을 사용하려면 Car 객체를 우선 생성해야 함.
```

- 도트(.) 연산자는 객체 접근 연산자로 객체가 가지고 있는 필드나 메소드를 사용하고자 할 때 사용됨.



## 3. 생성자

- 생성자는 new 연산자로 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당함.
- 생성자는 객체 생성 시 초기화를 담당하며, 모든 클래스에 반드시 하나 이상 존재함.
- 클래스 내부에 선언을 생력하면 기본 생성자가 자동으로 추가됨.
- 객체 초기화 : 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 하는 것을 말함.
- new 연산자에 의해 생성자가 성공적으로 실행되면 힙 영역에 객체가 생성되고 객체의 번지가 리턴됨.
- 리턴된 객체의 번지는 클래스 변수에 저장됨.



### 3.1. 기본 생성자

- 클래스 내부에 생성자 선언을 생략했다면 컴파일러는 중괄호 {} 블록 내용이 비어 있는 기본 생성자(Default Constructor)를 바이트 코드에 자동으로 추가함.

```java
[public] 클래스() { }
//생성자 선언 생략시 컴파일러에 의해 자동으로 기본 생성자 추가됨.
```

- 클래스가 public class로 선언되면 기본 생성자에서도 public이 붙지만, 클래스가 public 없이 class로만 선언되면 기본 생성자에서도 public이 붙지 않음.
- 클래스에 생성자를 선언하지 않아도 new 연산자 뒤에 기본 생성자를 호출해서 객체를 생성할 수 있음.

```java
Car myCar = new Car();
// Car() << 기본 생성자
```

- 클래스에 명시적으로 생성자를 선언하는 이유는 객체를 다양한 값으로 초기화하기 위해서임.



### 3.2. 생성자 선언

```java
클래스 ( 매개변수선언, ... ) {
	// 객체의 초기화 코드
}
```

- 생성자는 리턴 타입이 없고, 생성자의 이름은 클래스 이름과 동일함.
- 생성자 블록 내부에는 객체 초기화 코드가 작성됨.
- 매개 변수 선언은 생략할 수도 있고 여러 개를 선언할 수도 있음.
- 매개 변수는 new 연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할을 함.

```java
Car myCar = new Car("그랜져", "검정", 300);
// 대입연산자 오른쪽의 new Car(...)에서 Car 부분이 생성자임.
```

```java
public class Car {
	//생성자
	Car(String model, String color, int maxSpeed) { ... }
}
```

- Car 생성자를 호출할 때 3개의 매개값이 제공되었으므로 세 매개값을 생성자가 받기 위해서는 생성자도 매개 변수를 선언해야 함.
- 클래스에 생성자가 명시적으로 선언되어 있을 경우, 반드시 선언된 생성자를 호출해서 객체를 생성해야 하고 이 과정에서 매개값도 제공되어야 함. 클래스에 생성자 선언이 있다면 기본 생성자(Car())를 호출해서 객체를 생성할 수 없음. 매개변수가 있는 생성자를 호출해야 함.

```java
//클래스 생성
public class Car {
	//생성자
	Car(String color, int cc) {
	}
}
```

```java
//생성자 호출
public class CarExample {
	public static void main(String[] args) {
	Car myCar = new Car("검정", 3000);
	//Car myCar = new Car(); // (x) 기본 생성자 호출 불가능함.
    }
}
```



### 3.3. 필드 초기화

- 클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정됨.
- 기본 초기값 외에 다른 값으로 초기화하는 방법
  - 1) 필드를 선언할 때 초기값을 줄 수 있음. -> 객체 생성 시점에 값이 고정적인 경우
  - 2. 생성자에서 매개값으로 외부 값을 받아 필드에 초기값을 줄 수 있음. -> 객체 생성 시점에 다양한 값을 가져야 하는 경우



#### 필드 선언할 때 초기화

- 필드를 선언할 때 초기값을 주게 되면 동일한 클래스로부터 생성되는 객체들은 모두 같은 값을 갖게 됨.

- ```java
  public class Korean {
  String nation = "대한민국";
  }
  ```

- ```java
  Korean k1 = new Korean();
  Korean k2 = new Korean();
  // k1과 k2 객체의 nation 필드에는 모두 "대한민국"이 저장되어 있음.
  ```



#### 생성자 매개 변수로 필드 초기화

- 객체 생성 시점에 다양한 필드 값을 가져야 할 경우 생성자의 매개 변수로 이 값들을 받아 필드를 초기화할 수 있음.

- ```java
  public class Korean {
  	//필드
  	String nation = "대한민국";
  	String name;
  	String ssn;
  
  	//생성자
  	public Korean(String n, String s){ // 필드값 초기화 위해 매개변수선언
  		name = n; // 필드값 초기화
  		ssn = s; // 필드값 초기화
  	}
  }
  ```

- ```
  Korean k1 = new Korean("김자바", "011225-1234567");
  Korean k2 = new Korean("이자바", "000505-2134567");
  ```



#### this. 참조 변수

- Korean 생성자의 매개 변수 이름은 각각 n과 s를 사용함.
- 매개 변수의 이름이 너무 짧으면 코드의 가독성이 좋지 않기 때문에 가능하면 초기화시킬 필드 이름과 동일한 이름을 사용하는 것이 좋음.
- 필드와 생성자 매개 변수 이름 동일하면 생성자 매개 변수가 사용 우선순위가 높기 때문에 생성자 내부에서 해당 필드에 접근할 수 없음.
- 이를 해결하기 위해 필드 앞에 'this.'을 붙임.
- this는 객체 자신의 참조임.

- ```java
  //생성자
  public class Korean (String name, String ssn){
  	this.name = name; // 필드 이름과 매개 변수 이름이 동일할 때 필드 앞에 this. 사용
  	this.ssn = ssn;
  }
  ```



- 일반적으로 중요한 몇 개의 필드만 생성자 매개 변수으로 초기화함.
- 나머지 필드들은 필드 선언 시에 초기화하거나 생성자 내부에서 임의의 값 또는 계산된 값으로 초기화함.
- 객체 생성 후에 필드값을 별도로 저장하기도 함.



### 3.4. 생성자 오버로딩

- 생성자 오버로딩(overloading) : 매개 변수를 달리하는 생성자를 여러 개 선언하는 것.
- 오버로딩의 목적 : 외부에서 제공되는 다양한 데이터들을 이용해서 객체를 초기화하려면 생성자도 다양화될 필요가 있음
  - 외부 제공 데이터가 없을 때, model 데이터만 제공될 때, model과 color 데이터 2개 제공될 때 등 어떤 경우에도 Car 객체를 생성할 수 있어야 함.
  - 만약 생성자가 1개라면 이러한 다양한 요구 조건을 수용할 수 없음.
- 생성자 오버로딩 하는 방법 : 매개 변수의 타입, 개수, 순서를 다르게 해서 선언하면 됨.

```java
public class Car {
	Car() {...}
	Car(String model) {...}
	Car(String model, String color) {...}
	Car(String model, String color, int maxSpeed) {...}
}
```

- 매개 변수의 타입과 개수 그리고 선언된 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이 아니라는 점을 주의해야 함.

```java
Car(String model, String color) {...}
Car(String color, String model) {...} // 생성자 오버로딩이 아님
```

- 생성자가 오버로딩되어 있을 경우(다양한 경우에 대비해 생성자들이 많이 선언되어 있는 경우) new 연산자로 생성자를 호출할 때 제공되는 매개값의 타입과 수가 일치하는 생성자가 호출됨.



### 3.5. 다른 생성자 호출: this()

- this()는 객체 자신의 또 다른 생성자를 호출할 때 사용하는 코드
- this() 사용하는 이유 : 생성자 오버로딩이 많아질 때 생성자 간의 중복된 코드를 제거하여 코딩을 쉽게하기 위해서.
- this()는 반드시 생성자의 첫 줄에서만 사용해야 함.

```java
//중복이 많은 생성자 오버로딩
public class Car {
	//필드
	String company = "현대자동차";
	String model;
	String color;
	int maxSpeed;
	
	//생성자
	Car(){
	}
	
	Car(String model){			//중복코드
		this.model = model;
		this.color = "은색";
		this.maxSpeed = 250;
	}
	
	Car(String model, String color){			//중복코드
		this.model = model;
		this.color = color;
		this.maxSpeed = 250;
	}
	
	Car(String model, String color, int maxSpeed){			//중복코드
		this.model = model;
		this.color = color;
		this.maxSpeed = maxSpeed;
	}
}
```

```java
// this() 사용으로 다른 생성자 호출해서 중복 코드 줄이기
public class Car {
	//필드
	String company = "현대자동차";
	String model;
	String color;
	int maxSpeed;
	
	//생성자
	Car(){
	}
	
	Car(String model){						//호출
		this(model, "은색", 250);
	}
	
	Car(String model, String color){		//호출
		this(model, color, 250);
	}
	
	Car(String model, String color, int maxSpeed){	// 공통 실행 코드
		this.model = model;
		this.color = color;
		this.maxSpeed = maxSpeed;
	}
}

```



## 4. 메소드

- 메소드 : 객체의 동작에 해당하는 중괄호{} 블록.
- 메소드 선언은 선언부와 실행 블록으로 구성됨.
- 메소드 선언부를 메소드 시그니처(signature)라고 함.
- 선언부와 실행 블록에서는 다음 요소를 포함함.
  - 리턴 타입 : 메소드가 리턴하는 결과의 타입을 표시.
  - 메소드 이름 : 메소드의 기능이 드러나도록 식별자 규칙에 맞게 이름을 지어야 함.
  - 매개 변수 선언 : 메소드를 실행할 때 필요한 데이터를 받기 위한 변수를 선언.
  - 메소드 실행 블록 : 실행할 코드를 작성.

```java
리턴타입 메소드이름 ( [매개변수선언, ... ] ) {
	...
	실행할 코드를 작성하는 곳
	...
}
```



### 4.1. 메소드 선언



#### 리턴 타입

- 리턴 타입은 리턴값의 타입을 말함.

- 리턴값이란 메소드를 실행한 후의 결과값을 말함.

- 메소드는 리턴값이 있을 수도 있고 없을 수도 있음.

- 리턴값이 없는 메소드는 리턴 타입에 void로 기술하며, 리턴값이 있는 메소드는 리턴값의 타입을 기술함.

- 리턴값 유무에 따른 메소드 호출 방법

  - 리턴값이 없는 경우 : 단순히 메소드만 호출하면 됨.

  - 리턴값이 있는 경우 : 리턴값을 받기 위한 변수는 메소드의 리턴 타입을으로 선언되어야 함.

  - 리턴값을 받기 위한 변수를 더 작은 타입으로 선언하게 되면 컴파일 에러 발생함.

  - 리턴값이 중요하지 않고, 메소드 실행이 중요할 경우 변수를 선언하지 않고 메소드를 호출할 수도 있음.

  - ```java
    powerOn(); // 리턴값이 없는 경우
    double result = divide( 10, 20 ); // 리턴값이 있는 경우. 나누기 결과 타입이 double이므로 double 타입 변수 선언.
    
    int result = divide ( 10, 20 ); // 컴파일 에러 발생
    
    divide ( 10, 20 ); // 리턴 값이 있어도 변수를 선언하지 않고 메소드를 호출할 수도 있음.
    ```



#### 메소드 이름

- 메소드 이름은 자바 식별자 규칙에 맞게 작성하면 됨.



#### 매개 변수 선언

- 매개 변수는 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용됨.

- 메소드 호출 시 제공되는 매개값은 메소드 선언부의 매개 변수에 차례대로 대입되어, 메소드 블록 실행 시 이용됨.

- 호출 시 넘겨준 매개값은 반드시 매개 변수의 타입에 부합되는 값이어야 함.

- ```java
  double divide ( int x, int y ) {...} // int타입으로 매개 변수 선언
  double result = divide( 10, 20 ); // 호출시 넘겨준 매개값도 int 타입에 부합되는 정수.
  
  double result = divide ( 10.5, 20.0 ); // 컴파일 에러 발생.
  ```

- 호출 시 넘겨준 매개값이 매개 변수의 타입보다 작은 값이면 자동 타입 변환이 일어나 에러가 발생하지 않음.



#### 매개 변수의 개수를 모를 경우

- 매개 변수의 개수를 모를 경우 매개 변수를 배열 타입으로 선언해야 함.
- 메소드를 호출할 때 매개값으로 배열을 넘겨주면 됨. 배열의 항목 수는 호출할 때 결정됨.

```java
int sum1(int[] values){...} // 매개 변수로 배열 타입 선언

int[] numbers = {1, 2, 3};
int result = sum1(numbers); // 1) 미리 초기화된 배열을 매개값으로 넘겨줌.
int result = sum1(new int[] {1, 2, 3, 4, 5}); // 2) 새 배열을 생성하여 매개값으로 넘겨줌.
```

- 배열을 생성하지 않고 값의 목록만 넘겨주는 방법

```java
int sum2(int ... values){...} // ...을 사용해서 매개 변수 선언.

int result = sum2(1, 2, 3); // 3) 매개 변수의 값은 메소드 호출 시 쉼표로 나열해주면 됨.

int[] numbers = {1, 2, 3};
int result = sum1(numbers);
int result = sum1(new int[] {1, 2, 3, 4, 5}); // ... 사용해서 매개 변수 선언하면 1), 2), 3) 방법 모두 사용 가능
```



### 4.2. 리턴(return)문



#### 리턴값이 있는 메소드

- 메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴(return)문을 사용해서 리턴값을 지정해야 함.
- return문이 실행되면 메소드는 즉시 종료됨. return문 이후의 실행문은 결코 실행되지 않음.
- return 이후에 실행문이 오면 Unreachable code 컴파일 에러 발생.
- return문의 리턴값 타입이 메소드 선언부의 리턴 타입보다 작을 경우 자동 타입 변환되어 상관없음.



#### 리턴값이 없는 메소드

- 리턴값이 없는 메소드는 리턴 타입으로 void를 사용함.
- void로 선언된 메소드에서도 return문을 사용할 수 있음. 이 경우 리턴값 없이 `return;`만 사용하여 메소드 실행을 강제 종료시키는 역할을 함.



### 4.3. 메소드 호출



#### 객체 내부에서 호출

- 클래스 내부의 다른 메소드에서 호출할 경우 단순한 메소드 이름으로 호출 가능.

```java
메소드( 매개값, ... ); // 리턴값이 없거나, 있어도 받고 싶지 않을 경우
타입 변수 = 메소드( 매개값, ... ); // 리턴값을 받고 싶은 경우
```

- 이때 변수 타입은 메소드 리턴 타입과 동일하거나, 자동 타입 변환이 될 수 있어야 함.

```java
//클래스 내부에서 메소드 호출
public class Calculator {
	int plus(int x, int y){
	int result = x + y;
	return result;
	}
	
	double avg(int x, int y){
	double sum = plus(x, y);
	avg = sum / 2;
	return avg;
	}
	
	void execute(){
	double result = avg(7, 10);
	println("실행결과 : " + result);
	}
	
	void println(String message){
	System.out.println(message);
	}
}
```

- execute 메소드 호출될 때 일어나는 일

- 1. execute() 메소드 실행

  2. avg() 메소드 실행

  3. plus() 메소드 실행

  4. plus 리턴값

  5. avg 리턴값

  6. println() 메소드 실행

  7. 종료.



#### 객체 외부에서 호출

- 클래스 외부에서 호출할 경우 우선 클래스로부터 객체를 생성한 뒤 참조 변수를 이용해서 메소드를 호출해야 함.
- 메소드는 객체에 소속된 멤버이므로 객체가 존재하지 않으면 메소드도 존재하지 않음.
- 객체가 생성되었다면 참조 변수와 함께 도트(.) 연산자를 사용해서 메소드를 호출할 수 있음.
- 도트(.) 연산자는 객체 접근 연산자로 객체가 가지고 있는 필드나 메소드에 접근할 때 사용됨.



### 4.4. 메소드 오버로딩

- 메소드 오버로딩 : 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것.
- 메소드 오버로딩이 필요한 이유 : 매개값을 다양하게 받아 처리할 수 있도록 하기 위해서.
- 메소드 오버로딩의 조건 : 매개 변수의 타입, 개수, 순서 중 하나가 달라야 함.
- 매개 변수의 타입이 일치하는 메소드가 없을 경우 JVM은 자동 타입 변환이 가능한지 검사함.
- 주의할 점
  - 매개 변수의 타입과 개수, 순서가 똑같을 경우 매개 변수 이름이 다르더라도 메소드 오버로딩이 아님.
  - 리턴 타입만 다르고 매개 변수가 동일하다면 오버로딩이 아님.



## 5. 인스턴스 멤버와 정적 멤버



### 5.1. 인스턴스 멤버와 this



### 5.2. 정적 멤버와 static

- 객체마다 다른 값 -> 인스턴스 필드로 선언
- 객체마다 다를 필욕 ㅏ없는 필드 값 -> 정적 필드로 선언
- 정적메소드선언시주의사항
  - 내부에 인스턴스 필드 및 메소드 사용 불가
  - this 키워드 사용 불가
- 인스턴스 멤버 사용하고 싶을 때 : 객체 우선 생성 후 참조 변수로 접근.



### 5.3. 싱글톤

- 전체 프로그램에서 단 하나의 객체만 만들도록 보장하는 코딩 기법
- 작성 방법
  - 클래스 외부에서 new 연산자 통해 생성자 호출하는 것 불가하도록 private 접근 제한자 사용
  - 자신의 타입인 정적 필드 선언 후 자신의 객체 생성해 초기화
  - 정적 필드로 자기 자신의 타입 변수 생성하면서 new 객체 생성(클래스 안쪽에서는 사용가능)
  - 외부에서 호출할 수 있는 getInstance() 선언
  - getInstance() 에서 필드에서 1개 객체 생성한 클래스 변수 리턴.







### 5.4. final 필드와 상수

- 초기값이 지정되면 최종값이 되어 프로그램 실행 도중 수정 불가
- 초기값 주는 방법
  - 단순 값일 경우 필드 선언시 초기화
  - 객체 생성시 외부 데이터 초기화 필요한 경우 생성자에서 초기화



## 6. 패키지와 접근 제한자



### 6.1. 패키지 선언



### 6.2. 접근 제한자



### 6.3. 클래스의 접근 제한



### 6.4. 생성자의 접근 제한



### 6.5. 필드와 메소드의 접근 제한



### 6.6. Getter와 Setter 메소드

