# 상속





> 이 문서는 [<혼자 공부하는 자바 - 신용권>](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791162241875&orderClick=LAG&Kc=) 책을 보고 정리한 문서입니다.



## 1. 상속

- 객체 지향 프로그래밍에서는 부모 클래스의 멤버를 자식 클래스에게 물려줄 수 있음.
- 프로그램에서는 부모 클래스를 상위 클래스라고 부르고, 자식 클래스를 하위 클래스 또는 파생 클래스라고 부름.
- 상속은 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 중복되는 코드를 줄여 줌.
- 상속을 이용하면 부모 클래스의 수정으로 모든 자식 클래스들도 수정되는 효과를 가져오기 때문에 유지 보수 시간을 최소화할 수도 있음.



### 1.1. 클래스 상속

- 자식 클래스를 선언할 때 어떤 부모 클래스를 상속받을 것인지 결정하고, 선택된 부모 클래스는 extends 뒤에 기술함.

```java
class 자식클래스 extends 부모클래스{
	// 필드
	// 생성자
	// 메소드
}
```

#### 자바에서 상속의 특징

- 여러 개의 부모 클래스를 상속할 수 없음. extends 뒤에는 단 하나의 부모 클래스만 와야 함.
- 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외됨.
- 부모와 자식 클래스가 다른 패키지라면 default 접근 제한을 갖는 필드와 메소드도 상속 대상에서 제외됨.



### 1.2. 부모 생성자 호출

- 자바에서 자식 객체를 생성하면, 부모 객체가 먼저 생성되고 그 다음에 자식 객체가 생성됨.

```java
DmbCellPhone dmbCellPhone = new DmbCellPhone();
```

- 모든 객체는 클래스의 생성자를 호출해야만 생성됨.
- 상속에서 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출됨.
- 자식 클래스의 생성자가 명시적으로 선언되지 않았다면 컴파일러는 다음과 같은 기본 생성자를 생성함.

```java
public 자식클래스(){
	super();
}
```

- `super()`는 부모의 기본 생성자를 호출함.
- 직접 자식 생성자를 선언하고 명시적으로 부모 생성자를 호출하고 싶다면 다음과 같이 작성하면 됨.

```java
자식클래스(매개변수선언, ...){
	super(매개값, ...);
}
```

- `super()`는 매개값의 타입과 일치하는 부모 생성자를 호출함.
- 만약 매개값의 타입과 일치하는 부모 생성자가 없을 경우 컴파일 에러가 발생.
- 부모 클래스에 기본 생성자가 없고 매개 변수가 있는 생성자만 있다면 자식 생성자에서 반드시 부모 생성자 호출을 위해 `super(매개값, ...)`를 명시적으로 호출해야 함.
- `super(매개값, ...)`는 반드시 자식 생성자 첫 줄에 위치해야 하며, 그렇지 않으면 컴파일 에러가 발생함.



### 1.3. 메소드 재정의

- 메소드 재정의(오버라이딩: Overriding) : 상속 과정에서 자식 클래스가 사용하기에 적합하지 않은 일부 메소드를 자식 클래스에서 다시 수정해서 사용하는 것.



#### 메소드 재정의 방법

- 부모의 메소드와 동일한 시그니처(리턴 타입, 메소드 이름, 매개 변수 목록)를 가져야 함.
- 접근 제한을 더 강하게 재정의할 수 없음.
  - 부모 메소드가 pubilc 접근 제한을 가지고 있는 경우 재정의하는 자식 메소드는 default나 private 접근 제한으로 수정할 수 없음.
  - 반대로 접근 제한을 완화하는 것은 가능함.
- 새로운 예외(Exception)를 throws할 수 없음.
- @Override
  - 어노테이션. 메소드 재정의 최상단에 표기. 생략해도 좋으나 이것을 붙여주면 컴파일러가 정확히 확인하기 때문에 오타 등의 개발자의 실수를 줄여줌.
- 이클립스에서 재정의 메소드 자동 생성
  - 이클립스 [Source] - [Override/Implement Methods] 메뉴에서 부모 클래스에서 재정의될 메소드를 선택하고 [OK]버튼 클릭.
  - Ctrl + space 누른 후 Override할 메소드 선택하고 엔터 클릭.



#### 부모 메소드 호출

- 자식 클래스에서 부모 클래스의 메소드를 재정의하게 되면, 부모 클래스의 메소드는 숨겨지고 재정의된 자식 메소드만 사용됨.
- 자식 클래스 내부에서 재정의된 부모 클래스의 메소드를 호출해야 하는 상황이 발생한다면 명시적으로 super 키워드를 붙여서 부모 메소드를 호출할 수 있음.

```java
super.부모메소드();
```

- 부모 클래스의 메소드에 조건을 추가하면서 오버라이딩 할 때 super.부모메소드 이용됨.



### 1.4. final 클래스와 final 메소드

- final이 지정되면 초기값 설정 후 더 이상 값을 변경할 수 없음.
- 클래스와 메소드를 선언할 때 final 키워드가 지정되면 상속과 관련이 있다는 의미임.



#### 상속할 수 없는 final 클래스

- 클래스를 선언할 때 final 키워드를 class 앞에 붙이면 상속할 수 없는 클래스가 됨.
- final 클래스는 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없음.

```java
public final class 클래스 {...}
```

- 자바 표준 API에서 제공하는 String 클래스가 final 클래스로 선언되어 있음. 자식 클래스를 만들 수 없음.



#### 재정의할 수 없는 final 메소드

- 메소드를 선언할 때 final 키워드를 붙이면 재정의할 수 없는 메소드가 됨.
- 부모 클래스를 상속해서 자식 클래스를 선언할 때 부모 클래스에 선언된 final 메소드는 자식 클래스에서 재정의할 수 없음.

```java
public final 리턴타입 메소드([매개변수, ...]){...}
```



### 1.5. protected 접근 제한자

- protected : 같은 패키지에서는 default와 같이 접근 제한이 없지만 다른 패키지에서는 자식 클래스만 접근을 허용함.
- protected는 필드와 생성자, 메소드 선언에 사용될 수 있음.



## 2. 타입 변환과 다형성

- 다형성 : 사용 방법은 동일하지만 다양한 객체를 이용해서 다양한 실행결과가 나오도록 하는 성질.
- 자동차가 타이어를 사용하는 방법은 동일하지만 어떤 타이어를 장착하느냐에 따라 주행 성능이 달라질 수 있음.
- 다형성을 구현하려면 메소드 재정의와 타입 변환이 필요함.



### 2.1. 자동 타입 변환

- 클래스의 타입 변환은 상속 관계에 있는 클래스 사이에서 발생.
- 자식 클래스는 부모 클래스 타입으로 자동 타입 변환이 가능함.

```java
부모타입 변수 = 자식타입;
// 자동 타입 변환 발생.
```





### 2.2. 필드의 다형성



### 2.3. 매개 변수의 다형성



### 2.4. 강제 타입 변환



### 2.5. 객체 타입 확인







## 3. 추상 클래스



### 3.1. 추상 클래스의 용도



### 3.2. 추상 클래스 선언



### 3.3. 추상 메소드와 재정의





