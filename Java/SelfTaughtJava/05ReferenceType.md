# 참조 타입



> 이 문서는 [<혼자 공부하는 자바 - 신용권>](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791162241875&orderClick=LAG&Kc=) 책을 보고 정리한 문서입니다.



## 1. 참조 타입과 참조 변수



### 1.1. 기본 타입과 참조 타입

- 기본 타입(primitive type) : 정수, 실수, 문자, 논리 리터럴을 저장하는 타입
- 참조 타입(reference type) : 객체(object)의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스를 말함.
- 기본 타입은 스택 영역에서 변수에 값을 직접 저장하지만, 참조 타입은 힙 영역에 있는 객체의 주소를 스택 영역에 있는 변수에 저장함.



### 1.2. 메모리 사용 영역

- JVM은 운영체제에서 할당받은 메모리 영역(Runtime Data Area)을 메소드 영역, 힙 영역, JVM 스택 영역으로 구분하여 사용함.
  - 메소드 영역(Method Area) : JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역.
  - 힙 영역(Heap Area) : 객체와 배열이 생성되는 영역. 참조하는 변수나 필드가 없을 경우 JVM이 이것을 쓰레기로 취급하고 쓰레기 수집기(Garbage Collector)를 실행시켜 자동으로 제거함.
  - JVM 스택 영역(JVM Stack Area) : 메소드를 호출할 때마다 프레임을 추가하고 메소드가 종료되면 해당 프레임을 제거하는 동작을 수행함.



### 1.3. 참조 변수의 ==, != 연산

- 참조 타입 변수의 값은 힙 영역의 객체 주소.
- 참조 타입 변수의 ==, != 연산은 참조하는 객체의 번지 값을 비교하는 연산.
- 일반적으로 if문 조건식에서 많이 사용됨.



### 1.4. null과 NullPointerException

- null
  - 참조 타입 변수는 null 값을 가질 수 있음. 이는 힙 영역의 객체를 참조하지 않는다는 뜻.
  - null 값도 초기값으로 사용할 수 있음. null로 초기회된 참조 변수는 스택 영역에 생성됨.
- NullPointerException
  - 자바는 프로그램 실행 도중에 발생하는 오류를 예외(Excepton)라고 부름.
  - 예외는 사용자의 잘못된 입력, 프로그래머가 코드를 잘못 작성하는 경우 등에 발생함.
  - NullPointerException은 참조 객체가 없는 참조 변수를 사용할 경우 발생하는 예외. 참조 변수를 사용하면서 가장 많이 발생하는 예외임.



### 1.5. String타입

- String은 참조 타입 변수임. 문자열은 변수에 값이 직접 저장되지 않음. 문자열은 String 객체로 생성되고 변수는 String 객체를 참조함.
- new 연산자 : 힙 영역에 새로운 객체를 만들 때 사용하는 연산자로 객체 생성 연산자라고 함.
- 동일한 문자열 리터럴로 String 객체를 생성했을 경우 같은 String 객체를 참조하지만, new 연산자로 String 객체를 생성했을 경우 String 객체가 하나 더 생성되어 동일한 문자열임에도 서로 다른 객체를 참조하게 됨.

- 문자열 값 자체를 비교하고 싶을 때는 String 객체의 equals() 메소드를 사용해야 함.

  - ```java
    boolean result = str1.equals(str2);
    ```



## 2. 배열



### 2.1. 배열이란?

- 배열은 같은 타입의 데이터를 앤속된 공간에 나열하고, 각 데이터에 인덱스(index)를 부여해놓은 자료구조.
- 배열은 같은 타입의 데이터만 저장할 수 있음. 다른 타입의 값을 저장하려고 하면 타입 불일치(Type mismatch) 컴파일 에러 발생.
- 한 번 생성된 배열은 길이를 늘리거나 줄일 수 없음. 더 많은 값을 저장해야 하는 경우는 새로운 배열을 생성하고 기존 배열을 복사해야 함.



### 2.2. 배열 선언



- ```java
  형식1 : 타입[] 변수;
  형식2 : 타입 변수[];
  ```

- 배열 변수도 참조 변수이므로 null 값으로 초기화 가능.



### 2.3. 배열 생성

#### 값 목록으로 배열 생성

- ```java
  타입[] 변수 = { 값0, 값1, 값2, 값3, ... };
  ```

- 중괄호 {}는 주어진 값들을 항목으로 가지는 배열 객체를 힙에 생성하고, 배열 객체의 번지를 리턴함.

- 배열 변수는 리턴된 번지를 저장함으로써 참조가 이루어짐.

- 배열 변수를 이미 선언한 후에는 다른 실행문에서 중괄호를 사용한 배열 생성이 허용되지 않음.

- ```java
  타입[] 변수;
  변수 = { 값0, 값1, 값2, 값3, ... }; // <<<<< 컴파일 에러 발생
  ```

- 메소드의 매개값이 배열일 경우 new 연산자 사용해야 함.



#### new 연산자로 배열 생성

- 값의 목록을 가지고 있지 않지만, 향후 값들을 저장할 배열을 미리 만들고 싶을 때 new 연산자 사용함.

- ```java
  타입[] 변수 = new 타입[길이];
  ```

- 이미 배열 변수가 선언된 경우에도 new 연산자로 배열을 생성할 수 있음.

- new 연산자도 배열을 처음 생성할 경우 배열은 자동적으로 기본값으로 초기화됨. 숫자는 0, 논리 타입은 false, 참조 타입은 null로 초기화됨.

- 배열 생성 후 특정 인덱스 위치에 새로운 값을 저장하려면 대입 연산자 사용.

- ```java
  변수[인덱스] = 값;
  ```



### 2.4. 배열 길이

- 배열 길이는 배열에 저장할 수 있는 전체 항목의 개수를 말함.

- 코드에서 배열의 길이를 얻으려면 배열 객체의 length필드를 읽어야 함.

- ```java
  배열 변수.length;
  ```

- length 필드는 읽기 전용 필드이기 때문에 값을 바꿀 수가 없음.



### 2.5. 명령 라인 입력

- ```java
  public static void main(String[] args) {...}
  ```

- 위 코드를 실행하면 JVM은 길이가 0인 String 배열을 먼저 생성하고 main() 메소드를 호출할 때 매개값으로 전달함.

- 문자열 목록을 미리 String[] arg에 주고 실행하면, 문자열 목록으로 구성된 String[] 배열이 생성되고 main() 메소드를 호출할 때 매개값으로 전달함.

- main() 메소드는 String[] args 매개 변수를 통해 명령 라인에서 입력된 데이터의 수(배열의 길이)와 입력된 데이터(배열의 항목 값)를 알 수 있음.

- 이클립스에서 매개값 주고 실행하기

  - 1) [Run] - [Run Configurations] 메뉴 선택
    2) [Run Configurations] 대화 상자의 [Main] 탭에서 [Project]와 [Main Class] 확인
    3) [Arguments] 탭을 클릭하고 [Program arguments] 입력란에 '10 20' 입력 후 [Apply] 버튼 클릭
    4) [Run] 아이콘 실행

- 명령 프롬프트에서 매개값 주고 실행하기

  - 실행 위치는 C:\워크스페이스 폴더\프로젝트\bin

  - ```
    [JDK 11 이후 버전] java -p . -m 프로젝트명/패키지명.클래스명 10 20
    ```

- 이렇게 실행하면 args는 {"10", "20"} 배열을 참조하게 되고 args[0]은 "10", args[1]은 "20"을 얻을 수 있음.

- 문자열로 얻은 값이기 때문에 산술 연산을 하고 싶은 경우 Integer.parseInt() 메소드를 이용하여 정수 변환한 후에 산술 연산해야 함.



### 2.6. 다차원 배열

- 값들이 행과 열로서 구성된 배열을 2차원 배열이라고 함.

- 2차원 배열은 수학의 행렬 같은 모양으로, 가로 인덱스와 세로 인덱스를 사용함.

  

#### 행렬 구조

```java
int[][] scores = new int[2][3];
```

- 위 코드는 메모리 힙 영역에 3개의 배열 객체를 생성함
- 배열 변수인 scores는 길이가 2인 배열 A를 참조.
- 배열 A의 scores[0]은 길이가 3인 배열 B를 참조.
- 배열 A의 scores[1]은 길이가 3인 배열 C를 참조.
- scores[0]과 scores[1]은 모두 배열을 참조하는 변수 역할을 함.



#### 계단식 구조

```java
int[][] scores = new int[2][];
scores[0] = new int[2];
scores[1] = new int[3];
```

- 계단식 구조의 배열은 배열의 정확한 길이를 알고 인덱스를 사용해야 함.
- 위의 코드에서 `scores[0][2]`는 ArrayIndexOutOfBoundsException을 발생시킴.



#### 값 목록으로 다차원 배열 생성

```java
타입[][] 변수 = { {값1, 값2, ...}, {값1, 값2, ...}, ... };
```



### 2.7. 객체를 참조하는 배열

- 기본 타입 배열은 각 항목에 직접 값을 갖고 있음.
- 참조 타입(클래스, 인터페이스) 배열은 각 항목에 객체의 번지를 가지고 있음.
- String[] 배열은 각 항목에 문자열이 아니라, String 객체의 번지를 가지고 있음. String[] 배열은 String 객체를 참조하게 됨.
- String[] 배열 항목 간에 문자열을 비교하기 위해서는 == 연산자 대신 equals() 메소드를 사용해야 함.



### 2.8. 배열 복사

- 배열은 한 번 생성하면 크기를 변경할 수 없음. 더 많은 저장 공간이 필요하다면 더 큰 배열을 새로 만들고 이전 배열로부터 항목 값들을 복사해야 함.
- 배열 간의 항목 값들을 복사하려면 for문을 사용하거나 System.arraycopy() 메소드를 사용함.



#### for문으로 배열 복사

```java
public static void main(String[] args) {
	int[] oldIntArray = { 1, 2, 3 };
	int[] newIntArray = new int[5];
	
	for(int i=0; i<oldIntArray.length; i++){ // for문으로 배열 복사
		newIntArray[i] = oldIntArray[i];
	}
	
	for(int=0; i<newIntArray.length; i++) { // System.arraycopy() 메소드로 배열 복사
		System.out.print(newIntArray[i] + ", ");
	}
} // 실행결과는 1, 2, 3, 0, 0
```



#### System.arraycopy() 메소드로 배열 복사

```java
System.arraycopy(원본 배열, 시작 인덱스, 대상 배열, 시작 인덱스, 복사할 개수);
```

- 복사되지 않는 항목은 String[] 배열의 초기값 null
- 원본 배열의 길이를 초과하여 복사할려고 시도할 경우 ArrayIndexOutOfBoundsException 발생.
- 일반적으로 '시작 인덱스'에는 0을 넣고 '복사할 개수'에는 원본 배열.length 넣음



### 2.9. 향상된 for문

- 배열이나 컬렉션을 좀 더 쉽게 처리하기 위해 자바는 향상된 for문을 제공함.
- 루프 카운터 변수와 증감식을 사용하지 않음.
- for문의 반복 횟수는 배열의 항목 수가 됨.
- 기본 형태

```java
for ( 타입 변수 : 배열 ) {
	실행문;
}
```

- 예시

```java
public static void main(String[] args) {
	int[] scores = { 95, 71, 84, 93, 87 };
	
	int sum = 0;
	for (int score : scores){
		sum = sum + score;
	}
	System.out.println("점수 총합 = " + sum);
}
// 실행결과
// 점수 총합 = 430
```



## 3. 열거 타입

- 열거 타입 : 한정된 값인 열거 상수(enumeration constant) 중에서 하나의 상수를 저장하는 타입.



### 3.1. 열거 타입 선언

- 열거 타입의 이름을 정하고 해당 이름으로 소스 파일(.java)을 생성해야 함.
- 이클립스에서 열거 타입 생성
  - Package Explorer 뷰에서 프로젝트를 선택한 다음 [File] - [New] - [Enum] 메뉴 선택
  - [Package] 입력란에는 열거 타입이 속할 패키지 이름을 입력하고, [Name] 입력란에는 열거 타입 이름을 입력한 후 [Finish] 버튼 클릭

- 열거 타입 선언

```java
public enum Week {
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	SATURDAY,
	SUNDAY
}
```

- 열거 상수 : 열거 타입 선언 때 주어진 상수를 말함. 타입.상수 형태로 사용함.
- 예시 : Week 열거 타입의 상수 MONDAY는 Week.MONDAY로 사용함.



### 3.2. 열거 타입 변수

- 열거 타입 변수 선언

```java
열거타입 변수;
// 예시
Week today;
```

- 열거 타입 변수에는 열거 상수 중 하나가 대입됨.
- 열거 상수 대입

```java
열거타입 변수 = 열거타입.열거상수;
// 예시
Week today = Week.SUNDAY;
```

- 열거 타입 변수에는 null 값을 저장할 수 있음.
- 열거 타입은 참조 타입이고 열거 상수는 객체임.
- 예시 `Week today = Week.SUNDAY;`
  - 열거 타입 선언시 MONDAY부터 SUNDAY까지 열거 상수는 총 7개의 Week 객체로 생성됨.
  - 메소드 영역에 생성된 열거 상수가 해당 Week 객체를 각각 참조하게 됨.
  - 열거 타입 변수 today는 스택 영역에 생성됨.
  - today에 저장되는 값은 메소드 영역의 Week.SUNDAY 열거 상수가 참조하는 힙 영역 Week 객체의 번지.
  - `today == Week.SUNDAY; // true`

- 열거 타입 변수는 스택 영역에 생성되고 열거 상수와 같은 객체를 참조함.