# 자바 프로그램 구조와 기초 문법



## 1. 자바 프로그램 기본 구조

### 클래스(class)

- 객체 지향 언어에서 클래스는 프로그램을 개발하는 단위로 적어도 하나의 클래스가 있어야 함.
- 







## 2. 식별자









## 3. 변수

### 변수의 개념

- 변수(Variable)는 값을 저장할 수 있는 메모리의 공간을 의미함.
- 데이터 타입(Data Type)에 따라 가능한 값, 수행할 수 있는 명령, 데이터 의미, 저장하는 방식이 달라짐.
- 특정 타입의 변수에는 해당 타입의 데이터만 저장할 수 있음.



### 데이터 타입

#### 기본타입

| 종류 |  이름   | 크기(byte) | 크기(bit) | 기본값 |                   범위                   |
| ---- | :-----: | :--------: | :-------: | :----: | :--------------------------------------: |
| 정수 |  byte   |   1byte    |   8bit    |   0    |                -128 ~ 127                |
| 정수 |  char   |   2byte    |   16bit   | \0000  |                 0~ 65535                 |
| 정수 |  short  |   2byte    |   16bit   |   0    |             –32,768 ~ 32,767             |
| 정수 |   int   |   4byte    |   32bit   |   0    | –2,147,483,648 ~ 2,147,483,647 (약 20억) |
| 정수 |  long   |   8byte    |   64bit   |   0L   |                매우 큰 값                |
| 실수 |  float  |   4byte    |   32bit   |  0.0F  |      부동소수점 연산(지수부/가수부)      |
| 실수 | double  |   8byte    |   64bit   |  0.0D  |      부동소수점 연산(지수부/가수부)      |
| 논리 | boolean |   1byte    |   8bit    | false  |               true와 false               |



##### byte 타입

- 색상 정보, 파일, 이미지 등의 데이터를 처리할 때 주로 사용됨.
- 정수 타입 중에서 가장 작은 범위의 수를 저장함.
- −2^7  ~ 2^7−1 (-128 ~ 127)
  - 양수가 0을 포함하기 때문에 마지막에 -1 처리를 함.
  - 이 범위를 초과하면 컴파일시 오류가 발생함.
- 1바이트는 총 8칸의 비트 메모리(0,1 둘 중 하나만 표시됨)
  - 1칸은 부호. +,- 표시
  - 7칸. 1,2,4,8,16,32,64
  - 11111111 = 플러스부호+1+2+4+8+16+32+64 = 127



###### byte 타입 값 오류 범위

- 실행 중에 저장할 수 있는 값의 범위를 초과하면 최소값으로 다시 반복 저장됨.
- -128(최소값)부터 시작해서 127(최대값)을 넘으면 다시 -128부터 시작함.
  - 오류가 발생하여 원하지 않는 값이 출력됨.
  - 반대로 1씩 감소될 때는 최소값을 넘어서는 순간 최대값으로 돌아감.



##### char 타입

- 문자는 char 타입을 사용. 비영어권 영어까지 최대 65,000여 개의 문자를 처리할 수 있도록 내부적으로는 2바이트 문자 처리 방식인 유니코드(unicode)를 사용.
- 유니코드는 0 ~ 65535 범위의 2byte 크기를 가진 정수값. 유니코드는 음수가 없기 때문에 char 타입의 변수에는 음수값을 저장할 수 없음.
- 0~127까지는 아스키(ASCII) 문자 (특수기호, 영어 알파벳)가 할당되어 있고, 44032 ~ 55203까지는 한글 11172자가 할당되어 있음.



##### short 타입

- 2byte(16bit)로 표현되는 정수 값을 저장할 수 있는 데이터 타입
- 값의 범위는 -32,768 ~ 32,767
- −2^15~(−2^15−1)
- C언어와의 호환을 위해 사용되며 자바에서는 비교적 잘 사용되지 않음.



##### int 타입

- 4byte(32bit)로 표현되는 정수 값을 저장할 수 있는 데이터 타입
- 값의 범위는 -2,147,483,648 ~ 2,147,483,647 (약 20억)
- −2^31~(2^31−1)
- int 타입은 자바에서 정수를 연산하기 위한 기본 타입.
  - int 타입은 자바에서 정수를 연산하기 위한 기본 타입.
  - 자바에서는 정수 연산을 기본 4byte로 처리함. byte, short 타입으로 계산해도 성능차이가 없음.
- 정수 값에 코드를 붙여 입력할 경우 8진수, 10진수, 16진수, 2진수로 표현할 수 있음.
  - int number = 10;			// 10진수
  - int octNumber = 012;			// 8진수
  - int hexNumber = 0xA;			// 16진수
  - int biNumber = 0b0010;			// 2진수



##### long 타입



##### float 타입



##### double 타입



##### boolean 타입



#### 타입 변환



##### 자동타입변환



##### 강제타입변환



###### 강제타입변환 값 손실



###### 강제타입변환시 주의사항



##### 연산식에서의 자동타입변환



##### 자바의 정수 연산





## 4. 자바 기본 입출력

### 화면에 데이터 출력

- 자바는 처리결과를 consol이라는 cmd 창에 출력함.
  - System.out.println(); -> 괄호 안의 내용을 출력하고 줄바꿈.
  - System.out.print(); -> 괄호 안의 내용을 출력. (줄바꿈x)
  - System.out.printf("포맷 명시자", 데이터1, 데이터2); -> 정해진 포맷에 맞추어 출력.



#### 포맷 명시자

- printf("%d\n", 97) -> 97(10진수) (\n은 줄바꿈 명령)
- printf("%o\n", 97) -> 141(8진수) 
- printf("%x\n", 97) -> 61(16진수)
- printf("%c\n", 97) -> a(char 타입 유니코드)
- printf("%5d\n", 97) -> ___97 (5칸에 10진수 97 넣음. 앞 3칸은 공백이 됨)
- printf("%05d\n", 97) -> 00097 (5칸에 10진수 97 넣음. 앞 3칸은 0이 됨)
- printf("%s\n", "java") -> 문자열 "java" 출력
- printf("%-5s\n", "java") -> 문자열 "java " 출력 (-는 왼쪽정렬, 왼쪽부터 5칸에 문자넣고 나머지 공백이 됨.
- printf("%s\n", "java") -> 문자열 java 출력



### 키보드로 데이터 입력

- scanner 메서드를 활용하여 키보드로 입력 받은 값을 처리하게 구현함.

- 대부분 웹에서 데이터를 입력 받는 것은 String 타입으로 입력 받음.

  - Scanner 객체를 생성하여 변수에 연결하고 변수에는 변수명.nextLine()을 사용하여 실행문에 연결함.

- ```java
  Scanner in = new Scanner(System.in);
  		int x = in.nextInt();
  		int y = in.nextInt();
  		System.out.printf("%d * %d은 %d입니다. \n", x, y, x * y);
  ```

  



## 5. 연산자

### 개념

- 프로그램에서 데이터를 처리하여 결과를 산출하는 것을 연산(operations)이라고 함.
  - 연산자(operator) : 연산에 사용되는 표시나 기호
  - 피연산자(operand) : 연산되는 데이터
  - 연산식(expressions) : 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것



### 연산자의 종류

| 종류   | 연산자                                         | 설명                                           | 비고       |
| ------ | ---------------------------------------------- | :--------------------------------------------- | ---------- |
| 증감   | ++, --                                         | 1만큼 증가 또는 감소한다.                      | 단항       |
| 산술   | +, -, *, /, %                                  | 사칙 연산과 모듈로 연산한다.                   | 이항       |
| 시프트 | >>, <<, >>>                                    | 비트를 좌우로 이동한다.                        | 이항       |
| 부호   | +, -                                           | 부호를 변환한다.                               | 단항       |
| 비교   | >, <, >=, <=, ==, !=, instanceof               | 데이터 값을 비교하거나 데이터 타입을 비교한다. | 이항       |
| 비트   | &, \|, ~, ^                                    | 비트 단위의 AND, OR, NOT, XOR                  | 단항, 이항 |
| 논리   | &&, \|\|, !, ^                                 | 논리적 AND, OR, NOT, XOR                       | 단항, 이항 |
| 조건   | (expr) ? x : y                                 | expr에 따라 x 또는 y로 값을 결정한다.          | 삼항       |
| 대입   | =, +=, -=, *=, /=, &=, \|=, ^=, >>=, <<=, >>>= | 오른쪽 값을 연산해 왼쪽에 대입한다.            | 이항       |



### 연산의 방향과 우선순위

1. 증감(++, --), 부호(+, -), 비트(~), 논리(!)
2. 산술(*, /, %)
3. 산술(+, -)
4. 쉬프트(<<, >>, >>>)
5. 비교(<, >, <=, >=, instanceof)
6. 비교(==, !=)
7. 논리(&)
8. 논리(^)
9. 논리(|)
10. 논리(&&)
11. 논리(||)
12. 조건(?:)
13. 대입(=, +=, -=, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=)

- 1번과 13번만 왼쪽 방향, 나머지는 오른쪽 방향으로 연산
- 복잡한 연산자를 많이 사용할 경우 괄호를 많이 사용할 것



### 단항, 이항, 삼항 연산자

- 단항연산자 : 피연산자 하나만 요구. 부호 연산자와 증감 연산자
- 이항연산자 : 두 개의 피연산자 요구.
- 삼항연산자 : 조건 연산자라고도 함.
- 연산식은 반드시 하나의 값을 산출함. 결과를 저장할 변수 등을 필요로 함.
- 연산식은 다른 연산식의 피연산자 위치에도 올 수 있음.



#### 단항연산자

##### 부호연산자

- 양수 및 음수를 표시하는 +,-를 의미함.
- Boolean 타입과 char 타입을 제외한 나머지의 기본타입에 해당함.
  - +피연산자 -> 피연산자의 부호 유지
  - -피연산자 -> 피연산자의 부호 반전



##### 증감연산자

- 증감연산자는 변수의 값을 1증가(++)시키거나 1감소(--)시키는 연산자.
- boolean타입을 제외하고 모든 기본 타입에 사용됨.
- 증가연산자와 감소연산자는 변수의 앞 뒤 어디에든 올 수 있음.
  - ++x : 연산 전 x값 증가 (전위 증가)
  - --x : 연산 전 x값 감소 (전위 감소) 
  - x++ : 연산 후 x값 증가(후위 증가)
  - x-- : 연산 후 x값 감소(후위 증가)



##### 논리부정연산자(!)

- 논리 부정 연산자는 true를 false로, false를 true로 변경하기 때문에 Boolean 타입에 사용됨.
- 논리 부정 연산자는 조건문, 제어문에서 사용되어 조건식의 값을 부정하도록 해서 실행 흐름을 제어할 때 주로 사용.
- 두 가지 상태를 번갈아가며 변경하는 토글(스위치) 기능을 구현할 때도 사용됨.



##### 비트반전연산자(~)

- 비트 반전 연산자는 정수타입의 피연산자에만 사용함.
- 피연산자를 2진수로 표현했을 때 비트값 0을 1로, 1을 0으로 반전함. 



#### 이항연산자

- 이항연산자는 피연산자가 두 개인 연산자를 말함.
  - 산술연산자(+,-,*,/,%), 문자열 연결(+), 대입연산자(=,+=,...), 비교연산자(>,<,>=,...), 논리연산자(&&,||,...), 비트 논리연산자(&,|,^)



##### 산술연산자

- 사칙연산 +, -, *, /, % 총 5개를 사용함.
- 산술연산자는 피연산자들의 타입이 동일하지 않을 경우 정해진 규칙을 사용해서 피연산자 타입을 일치시킨 후 연산을 수행함.
  - 피연산자들이 모두 정수 타입이고, int 타입(4byte)보다 크기가 작은 타입일 경우 모두 int 타입으로 변환 후 연산을 수행함
  - 피연산자들이 모두 정수 타입이고, long 타입(8byte)이 있을 경우 모두 long으로 변환 후 연산을 수행함.
  - 피연산자 중에 실수 타입이 있을 경우 크기가 큰 실수 타입으로 변환 후 연산을 수행함.



###### char 타입의 정수 계산

- char 타입도 정수 타입이므로 산술연산이 가능함.
- 주의할 점은 char 타입이 산술연산이 될 경우 int 타입으로 변환되므로 산출 타입은 int 타입이 됨.



###### 오버플로우

- 오버플로우는 사전적으로 넘쳐 흐른다는 뜻.
- 산술연산할 때 주의할 점은 연산 후의 산출값이 산출 타입으로 충분히 표현 가능한지를 살펴봐야 함.
- 산출 타입으로 표현할 수 없는 값이 산출되었을 경우, 오버플로우가 발생하고, 쓰레기 값(garbage value)을 얻을 수 있음.
- MIN_VALUE, MAX_VALUE 등을 활용하여 오버플로우 검증 코드를 만들 수 있음.

```
public static int safeAdd(int left, int right) {
		if (right > 0) {
			if(left > (Integer.MAX_VALUE - right)) {
				throw new ArithmeticException("오버플로우발생");
			}
		} else {
			if(left < (Integer.MIN_VALUE - right)) {
				throw new ArithmeticException("오버플로우발생");
			}
		}
		return left + right;
	}
```



###### 부동소수점 반올림 오차

- 수학적으로 무한히 많은 실수를 유한의 비트로 표현하기 위해 근사값을 사용하고 이 때문에 오차가 발생함.
- 실수를 근사값으로 표현하면서 발생하는 문제를 부동소수점 반올림 오차(rounding error)라고 함.
- 해결 : 정수 연산으로 변경하여 계산 실행, BigDecimal 사용 등



##### 문자열 연결 연산자 (+)

- 문자열을 서로 결합하는 연산자
- 산술연산자, 부호연산자인 동시에 문자열 연결 연산자이기도 함
- 피연산자 중 한쪽이 문자열이면 + 연산자는 문자열 연결 연산자로 사용되어 다른 피연산자를 문자열로 변환하고 서로 결합함.



##### 비교연산자

- ==, !=, >=, >, <=, <

- 동등비교
  - 피연산자1 == 피연산자2 : 두 피연산자의 값이 같은지 검사
  - 피연산자1 != 피연산자2 : 두 피연산자의 값이 다른지 검사
- 크기비교
  - 피연산자1 >= 피연산자2 : 피연산자1이 피연산자2 이상인지 검사
  - 피연산자1 > 피연산자2 : 피연산자1이 피연산자2 초과인지 검사
  - 피연산자1 <= 피연산자2 : 피연산자1이 피연산자2 이하인지 검사
  - 피연산자1 < 피연산자2 : 피연산자1이 피연산자2 미만인지 검사



###### String 참조 타입 비교

- String 타입은 문자열을 사용하는 참조 타입
- 대소연산자를 사용할 수 없고, 동등연산자는 주소를 비교하는 용도로 사용됨.
- String 값 비교는 .equals를 사용하여 비교함.



##### 대입연산자

- 대입연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자인 변수에 저장함.
- 오른쪽 피연산자는 리터럴, 변수, 다른 식이 올 수 있음.



###### 단순 대입연산자

- 변수 = 피연산자 -> 우측의 피연산자 값을 변수에 저장
- 예시) x = 10;



###### 복합 대입연산자

- 변수 += 피연산자 : 우측 피연산자의 값을 변수의 값과 더한 후 다시 변수에 저장 (변수 = 변수 + 피연산자)
- 변수 -= 피연산자 : 우측 피연산자의 값을 변수의 값과 뺀 후 다시 변수에 저장 (변수 = 변수 - 피연산자)
- 변수 *= 피연산자 : 우측 피연산자의 값을 변수의 값과 곱한 후 다시 변수에 저장 (변수 = 변수 * 피연산자)
- 변수 /= 피연산자 : 우측 피연산자의 값을 변수의 값과 나눈 후 다시 변수에 저장 (변수 = 변수 / 피연산자)
- 변수 %= 피연산자 : 우측 피연산자의 값을 변수의 값과 나눈 나머지를 다시 변수에 저장 (변수 = 변수 % 피연산자)



#### 삼항연산자

- 삼항연산자는 3개의 항을 가진 연산자로 if와 같이 조건을 비교하는 연산자로 많이 활용됨.
- (조건식) ? (참 실행문) : (거짓 실행문) ;



##### 논리연산자

- 논리연산자 자바 표시 방법
  - 논리곱(&&)
  - 논리합(||)
  - 베타적논리합(^)
  - 논리부정(!)
- 논리연산자의 피연산자는 Boolean 타입만 사용됨.
- AND, OR 연산 기호
  - &&는 앞의 피연산자가 false(0)라면 뒤의 피연산자를 평가하지 않고 false(0) 산출 결과를 냄.
  - &는 두 피연산자 모두를 평가하여 산출 결과를 냄.
  - ||는 앞의 피연산자가 true(1)라면 뒤의 피연산자를 평가하지 않고 true(1) 산출 결과를 냄.
  - |는 두 피연산자 모두를 평가하여 산출 결과를 냄.



##### 비트연산자

- 비트연산자는 데이터를 비트(bit) 단위로 연산함. (0과 1로 계산)
- 정수 타입만 가능함.



###### 비트논리연산자

- &, |, ^, ~
- 논리곱, 논리합, NOT, 배타적논리합의 진리표를 따름.



###### 비트이동연산자

- 비트 이동(shift) 연산자는 정수 데이터의 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산을 수행함.
- 2진법의 자리 이동을 이용하여 2배수를 계산함.
- 연산식
  - a << b : 정수 a의 각 비트를 b만큼 왼쪽으로 이동. 남은 부분은 0으로 채움.
  - a >> b : 정수 a의 각 비트를 b만큼 오른쪽으로 이동. 남은 부분은 정수 a의 최상위 부호비트와 같은 값을 채움.
  - a >>> b : 정수 a의 각 비트를 b만큼 오른쪽으로 이동함. 남은 부분은 0으로 채움.
