# 인터페이스



## 1. 인터페이스

- 자바에서 인터페이스(interface)는 객체의 사용 방법을 정의한 타입.
- 인터페이스를 통해 다양한 객체를 동일한 사용 방법으로 이용할 수 있음.

- 인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 함.
- 개발 코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드를 호출시킴.
- 개발 코드는 객체의 내부 구조를 알 필요가 없고 인터페이스의 메소드만 알고 있으면 됨.
- 중간에 인터페이스를 두는 이유는 개발 코드를 수정하지 않고 사용하는 객체를 변경할 수 있도록 하기 위해서임.
- 인터페이스는 여러 객체들과 사용이 가능하므로 어떤 객체를 사용하느냐에 따라서 실행 내용과 리턴값이 다를 수 있음.



### 1.1. 인터페이스 선언

- 물리적 형태는 클래스와 동일함.
- 선언 시 class 키워드 대신 interface 키워드 사용.

```java
[public] interface 인터페이스이름 {...}
```

- 인터페이스 이름은 클래스 이름 작성 방법과 동일함.
- 인터페이스는 상수 필드와 추상 메소드를 구성 멤버로 가짐.
- 자바8부터 디폴트 메소드와 정적 메소드도 구성 멤버로 가질 수 있음.
- 인터페이스는 객체로 생성할 수 없기 때문에 생성자를 가질 수 없음.



#### 상수 필드 선언

- 인터페이스는 인스턴스 또는 정적 필드를 선언할 수 없지만, 상수 필드는 선언이 가능함.
- 상수는 인터페이스에 고정된 값으로 실행 시에 데이터를 바꿀 수 없음.
- 상수는 public static final 로 선언함.
- public static final을 생략하더라도 컴파일 과정에서 자동으로 붙음.
- 상수 이름은 대문자 작성, 단어 연결은 언더바(_)로 함.
- 인터페이스 상수는 반드시 선언과 동시에 초기값을 지정해야 함.



#### 추상 메소드 선언

- 인터페이스의 메소드는 실행 블록이 필요 없는 추상 메소드로 선언함.
- 인터페이스에 선언된 추상 메소드는 public abstract를 생략하더라도 컴파일 과정에서 자동으로 붙음.



### 1.2. 인터페이스 구현

- 개발 코드가 인터페이스 메소드를 호출하면 인터페이스는 객체의 메소드를 호출함.
- 객체는 인터페이스에서 정의된 추상 메소드와 동일한 메소드 이름, 매개 타입, 리턴 타입을 가진 실체 메소드를 가지고 있어야 함.
- 이러한 객체를 인터페이스의 구현(implement) 객체라고 하고, 구현 객체를 생성하는 클래스를 구현 클래스라고 함.



#### 구현 클래스

- 구현 클래스는 보통의 클래스와 동일한데, 인터페이스 타입으로 사용할 수 있음을 알려주기 위해 클래스 선언부에 implements 키워드를 추가하고 인터페이스 이름을 명시해야 함.
- 인터페이스에 선언된 추상 메소드의 실체 메소드를 선언해야 함.

```java
pubilc class 구현클래스이름 implements 인터페이스이름 {
	// 인터페이스에 선언된 추상 메소드의 실체 메소드 선언
}
```

- 실체 메소드를 작성할 때 public보다 더 낮은 접근 제한으로 작성할 수 없음. 인터페이스의 모든 메소드는 기본적으로 public 접근 제한을 갖기 때문임.
- public을 생략하면 "Cannot reduce the visibility of the inherited method" 컴파일 에러 발생.
- 인터페이스로 구현 객체를 사용하려면 인터페이스 변수를 선언하고 구현 객체를 대입해야 함.
- 인터페이스 변수는 참조 타입이기 때문에 구현 객체가 대입될 경우 구현 객체의 번지를 저장함.

```java
인터페이스 변수; // 방법1
변수 = 구현객체;

인터페이스 변수 = 구현객체; // 방법2

RemoteControl rc = new Television(); // 예시
```



#### 다중 인터페이스 구현 클래스

- 다중 인터페이스를 구현할 경우, 구현 클래스는 모든 인터페이스의 추상 메소드에 대해 실체 메소드를 작성해야 함.

```java
public class 구현클래스이름 implements 인터페이스A, 인터페이스B {
	// 인터페이스 A에 선언된 추상 메소드의 실체 메소드 선언
	// 인터페이스 B에 선언된 추상 메소드의 실체 메소드 선언
}
```



### 1.3. 인터페이스 사용

- 클래스를 선언할 때 인터페이스는 필드, 생성자 또는 메소드의 매개 변수, 생성자 또는 메소드의 로컬 변수로 선언될 수 있음.
  - 인터페이스가 필드 타입으로 사용될 경우, 필드에 구현 객체를 대입할 수 있음.
  - 인터페이스가 생성자의 매개 변수 타입으로 사용될 경우, new 연산자로 객체를 생성할 때 구현 객체를 생성자의 매개값으로 대입할 수 있음.
  - 인터페이스가 로컬 변수 타입으로 사용될 경우, 변수에 구현 객체를 대입할 수 있음.
  - 인터페이스가 메소드의 매개 변수 타입으로 사용될 경우, 메소드 호출 시 구현 객체를 매개값으로 대입할 수 있음.
- 구현 객체가 인터페이스 타입에 대입되면 인터페이스에 선언된 추상 메소드를 개발 코드에서 사용할 수 있게 됨.
- 인터페이스(Remote Control)는 개발 코드(MyClass)와 구현 객체(Television, Audio) 사이에서 접점 역할을 함. 개발 코드는 인터페이스에 선언된 추상 메소드(turnOn())를 호출하고 인터페이스는 구현 객체의 재정의 메소드(turnOn())를 호출함.

```java
//예시

//인터페이스 선언
public class MyClass {
	// 필드
	RemoteControl rc = new Television(); // 필드로 선언
	
	// 생성자
	MyClass(){
	}
	
	MyClass(RemoteControl rc){ // 생성자 매개변수로 선언
		this.rc = rc;
		rc.turnOn();
		rc.setVolume(2);
	}
	
	// 메소드
	void methodA() {
		RemoteControl rc = new Audio(); // 메소드 로컬변수로 선언
		rc.turnOn();
		rc.setVolume(3);
	}
	
	void methodB(RemoteControl rc) { // 메소드 매개변수로 선언
		rc.turnOn();
		rc.setVolume(4);
	}
}
// 인터페이스 사용
public class MyClassExample {

	public static void main(String[] args) {

		// 필드로 선언된 인터페이스 사용.
		MyClass mc1 = new MyClass();
		mc1.rc.turnOn();
		mc1.rc.setVolume(1);

		// 생성자 매개변수로 선언된 인터페이스 사용
		MyClass mc2 = new MyClass(new Audio());

		// 메소드의 로컬 변수로 선언된 인터페이스 사용
		MyClass mc3 = new MyClass();
		mc3.methodA();

		// 메소드의 매개변수로 선언된 인터페이스 사용
		MyClass mc4 = new MyClass();
		mc4.methodB(new Television());
	}
}
```



## 2. 타입 변환과 다형성

- 인터페이스의 다형성
  - 프로그램을 개발할 때 인터페이스를 사용해서 메소드를 호출하도록 코딩했다면, 구현 객체를 매우 손쉽고 빠르게 교체할 수 있음.
  - 프로그램 소스 코드는 변함이 없는데, 구현 객체를 교체함으로써 프로그램의 실행결과가 다양해짐.
  - 개발코드에서는 인터페이스의 메소드를 호출함 -> 구현 객체의 재정의된 메소드가 실행됨. -> 개발코드는 그대로 두고 구현객체만 변경하면서 실행 결과를 다르게 할 수 있음.

```java
// A 클래스에 문제가 발생하여 B 클래스와 교체할 때

//I i = new A();
I i = new B();
// i에 대입되는 객체만 A에서 B로 바꾸면 됨.


i.method1();
i.method2();
// 메소드 호출 코드는 수정할 필요가 없음.
```



### 2.1. 자동 타입 변환

- 자동 타입 변환(promotion) : 구현 객체가 인터페이스 타입으로 변환되는 것.
- 인터페이스 구현 클래스를 상속해서 자식 클래스를 만들었다면 자식 객체 역시 인터페이스 타입으로 자동 타입 변환할 수 있음.
- 자동 타입 변환을 이용하면 필드의 다형성과 매개 변수의 다형성을 구현할 수 있음.



### 2.2. 필드의 다형성

- 자동차 설계 예시

- 1. 자동차 클래스의 필드 타입으로 타이어 인터페이스를 선언하면 필드값으로 구현 객체인 한국 타이어 또는 금호 타이어 객체를 대입할 수 있음. 자동 타입 변환이 일어나서 문제가 없음.

- ```java
  public class Car {
  	Tire frontLeftTire = new HankookTire();
      Tire frontRightTire = new HankookTire();
      Tire backLeftTire = new HankookTire();
      Tire backRightTire = new HankookTire();
  }
  ```

- 2. Car 객체를 생성한 후, 초기값으로 대입한 구현 객체 대신 다른 구현 객체를 대입할 수 있음. 이것은 타이어 교체에 해당함.

- ```java
  Car myCar = new Car();
  myCar.frontLeftTire = new KumhoTire();
  myCar.frontRightTire = new KumhoTire();
  ```

- 3. Car 객체의 run() 메소드에서 타이어 인터페이스 타입으로 선언된 필드의 roll() 메소드를 호출함.

- ```java
  void run(){
  	frontLeftTire.roll();
      frontRightTire.roll();
      backLeftTire.roll();
      backRightTire.roll();
  }
  ```

- 4. 타이어 교체 전에는 HankookTire 객체의 재정의된 roll() 메소드가 호출되지만, KumhoTire로 교체된 후에는 KumhoTire 객체의 재정의된 roll() 메소드가 호출됨. Car의 run() 메소드를 수정하지 않아도 객체 교체에 따라 다양하게 재정의된 roll() 메소드의 실행결과를 얻을 수 있게 됨.



### 2.3. 매개 변수의 다형성

- 매개 변수를 인터페이스 타입으로 선언하고 호출할 때에는 구현 객체를 대입.
- 구현 객체가 대입될 때 자동 타입 변환이 발생함.
- 매개 변수의 타입이 인터페이스일 경우 어떠한 구현 객체도 매개값으로 사용할 수 있고, 어떤 구현 객체가 제공되느냐에 따라 메소드의 실행 결과는 다양해짐. 이것이 인터페이스 매개 변수의 다형성임.



### 2.4. 강제 타입 변환

- 구현 객체가 인터페이스 타입으로 자동 타입 변환되면 인터페이스에 선언된 메소드만 사용 가능함.
- 예를 들어 인터페이스에 3개의 메소드가 선언되어 있고 구현 클래스에 재정의된 메소드 3개 포함 총 5개의 메소드가 선언되어 있다면, 자동 타입 변환된 인터페이스로 호출 가능한 메소드는 재정의된 메소드 3개뿐임.
- 강제 타입 변환(casting) : 자동 타입 변환된 인터페이스 타입을 다시 구현 클래스 타입으로 변환하는 것. 구현 클래스의 필드와 메소드를 사용할 수 있게 됨.

```java
구현클래스 변수 = (구현클래스) 인터페이스변수;
```



### 2.5. 객체 타입 확인

- 강제 타입 변환은 구현 객체가 인터페이스 타입으로 자동 타입 변환되어 있는 상태에서 가능함.
- 어떤 구현 객체가 자동 타입 변환되어 있는지 알 수 없는 상태에서 무작정 강제 타입 변환할 경우 ClassCastException 발생할 수 있음.

- 메소드의 매개 변수가 인터페이스로 선언된 경우 메소드 호출 시 다양한 구현 객체들을 매개값으로 지정할 수 있는데, 어떤 구현 객체가 지정될지 모르는 상황에서 무작정 강제 타입 변환을 시도하면 안됨.
- instanceof 연산자로 확인할 수 있음.

```java
public class Driver {
	public void drive(Vehicle vehicle) {
		if(vehicle instanceof Bus) {
			Bus bus = (Bus) vehicle;
			bus.checkFare();
		}
		vehicle.run();
	}
}
```



### 2.6. 인터페이스 상속

- 인터페이스도 다른 인터페이스를 상속할 수 있음.
- 인터페이스는 클래스와 달리 다중 상속을 허용함.

```java
public interface 하위인터페이스 extends 상위인터페이스1, 상위인터페이스2 {...}
```

- 하위 인터페이스를 구현하는 클래스는 상위 인터페이스의 모든 추상 메소드에 대한 실체 메소드를 가지고 있어야 함.
- 구현 클래스로부터 객체를 생성한 후에 하위 및 상위 인터페이스 타입으로 변환이 가능함.
- 하위 인터페이스로 타입 변환되면 상위 및 하위 인터페이스에 선언된 모든 메소드 사용 가능.
- 상위 인터페이스로 타입 변환되면 상위 인터페이스에 선언된 메소드만 사용 가능함.

