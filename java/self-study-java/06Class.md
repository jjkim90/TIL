# 클래스





> 이 문서는 [<혼자 공부하는 자바 - 신용권>](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791162241875&orderClick=LAG&Kc=) 책을 보고 정리한 문서입니다.





## 1. 객체 지향 프로그래밍

- 객체(object) : 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있으면서 식별 가능한 것.
- 객체는 속성과 동작으로 구성됨. 자바는 속성은 필드(field), 동작은 메소드(method)라고 부름.
- 객체 모델링(object modeling) : 현실 세계의 객체를 소프트웨어 객체로 설계하는 것. 현실 세계 객체의 속성과 동작을 추려내어 소프트웨어 객체의 필드와 메소드로 정의하는 과정.
- 객체 지향 프로그래밍(OOP: Object-Oriented Programming) : 부품에 해당하는 객체를 먼저 만든 뒤 객체를 하나씩 조립해서 완성된 프로그램을 만드는 기법.



### 1.1. 객체의 상호작용

- 객체들은 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용하면서 동작함.

- 객체들 사이의 상호작용 수단은 메소드.

- 메소드 호출 : 객체가 다른 객체의 기능을 이용하는 것.

- 메소드 호출 방법은 객체에 도트(.) 연산자를 붙이고 메소드 이름을 기술하면 됨.

- 도트 연산자는 객체의 필드와 메소드에 접근할 때 사용함.

- 매개값 : 메소드를 실행하기 위해 필요한 데이터.

- 리턴값 : 메소드가 실행되고 난 후 호출한 곳으로 돌려주는(리턴하는) 값.

  ```java
  int result = Calculator.add(10, 20);
  ```

  - 계산기 객체의 add 메소드를 10, 20 값을 매개로 호출하여 리턴한 값을 int 변수에 저장하는 코드

- 객체의 상호작용은 객체 간의 메소드 호출을 의미하며 매개값과 리턴값을 통해서 데이터를 주고 받음.



### 1.2. 객체 간의 관계

### 집합 관계

- 객체 하나는 부품이고, 다른 하나는 완성품에 해당함.
- 자동차는 엔진, 타이어, 핸들 등으로 구성되므로 자동차와 이 부품들은 집합 관계라고 볼 수 있음.



### 사용 관계

- 객체 간의 상호작용을 말함.
- 객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어냄.
- 사람은 자동차를 사용하므로 사람과 자동차는 사용 관계라고 볼 수 있음.
- 사람은 자동차를 사용할 때 달린다, 멈춘다 등의 메소드를 호출하는 것임.



### 상속 관계

- 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계를 말함.
- 일반적으로 상위 객체는 종류를 의미하고, 하위 객체는 구체적인 사물에 해당함.
- "자동차는 기계의 한 종류이다."에서 기계(상위)와 자동차(하위)는 상속 관계에 있다고 볼 수 있음.



### 1.3. 객체와 클래스

- 클래스(class) : 객체의 설계도. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있음.
- 인스턴스(instance) : 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 함.
  - 자동차 객체는 자동차 클래스의 인스턴스임.
- 인스턴스화 : 클래스로부터 객체를 만들어내는 과정.
- 하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있음.
- 객체 지향 프로그래밍 개발의 세 단계
  - 1단계 : 클래스 설계
  - 2단계 : 설계된 클래스를 가지고 사용할 객체를 생성
  - 3단계 : 생성된 객체를 이용
- main() 메소드가 없는 클래스는 객체 생성 과정을 거쳐 사용해야 함.



### 1.4. 클래스 선언

- 클래스 이름은 자바의 식별자 작성 규칙에 따름.

- '클래스 이름.java'로 소스 파일 생성.

- 클래스 이름과 소스 파일 이름 대소문자가 같도록 해야 함.

- 일반적으로 소스 파일 하나당 하나의 클래스를 선언함. 2개 이상의 클래스 선언도 가능함.

- 클래스가 선언된 소스 파일을 컴파일하면 클래스를 선언한 개수만큼 바이트 코드 파일(.class)가 생성됨.

- ```java
  public class Car {
  
  }
  
  class Tire {
  
  }
  ```

  - 위의 코드를 컴파일하면 Car.class와 Tire.class 가 각각 생성됨.

- public 접근 제한자 : 파일 이름과 동일한 이름의 클래스 선언에만 붙일 수 있음. 파일 이름과 일치하지 않는 클래스 선언에 public 접근 제한자를 붙이면 컴파일 에러 발생. 위의 코드에서도 소스 파일 이름이 'Car.java'이기 때문에 Tire 클래스에는 public 접근 제한자를 붙이지 않았음.



### 1.5. 객체 생성과 클래스 변수

- new : 클래스로부터 객체를 생성시키는 연산자.
- new 연산자 뒤에는 생성자가 옴. 생성자는 클래스() 형태를 가지고 있음.
- new 연산자로 생성된 객체는 메모리의 힙(heap) 영역에 생성됨.
- new 연산자는 힙 영역에 객체를 생성시킨 후 객체의 번지를 리턴함.
- 이 주소를 참조 타입인 클래스 변수에 저장해두면 변수를 통해 객체를 사용할 수 있음.

```java
Student s1 = new Student();

Student s2;
s2 = new Student();
// 실행문 1개, 2개 둘 다 가능함.
```

- 클래스가 1개뿐이어도 new 연산자를 사용한 만큼 객체를 메모리에 생성할 수 있음. 이러한 객체들은 Student 클래스의 인스턴스임.
- 비록 같은 클래스로부터 생성되었지만 각각의 Student 객체는 자신만의 고유 데이터를 가지면서 메모리에서 활동함. s1과 s2가 참조하는 Student 객체는 완전히 독립된 서로 다른 객체임.



#### Student와 StudentExample 클래스의 용도

- 클래스의 용도는 두 가지로, 하나는 라이브러리(API: Application Program Interface)용이고 다른 하나는 실행용임.
- 라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계됨. 프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리 클래스임.
- 실행 클래스는 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할을 함.
- 대부분의 객체 지향 프로그램은 라이브러리(부품 객체 및 완성 객체)와 실행 클래스가 분리되어 있음.



### 1.6. 클래스의 구성 멤버

- 클래스에는 객체가 가져야 할 구성 멤버가 선언됨.
- 구성 멤버에는 필드(Field), 생성자(Constructor), 메소드(Method)가 있음.
- 구성 멤버들은 생략되거나 복수의 개수로 작성될 수 있음.



#### 필드

- 필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳.
- 선언 형태는 변수와 비슷하지만, 필드를 변수라고 부르지는 않음.
- 변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸되지만, 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재함.



#### 생성자

- 생성자는 new 연산자로 호출되는 특별한 중괄호 {} 블록임.
- 생성자의 역할은 객체 생성 시 초기화를 담당함.
- 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 함.
- 생성자는 메소드와 비슷하게 생겼지만, 클래스 이름으로 되어 있고 리턴 타입이 없음.



#### 메소드

- 메소드는 객체의 동작에 해당하는 중괄호 {} 블록을 말함.
- 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행됨.
- 메소드는 객체 간의 데이터를 전달하는 수단.



## 2. 필드

- 필드 : 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳
- 자동차 객체
  - 제작회사, 모델, 색깔, 최고 속도는 고유 데이터에 해당함.
  - 현재 속도, 엔진 회전 수는 상태 데이터에 해당함.
  - 차체, 엔진, 타이어는 부품에 해당함.



### 2.1. 필드 선언

- 필드 선언은 클래스 중괄호 {} 블록 어디서든 존재할 수 있지만, 생성자와 메소드 중괄호 {} 블록 내부에는 선언될 수 없음.
- 필드의 선언 형태는 변수와 비슷하지만, 필드를 변수라고 부르지는 않음. 구분해야 함.
- 초기값이 지정되지 않은 필드는 객체 생성 시 자동으로 기본 초기값으로 설정됨.



### 2.2. 필드 사용

- 필드를 사용한다는 것은 필드값을 읽고 변경하는 작업을 말함.
- 클래스 외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야 함.
- 필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않음.

```java
//Car 클래스
int speed; // 필드
Car(){ // 생성자
	speed = 0; // 생성자에서 필드값 변경 가능함.
}
void method(...){
	speed = 10; // 메소드에서 필드값 변경 가능함.
}
// 필드는 생성자와 모든 메소드에서 사용이 가능함.
```

```java
//Person 클래스
void method(){
	//1) Car 객체 생성
	Car myCar = new Car();
	
	//2) 필드 사용
	myCar.speed = 60;
}
//외부 Person 클래스에서 Car 클래스의 speed 필드값을 사용하려면 Car 객체를 우선 생성해야 함.
```

- 도트(.) 연산자는 객체 접근 연산자로 객체가 가지고 있는 필드나 메소드를 사용하고자 할 때 사용됨.



## 3. 생성자

- 생성자는 new 연산자로 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당함.
- 생성자는 객체 생성 시 초기화를 담당하며, 모든 클래스에 반드시 하나 이상 존재함.
- 클래스 내부에 선언을 생력하면 기본 생성자가 자동으로 추가됨.
- 객체 초기화 : 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 하는 것을 말함.
- new 연산자에 의해 생성자가 성공적으로 실행되면 힙 영역에 객체가 생성되고 객체의 번지가 리턴됨.
- 리턴된 객체의 번지는 클래스 변수에 저장됨.



### 3.1. 기본 생성자

- 클래스 내부에 생성자 선언을 생략했다면 컴파일러는 중괄호 {} 블록 내용이 비어 있는 기본 생성자(Default Constructor)를 바이트 코드에 자동으로 추가함.

```java
[public] 클래스() { }
//생성자 선언 생략시 컴파일러에 의해 자동으로 기본 생성자 추가됨.
```

- 클래스가 public class로 선언되면 기본 생성자에서도 public이 붙지만, 클래스가 public 없이 class로만 선언되면 기본 생성자에서도 public이 붙지 않음.
- 클래스에 생성자를 선언하지 않아도 new 연산자 뒤에 기본 생성자를 호출해서 객체를 생성할 수 있음.

```java
Car myCar = new Car();
// Car() << 기본 생성자
```

- 클래스에 명시적으로 생성자를 선언하는 이유는 객체를 다양한 값으로 초기화하기 위해서임.



### 3.2. 생성자 선언

```java
클래스 ( 매개변수선언, ... ) {
	// 객체의 초기화 코드
}
```

- 생성자는 리턴 타입이 없고, 생성자의 이름은 클래스 이름과 동일함.
- 생성자 블록 내부에는 객체 초기화 코드가 작성됨.
- 매개 변수 선언은 생략할 수도 있고 여러 개를 선언할 수도 있음.
- 매개 변수는 new 연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할을 함.

```java
Car myCar = new Car("그랜져", "검정", 300);
// 대입연산자 오른쪽의 new Car(...)에서 Car 부분이 생성자임.
```

```java
public class Car {
	//생성자
	Car(String model, String color, int maxSpeed) { ... }
}
```

- Car 생성자를 호출할 때 3개의 매개값이 제공되었으므로 세 매개값을 생성자가 받기 위해서는 생성자도 매개 변수를 선언해야 함.
- 클래스에 생성자가 명시적으로 선언되어 있을 경우, 반드시 선언된 생성자를 호출해서 객체를 생성해야 하고 이 과정에서 매개값도 제공되어야 함. 클래스에 생성자 선언이 있다면 기본 생성자(Car())를 호출해서 객체를 생성할 수 없음. 매개변수가 있는 생성자를 호출해야 함.

```java
//클래스 생성
public class Car {
	//생성자
	Car(String color, int cc) {
	}
}
```

```java
//생성자 호출
public class CarExample {
	public static void main(String[] args) {
	Car myCar = new Car("검정", 3000);
	//Car myCar = new Car(); // (x) 기본 생성자 호출 불가능함.
    }
}
```



### 3.3. 필드 초기화

- 클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정됨.
- 기본 초기값 외에 다른 값으로 초기화하는 방법
  - 1) 필드를 선언할 때 초기값을 줄 수 있음. -> 객체 생성 시점에 값이 고정적인 경우
  - 2. 생성자에서 매개값으로 외부 값을 받아 필드에 초기값을 줄 수 있음. -> 객체 생성 시점에 다양한 값을 가져야 하는 경우



#### 필드 선언할 때 초기화

- 필드를 선언할 때 초기값을 주게 되면 동일한 클래스로부터 생성되는 객체들은 모두 같은 값을 갖게 됨.

- ```java
  public class Korean {
  String nation = "대한민국";
  }
  ```

- ```java
  Korean k1 = new Korean();
  Korean k2 = new Korean();
  // k1과 k2 객체의 nation 필드에는 모두 "대한민국"이 저장되어 있음.
  ```



#### 생성자 매개 변수로 필드 초기화

- 객체 생성 시점에 다양한 필드 값을 가져야 할 경우 생성자의 매개 변수로 이 값들을 받아 필드를 초기화할 수 있음.

- ```java
  public class Korean {
  	//필드
  	String nation = "대한민국";
  	String name;
  	String ssn;
  
  	//생성자
  	public Korean(String n, String s){ // 필드값 초기화 위해 매개변수선언
  		name = n; // 필드값 초기화
  		ssn = s; // 필드값 초기화
  	}
  }
  ```

- ```
  Korean k1 = new Korean("김자바", "011225-1234567");
  Korean k2 = new Korean("이자바", "000505-2134567");
  ```



#### this. 참조 변수

- Korean 생성자의 매개 변수 이름은 각각 n과 s를 사용함.
- 매개 변수의 이름이 너무 짧으면 코드의 가독성이 좋지 않기 때문에 가능하면 초기화시킬 필드 이름과 동일한 이름을 사용하는 것이 좋음.
- 필드와 생성자 매개 변수 이름 동일하면 생성자 매개 변수가 사용 우선순위가 높기 때문에 생성자 내부에서 해당 필드에 접근할 수 없음.
- 이를 해결하기 위해 필드 앞에 'this.'을 붙임.
- this는 객체 자신의 참조임.

- ```java
  //생성자
  public class Korean (String name, String ssn){
  	this.name = name; // 필드 이름과 매개 변수 이름이 동일할 때 필드 앞에 this. 사용
  	this.ssn = ssn;
  }
  ```



- 일반적으로 중요한 몇 개의 필드만 생성자 매개 변수으로 초기화함.
- 나머지 필드들은 필드 선언 시에 초기화하거나 생성자 내부에서 임의의 값 또는 계산된 값으로 초기화함.
- 객체 생성 후에 필드값을 별도로 저장하기도 함.



### 3.4. 생성자 오버로딩

- 생성자 오버로딩(overloading) : 매개 변수를 달리하는 생성자를 여러 개 선언하는 것.
- 오버로딩의 목적 : 외부에서 제공되는 다양한 데이터들을 이용해서 객체를 초기화하려면 생성자도 다양화될 필요가 있음
  - 외부 제공 데이터가 없을 때, model 데이터만 제공될 때, model과 color 데이터 2개 제공될 때 등 어떤 경우에도 Car 객체를 생성할 수 있어야 함.
  - 만약 생성자가 1개라면 이러한 다양한 요구 조건을 수용할 수 없음.
- 생성자 오버로딩 하는 방법 : 매개 변수의 타입, 개수, 순서를 다르게 해서 선언하면 됨.

```java
public class Car {
	Car() {...}
	Car(String model) {...}
	Car(String model, String color) {...}
	Car(String model, String color, int maxSpeed) {...}
}
```

- 매개 변수의 타입과 개수 그리고 선언된 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이 아니라는 점을 주의해야 함.

```java
Car(String model, String color) {...}
Car(String color, String model) {...} // 생성자 오버로딩이 아님
```

- 생성자가 오버로딩되어 있을 경우(다양한 경우에 대비해 생성자들이 많이 선언되어 있는 경우) new 연산자로 생성자를 호출할 때 제공되는 매개값의 타입과 수가 일치하는 생성자가 호출됨.



### 3.5. 다른 생성자 호출: this()

- this()는 객체 자신의 또 다른 생성자를 호출할 때 사용하는 코드
- this() 사용하는 이유 : 생성자 오버로딩이 많아질 때 생성자 간의 중복된 코드를 제거하여 코딩을 쉽게하기 위해서.
- this()는 반드시 생성자의 첫 줄에서만 사용해야 함.

```java
//중복이 많은 생성자 오버로딩
public class Car {
	//필드
	String company = "현대자동차";
	String model;
	String color;
	int maxSpeed;
	
	//생성자
	Car(){
	}
	
	Car(String model){			//중복코드
		this.model = model;
		this.color = "은색";
		this.maxSpeed = 250;
	}
	
	Car(String model, String color){			//중복코드
		this.model = model;
		this.color = color;
		this.maxSpeed = 250;
	}
	
	Car(String model, String color, int maxSpeed){			//중복코드
		this.model = model;
		this.color = color;
		this.maxSpeed = maxSpeed;
	}
}
```

```java
// this() 사용으로 다른 생성자 호출해서 중복 코드 줄이기
public class Car {
	//필드
	String company = "현대자동차";
	String model;
	String color;
	int maxSpeed;
	
	//생성자
	Car(){
	}
	
	Car(String model){						//호출
		this(model, "은색", 250);
	}
	
	Car(String model, String color){		//호출
		this(model, color, 250);
	}
	
	Car(String model, String color, int maxSpeed){	// 공통 실행 코드
		this.model = model;
		this.color = color;
		this.maxSpeed = maxSpeed;
	}
}

```

- this() 매개변수 개수를 조작하여 서로 다른 this를 참조하게 할 수 있음.
- 호출의 호출도 가능함. 순서대로 참조하게 했을 경우 역순으로 실행됨.

```java
public class Parent {
	public String nation;
	public String ssn;
	public String color;
	
	public Parent() {
		this("대한민국", "123123", "녹색"); // 매개변수 3개인 this 호출
		System.out.println("4등");
	}
	
	public Parent(String nation) {
		this(nation,"12");
		System.out.println("3등");
	}
	
	public Parent(String nation, String ssn) {
		this(nation, ssn, "파랑");
		System.out.println("2등");
	}
	
	public Parent(String nation, String ssn, String color) {
		this.nation = nation;
		this.ssn = ssn;
		this.color = color;
		System.out.println("1등");
	}
}

// 실행결과 1등 4등
```

```java
public class Parent {
	public String nation;
	public String ssn;
	public String color;
	
	public Parent() {
		this("대한민국"); // 매개변수 1개인 this 호출
		System.out.println("4등");
	}
	
	public Parent(String nation) {
		this(nation,"12"); // 매개변수 2개인 this 호출
		System.out.println("3등");
	}
	
	public Parent(String nation, String ssn) {
		this(nation, ssn, "파랑"); // 매개변수 3개인 this 호출
		System.out.println("2등");
	}
	
	public Parent(String nation, String ssn, String color) {
		this.nation = nation;
		this.ssn = ssn;
		this.color = color;
		System.out.println("1등");
	}
}

// 실행결과 1등 2등 3등 4등
```





## 4. 메소드

- 메소드 : 객체의 동작에 해당하는 중괄호{} 블록.
- 메소드 선언은 선언부와 실행 블록으로 구성됨.
- 메소드 선언부를 메소드 시그니처(signature)라고 함.
- 선언부와 실행 블록에서는 다음 요소를 포함함.
  - 리턴 타입 : 메소드가 리턴하는 결과의 타입을 표시.
  - 메소드 이름 : 메소드의 기능이 드러나도록 식별자 규칙에 맞게 이름을 지어야 함.
  - 매개 변수 선언 : 메소드를 실행할 때 필요한 데이터를 받기 위한 변수를 선언.
  - 메소드 실행 블록 : 실행할 코드를 작성.

```java
리턴타입 메소드이름 ( [매개변수선언, ... ] ) {
	...
	실행할 코드를 작성하는 곳
	...
}
```



### 4.1. 메소드 선언



#### 리턴 타입

- 리턴 타입은 리턴값의 타입을 말함.

- 리턴값이란 메소드를 실행한 후의 결과값을 말함.

- 메소드는 리턴값이 있을 수도 있고 없을 수도 있음.

- 리턴값이 없는 메소드는 리턴 타입에 void로 기술하며, 리턴값이 있는 메소드는 리턴값의 타입을 기술함.

- 리턴값 유무에 따른 메소드 호출 방법

  - 리턴값이 없는 경우 : 단순히 메소드만 호출하면 됨.

  - 리턴값이 있는 경우 : 리턴값을 받기 위한 변수를 메소드의 리턴 타입으로 선언되어야 함.

  - 리턴값을 받기 위한 변수를 더 작은 타입으로 선언하게 되면 컴파일 에러 발생함.

  - 리턴값이 중요하지 않고, 메소드 실행이 중요할 경우 리턴값이 있는 메소드를 변수를 선언하지 않고 호출할 수도 있음.

  - ```java
    powerOn(); // 리턴값이 없는 경우
    double result = divide( 10, 20 ); // 리턴값이 있는 경우. 나누기 결과 타입이 double이므로 double 타입 변수 선언.
    
    int result = divide ( 10, 20 ); // 컴파일 에러 발생
    
    divide ( 10, 20 ); // 리턴 값이 있어도 변수를 선언하지 않고 메소드를 호출할 수도 있음.
    ```



#### 메소드 이름

- 메소드 이름은 자바 식별자 규칙에 맞게 작성하면 됨.



#### 매개 변수 선언

- 매개 변수는 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용됨.

- 메소드 호출 시 제공되는 매개값은 메소드 선언부의 매개 변수에 차례대로 대입되어, 메소드 블록 실행 시 이용됨.

- 호출 시 넘겨준 매개값은 반드시 매개 변수의 타입에 부합되는 값이어야 함.

- ```java
  double divide ( int x, int y ) {...} // int타입으로 매개 변수 선언
  double result = divide( 10, 20 ); // 호출시 넘겨준 매개값도 int 타입에 부합되는 정수.
  
  double result = divide ( 10.5, 20.0 ); // 컴파일 에러 발생.
  ```

- 호출 시 넘겨준 매개값이 매개 변수의 타입보다 작은 값이면 자동 타입 변환이 일어나 에러가 발생하지 않음.



#### 매개 변수의 개수를 모를 경우

- 매개 변수의 개수를 모를 경우 매개 변수를 배열 타입으로 선언해야 함.
- 메소드를 호출할 때 매개값으로 배열을 넘겨주면 됨. 배열의 항목 수는 호출할 때 결정됨.

```java
int sum1(int[] values){...} // 매개 변수로 배열 타입 선언

int[] numbers = {1, 2, 3};
int result = sum1(numbers); // 1) 미리 초기화된 배열을 매개값으로 넘겨줌.
int result = sum1(new int[] {1, 2, 3, 4, 5}); // 2) 새 배열을 생성하여 매개값으로 넘겨줌.
```

- 배열을 생성하지 않고 값의 목록만 넘겨주는 방법

```java
int sum2(int ... values){...} // ...을 사용해서 매개 변수 선언.

int result = sum2(1, 2, 3); // 3) 매개 변수의 값은 메소드 호출 시 쉼표로 나열해주면 됨.

int[] numbers = {1, 2, 3};
int result = sum1(numbers);
int result = sum1(new int[] {1, 2, 3, 4, 5}); // ... 사용해서 매개 변수 선언하면 1), 2), 3) 방법 모두 사용 가능
```

- ... 방법이 나중에 나온 상위호환 방법임. 기존의 배열 방법에 값의 목록만 넘겨주는 방법이 추가됨.



### 4.2. 리턴(return)문



#### 리턴값이 있는 메소드

- 메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴(return)문을 사용해서 리턴값을 지정해야 함.
- return문이 실행되면 메소드는 즉시 종료됨. return문 이후의 실행문은 결코 실행되지 않음.
- return 이후에 실행문이 오면 Unreachable code 컴파일 에러 발생.
- return문의 리턴값 타입이 메소드 선언부의 리턴 타입보다 작을 경우 자동 타입 변환되어 상관없음.



#### 리턴값이 없는 메소드

- 리턴값이 없는 메소드는 리턴 타입으로 void를 사용함.
- void로 선언된 메소드에서도 return문을 사용할 수 있음. 이 경우 리턴값 없이 `return;`만 사용하여 메소드 실행을 강제 종료시키는 역할을 함.



### 4.3. 메소드 호출



#### 객체 내부에서 호출

- 클래스 내부의 다른 메소드에서 호출할 경우 단순한 메소드 이름으로 호출 가능.

```java
메소드( 매개값, ... ); // 리턴값이 없거나, 있어도 받고 싶지 않을 경우
타입 변수 = 메소드( 매개값, ... ); // 리턴값을 받고 싶은 경우
```

- 이때 변수 타입은 메소드 리턴 타입과 동일하거나, 자동 타입 변환이 될 수 있어야 함.

```java
//클래스 내부에서 메소드 호출
public class Calculator {
	int plus(int x, int y){
	int result = x + y;
	return result;
	}
	
	double avg(int x, int y){
	double sum = plus(x, y);
	avg = sum / 2;
	return avg;
	}
	
	void execute(){
	double result = avg(7, 10);
	println("실행결과 : " + result);
	}
	
	void println(String message){
	System.out.println(message);
	}
}
```

- execute 메소드 호출될 때 일어나는 일

- 1. execute() 메소드 실행

  2. avg() 메소드 실행

  3. plus() 메소드 실행

  4. plus 리턴값

  5. avg 리턴값

  6. println() 메소드 실행

  7. 종료.



#### 객체 외부에서 호출

- 클래스 외부에서 호출할 경우 우선 클래스로부터 객체를 생성한 뒤 참조 변수를 이용해서 메소드를 호출해야 함.
- 메소드는 객체에 소속된 멤버이므로 객체가 존재하지 않으면 메소드도 존재하지 않음.
- 객체가 생성되었다면 참조 변수와 함께 도트(.) 연산자를 사용해서 메소드를 호출할 수 있음.
- 도트(.) 연산자는 객체 접근 연산자로 객체가 가지고 있는 필드나 메소드에 접근할 때 사용됨.



### 4.4. 메소드 오버로딩

- 메소드 오버로딩 : 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것.
- 메소드 오버로딩이 필요한 이유 : 매개값을 다양하게 받아 처리할 수 있도록 하기 위해서.
- 메소드 오버로딩의 조건 : 매개 변수의 타입, 개수, 순서 중 하나가 달라야 함.
- 매개 변수의 타입이 일치하는 메소드가 없을 경우 JVM은 자동 타입 변환이 가능한지 검사함.
- 주의할 점
  - 매개 변수의 타입과 개수, 순서가 똑같을 경우 매개 변수 이름이 다르더라도 메소드 오버로딩이 아님.
  - 리턴 타입만 다르고 매개 변수가 동일하다면 오버로딩이 아님.



## 5. 인스턴스 멤버와 정적 멤버



### 5.1. 인스턴스 멤버와 this

- 인스턴스(instance) 멤버 : 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드
- 위의 필드와 메소드를 각각 인스턴스 필드, 인스턴스 메소드라고 함.
- 인스턴스 필드와 메소드는 객체에 소속된 멤버이기 때문에 객체 없이는 사용할 수 없음.



#### 인스턴스 멤버 선언

```java
public class Car {
	//필드
	int gas;
	
	//메소드
	void setSpeed(int speed){ ... }
}
```

- 인스턴스 필드 gas는 객체마다 따로 존재하고, 인스턴스 메소드 setSpeed()는 메소드 영역에 저장되고 공유됨.
- 메소드는 코드 블록이므로 객체마다 동일한 코드 블록을 가지고 있을 필요가 없어서 메소드 영역에 저장되고 공유됨.
- 메소드에도 인스턴스 용어가 붙은 이유 : 메모리 블록 내부에 인스턴스 필드 등이 사용되는 경우가 있음. 해당 인스턴스 필드가 사용되면 메소드 역시 객체 없이는 실행할 수 없음.



#### this

- 객체 내부에서 인스턴스 멤버에 접근하기 위해 this를 사용함.
- this는 주로 생성자와  메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용됨.



### 5.2. 정적 멤버와 static

- 정적(static)은 '고정된'이란 의미.
- 정적 멤버는 클래스에 고정된 멤버로서, 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말함.
- 위의 필드와 메소드를 각각 정적 필드, 정적 메소드라고 함.



#### 정적 멤버 선언

```java
public class 클래스 {
	// 정적 필드
	static 타입 필드 [= 초기값];
	
	// 정적 메소드
	static 리턴타입 메소드( 매개변수선언, ... ) { ... }
}
```

- 정적 필드와 정적 메소드는 클래스에 고정된 멤버이므로 클래스 로더가 클래스(바이트 코드)를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리됨.
- 클래스 로딩이 끝나면 바로 사용할 수 있음. 이클립스는 저장만 하면 됨.

- 객체마다 가지고 있어야 할 데이터라면 인스턴스 필드로 선언하고, 객체마다 가지고 있을 필요가 없는 공용 데이터라면 정적 필드로 선언함.
- 메소드는 인스턴스 필드를 포함하고 있다면 인스턴스 메소드로 선언하고, 인스턴스 필드를 포함하고 있지 않다면 정적 메소드로 선언함.
- Calculator 클래스의 덧셈, 뺄셈 기능은 인스턴스 필드를 이용하기보다는 외부에서 주어진 매개값들을 가지고 덧셈과 뺄셈을 수행하므로 정적 메소드로 선언하고, 인스턴스 필드인 색깔을 변경하는 setColor 메소드는 인스턴스 메소드로 선언함.



#### 정적 멤버 사용

- 클래스 이름과 함께 도트(.) 연산자로 접근함.

```java
Calculator.pi; // 정적 필드 사용
Calculator.plus(10, 5); // 정적 메소드 사용
```

- 정적 필드와 정적 메소드는 원칙적으로 클래스 이름으로 접근하는 것이 좋음.
- 객체 참조 변수로도 접근은 가능함.

```
Calculator myCalc = new Calculator();
myCalc.pi;
myCalc.plus(10, 5);
```

- 이클립스에서는 정적 멤버를 클래스 이름으로 접근하지 않고 객체 참조 변수로 접근했을 경우 경고 표시가 나타남.



#### 정적 메소드 선언 시 주의할 점

- 정적 메소드를 선언할 때는 내부에 인스턴스 필드나 인스턴스 메소드를 활용할 수 없음.
- 객체 자신의 참조인 this 키워드도 사용이 불가능함.
- 정적 메소드에서 인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성하고 참조 변수로 접근해야 함.

```java
static void method3(){
	ClassName obj = new ClassName();
	obj.field1 = 10;
	obj.method1();
}
```

- main 메소드도 정적 메소드이므로 객체 생성 없이 인스턴스 멤버를 main() 메소드에서 바로 사용할 수 없음.



### 5.3. 싱글톤

- 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있음. 단 하나만 생성된다고 해서 이 객체를 싱글톤(Singleton)이라고 함.
- 싱글톤을 만들려면 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 함.
- 싱글톤 만들기
  - 1) 생성자 앞에 private 접근 제한자를 붙이기.
    2) 자신의 타입인 정적 필드를 하나 선언하고, private 접근 제한자 붙이고, 자신의 객체를 생성해 초기화.
    4) 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언하고 정적 필드에서 참조하고 있는 자신의 객체를 리턴.

```java
public class Car {
	// 정적 필드
	private static Car singleton = new Car();
	
	// 생성자
	private Car(){}
	
	//정적 메소드
	static Car getInstance(){
	return singleton;
	}
}
```

- 외부에서 객체를 얻으려면 getInstance() 메소드를 호출해야 함.
- getInstance() 메소드는 단 하나의 객체만 리턴함.



### 5.4. final 필드와 상수



#### final 필드

- final 필드는 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없음.

```java
final 타입 필드 [=초기값];
```

- final 필드의 초기값을 주는 방법 2가지
  - 필드 선언 시에 초기값 주기 : 단순 값일 때.
  - 생성자에서 초기값 주기 : 복잡한 초기화 코드가 필요하거나 객체 생성 시에 외부 데이터로 초기화해야 할 때.
- Person 클래스의 ssn 필드. 주민번호는 사람 객체가 생성될 때 부여되기 때문에 클래스 설계 시 초기값을 미리 줄 수 없음. -> 생성자 매개값으로 ssn을 받아서 초기값 주기.
- Person 클래스의 nation 필드. 어떤 객체를 생성하더라도 국적이 고정이기 때문에 필드 선언 시에 초기값 주기.



#### 상수

- 자바의 상수(Constant) : 수학에서 사용되는 원주율 파이나 지구의 무게 및 둘레 등 불변의 값을 저장하는 필드.
- 상수는 객체마다 존재하지 않고 클래스에만 존재함.
- 한 번 초기값이 저장되면 변경할 수 없음.

```java
static final 타입 상수 = 초기화;
```

- 상수 이름은 모두 대문자로 작성.
- 단어의 혼합 사이에는 언더바(_)를 넣어 단어 연결.



## 6. 패키지와 접근 제한자

- 패키지는 파일 시스템의 폴더 역할과 클래스를 유일하게 만들어주는 식별자 역할을 함.
- 클래스 이름이 동일하더라도 패키지가 다르면 다른 클래스로 인식함.
- 클래스의 전체 이름은 '상위패키지.하위패키지.클래스이름' 임.



### 6.1. 패키지 선언

- 코드 작성의 제일 윗 줄에 자동으로 작성됨.
- 패키지는 클래스의 일부로, 클래스만 따로 복사해서 다른 곳으로 이동하면 클래스를 사용할 수 없음.
- 패키지 이름은 자바 식별자 규칙을 따르면서 java로 시작하지 않아야 함.
- 패키지 이름은 모두 소문자로 작성하는 것이 관례.
- 여러 개발 회사가 함께 참여하는 대규모 프로젝트의 경우 패키지 이름이 중복될 가능성을 줄이기 위해 회사의 도메인 이름으로 패키지를 만듦.

```
com.회사명.projectname
org.기관명.projectname
```

- 이클립스 패키지를 계층적으로 보고 싶다면 Package Explorer 뷰의 오른쪽 상단에서 역삼각형 버튼을 클릭하고 [Package Presentation] - [Hierarchical] 선택.



#### import문

- 사용하고자 하는 클래스 또는 인터페이스가 다른 패키지에 소속되어 있다면, import문으로 해당 패키지의 클래스 또는 인터페이스를 가져와 사용할 것임을 컴파일러에게 알려줘야 함.

```java
import 상위패키지.하위패키지.클래스이름;
import 상위패키지.하위패키지.*;
```

- 상위패키지를 import 했다고 하위패키지까지 import되는 것은 아님. 각각 import 해줘야 함.
- 서로 다른 패키지에 동일한 클래스 이름이 존재할 경우 패키지가 포함된 클래스 전체 이름을 기술하여 서로 구분함.

```java
sec06.exam02.hankook.Tire tire3 = new secsec06.exam02.hankook.Tire();
sec06.exam02.kumho.Tire tire4 = new sec06.exam02.kumho.Tire();
```

- 단축키 Ctrl + Shift + O : 자동으로 import문 삽입됨.



### 6.2. 접근 제한자

- 접근 제한자(Access Modifier) : 클래스 및 인터페이스 그리고 이들이 가지고 있는 멤버의 접근을 제한하기 위해서 사용됨.
- 어떤 경우에는 클래스와 인터페이스를 다른 패키지에서 사용하지 못하도록 막을 필요가 있음. 그리고 객체 생성을 막기 위해 생성자를 호출하지 못하게 하거나 필드나 메소드를 사용하지 못하도록 막아야되는 경우도 있음.

- 접근 제한자는 public, protected, default, private 4종류가 있음.
  - public  : 외부 클래스가 자유롭게 사용할 수 있도록 함.
  - protected : 같은 패키지 또는 자식 클래스에서 사용할 수 있도록 함.
  - private : 클래스 외부에서 사용될 수 없도록 함.
  - default : 같은 패키지에 소속된 클래스에서만 사용할 수 있도록 함.
- public -> protected -> default -> private 순으로 접근 제한이 강화됨.



### 6.3. 클래스의 접근 제한

- 클래스는 pubilc, default 2개의 접근 제한을 가짐.



#### default 접근 제한

- 클래스를 선언할 때 public을 생략했다면 클래스는 default 접근 제한을 가짐.
- dafault 접근 제한을 가지면 같은 패키지에서는 아무런 제한 없이 사용할 수 있지만 다른 패키지에서는 사용할 수 없도록 제한됨.



#### public 접근 제한

- 클래스를 선언할 때 public을 붙였다면 클래스는 public 접근 제한을 가짐.
- public 접근 제한을 가지면 같은 패키지뿐만 아니라 다른 패키지에서도 아무런 제한 없이 사용할 수 있음.
- 클래스를 다른 개발자가 사용할 수 있도록 라이브러리 클래스로 개발한다면 반드시 public 접근 재한을 갖도록 해야 함.



### 6.4. 생성자의 접근 제한

- 생성자는 public, protected, default, private 접근 제한을 가짐.
- 자동으로 생성되는 기본 생성자의 접근 제한은 클래스의 접근 제한과 동일함.

- public 접근 제한 : 모든 패키지에서 아무런 제한 없이 생성자 호출 가능.
- protected 접근 제한 : 같은 패키지에 속하는 클래스에서 생성자 호출 가능. 다른 패키지에 속한 클래스가 해당 클래스의 자식 클래스라면 생성자 호출 가능.
- default 접근 제한 : 같은 패키지에 속하는 클래스에서 생성자 호출 가능.
- private 접근 제한 : 클래스 내부에서만 생성자 호출 가능.



### 6.5. 필드와 메소드의 접근 제한

- 필드와 메소드는 public, protected, default, private 접근 제한을 가질 수 있음.
- public 접근 제한 : 모든 패키지에서 아무런 제한 없이 필드와 메소드 사용 가능.
- protected 접근 제한 : 같은 패키지에 속하는 클래스에서 필드와 메소드 사용 가능. 다른 패키지에 속한 클래스가 해당 클래스의 자식 클래스라면 필드와 메소드 사용 가능.
- default 접근 제한 : 같은 패키지에 속하는 클래스에서 필드와 메소드 사용 가능.
- private 접근 제한 : 클래스 내부에서만 필드와 메소드 사용 가능.



### 6.6. Getter와 Setter 메소드

- 일반적으로 객체 지향 프로그래밍에서는 객체의 필드를 객체 외부에서 직접적으로 접근하는 것을 막음.
  - 외부에서 마음대로 변경할 경우 객체의 무결성(결점이 없는 성질)이 깨질 수 있기 때문.
  - 자동차의 속력은 음수가 될 수 없는데 외부에서 음수로 변경하면 객체의 무결성이 깨짐.
- 이러한 문제점을 해결하기 위해 객체 지향 프로그래밍에서는 메소드를 통해서 필드를 변경하는 방법을 선호함.
  - 필드는 외부에서 접근할 수 없도록 막고 메소드를 공개해서 외부에서 메소드를 통해 필드에 접근하도록 유도함.
  - 메소드는 매개값을 검증해서 유효한 값만 객체의 필드로 저장할 수 있기 때문임.
- Setter 메소드 (필드값 변경)

```java
void setSpeed(double speed){
	if(speed < 0){
	this.speed = 0;
    return;
	} else {
	this.speed = speed;
	}
}
```

- 외부에서 객체의 데이터를 읽을 때 Setter 메소드를 사용하면 필드값을 가공한 후 외부로 전달 가능함.
- Getter 메소드 (필드값 읽기)

```java
double getSpeed() {
	double km = speed * 1.6;
	return km;
}
```

- 클래스를 선언할 때 가능하다면 필드를 private으로 선언해서 외부로부터 보호하고, 필드에 대한 Setter와 Getter 메소드를 작성해서 필드값을 안전하게 변경/ 사용하는 것이 좋음.

```java
private 타입 fieldName;

//Setter
public void setFieldName(타입 fieldName) {
	this.fieldName = fieldName;
}

//Getter
public 타입 getFieldName(){
	return FieldName;
}
```

- 필드 타입이 boolean인 경우에는 Getter 메소드는 get으로 시작하지 않고 is로 시작하는 것이 관례임.
- 외부에서 필드값을 읽을 수만 있고 변경하지 못하도록 하려면(읽기 전용) Getter 메소드만 선언해도 좋고, 아니면 Setter 메소드가 private 접근 제한을 갖도록 선언해도 좋음.
- 이클립스에서는 [Source] - [Generate Getters and Setters] 메뉴를 선택하면 선언된 필드에 대한 Getter와 Setter를 자동으로 생성시킬 수 있는 대화상자가 실행됨.
