[TOC]

<br>

# 3과목 데이터베이스 구축

## 1. 데이터베이스의 개요

### 데이터베이스의 개요(하)

#### 데이터베이스 설계

- 데이터베이스 설계 순서
  1. 요구 조건 분석 : 요구 조건 명세서 작성
  2. 개념적 설계 : DBMS에 독립적인 개념 스키마, 트랜잭션 모델링, E-R 모델
  3. 논리적 설계 : 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계
  4. 물리적 설계 : 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
  5. 구현 : 목표 DBMS의 DDL로 데이터베이스 생성, 트랜잭션 생성
- 3단계 데이터베이스 구조 3level Database Architecture
  - 스키마 3단계와 동일함.
  - 미국의 표준화 기관인 ANSI/SPARC에서는 데이터베이스의 복잡한 내부 구조를 감추고 일반 사용자가 데이터베이스에 쉽게 이해하고 이용할 수 있도록 3단계 데이터베이스 구조를 제안하였음.
- 물리적 설계
  - 트랜잭션 처리량과 응답시간, 디스크 용량 등을 고려해야 함.
  - 저장 레코드의 형식, 순서, 접근 경로와 같은 정보를 사용하여 설계함.





#### 스키마

- 개념

  - 데이터베이스를 구성하는 자료 개체, 이들의 성질, 이들 간의 관계, 자료의 조작 및 이들 자료 값들이 갖는 제약조건에 관한 정의를 총칭해서 스키마라고 함.
  - 데이터베이스의 논리적 구조 기술임
  - DBMS 특성과 구현 환경을 감안한 데이터 구조.
  - 직관적으로 하나의 데이터베이스로 이해 가능함.
  - 스키마는 데이터 사전에 저장되며 메타데이터라고도 함.

- 스키마 3단계

  - 외부 스키마(External Schema)

    - 서브스키마, 사용자 뷰
    - 응용 프로그래머나 사용자 그룹 입장에서의 데이터베이스 모습으로 조직의 일부분을 정의한 것.
    - 공용의 의미보다는 어느 개인이나 특정 응용에 한정된 논리적 데이터 구조이며, 데이터베이스의 개별 사용자나 응용 프로그래머가 접근하는 데이터베이스임.
    - 각 개인의 입장에서 필요로 하는 구조를 정의함
    - 하나의 데이터베이스 시스템에는 여러 개의 외부스키마가 존재할 수 있음.

  - 개념 스키마(Conceptual Schema)

    - 전체적인 뷰
    - 모든 응용 프로그램과 사용자들이 필요로 하는 데이터베이스 전체를 정의함.
    - 데이터베이스를 이용하는 사용자들의 관점을 통합하여 데이터베이스를 조직 전체의 관점에서 이해하고 표현함.
    - 전체적인 논리적 구조
    - 트랜잭션 모델링을 하는 단계임.
    - 데이터베이스에서 데이터에 대한 접근 권한, 보안 정책, 무결성 규칙들이 포함됨.

  - 내부 스키마(Internal Schema)

    - 물리적 저장 장치의 입장에서 본 데이터베이스 구조

    - 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄.

    - 데이터베이스를 디스크나 테이프 같은 저장 장치의 관점에서 이해하고 표현함

      

- 인터페이스

  - 응용 인터페이스 : 외부 스키마와 개념 스키마 간의 사상 관계를 나타내는 인터페이스.
  - 저장 인터페이스 : 개념 스키마와 내부 스키마 간의 사상 관계를 나타내는 인터페이스



### 데이터베이스 관리 시스템(DBMS)(하)

### 데이터베이스의 종류(상)

#### RDBMS

- 기본 용어

  - 속성(Attribute)
    - 개체 정보의 특성에 대한 이름임.
    - 프로그래밍 언어에서 기억 장소 이름인 변수명에 해당됨.
    - 파일 시스템에서 레코드의 필드에 해당됨.
    - 각 속성은 유일한 값(원자 값)을 갖고 있어야 함.
    - 한 릴레이션을 구성하는 애트리뷰트 사이에는 순서가 없음.
  - 도메인(Domain)
    - 한 속성에 입력되는 실제 원자 값들의 범위임.
    - 하나의 속성이 가질 수 있는 원자 값들의 집합임.
    - 수험번호가 2byte 정수형으로 선언했다면 수험번호의 도메인은 -32768~32767 사이의 값임.

  - 튜플(Tuple)
    - 속성들에 실제 입력된 값들의 집합임.
    - 하나의 행, 하나의 줄에 해당되는 값임.
    - 파일 시스템에서 레코드에 해당됨.

  - 릴레이션(Relation)
    - 데이터 간에 나타내는 표 자체임.
    - 한 개 이상의 속성들 집합으로 이루어져 있음.
    - 릴레이션 스키마와 릴레이션 어커런스가 결합된 명칭임.
  - 릴레이션 스키마(Relation Schema)
    - 하나 이상의 속성을 합쳐 정의하는 이름임.
    - 릴레이션의 이름과 릴레이션에 포함된 모든 속성의 이름으로 정의하는 릴레이션의 논리적 구조.
    - 릴레이션이름(속성이름1, 속성이름2, ..., 속성이름n)과 같은 형태로 쉽게 표현함.
  - 릴레이션 어커런스(Relation Occurrence)
    - 실제 입력된 튜플들의 집합으로 시간에 따라 변화됨.
    - 릴레이션 인스턴스와 사실상 동의어임.
  - 차수(Degree)
    - 하나의 릴레이션에서 정의된 속성의 개수.
    - 레코드의 필드 수.
  - 카디널리티(Cardinality, 기수)
    - 하나의 릴레이션에 형성된 튜플의 개수 혹은 기수라고 함.
    - 레코드의 수를 의미함.
  - 널(NULL)
    - 속성 값이 비어 있는 상태임.
    - 숫자 0과 공백 문자는 속성 값에 입력된 데이터로 NULL은 아님.
    - 한 바이트가 모두 0인 상태임. 00000000. 초기화 상태. 무 상태. 공백, 숫자 0은 바이트로 00100000, 00110000 임. 
    - 메모리에 가장 많이 분포되어 있는 값.
- 릴레이션의 특징

  - 튜플의 유일성 : 입력되는 모든 튜플은 중복된 튜플이 존재하지 않음.
  - 튜플의 무순서 : 입력되는 모든 튜플은 순서적으로 입력되지 않고 상황에 따라 순서 없이 입력됨.
  - 속성의 원자성 : 속성으로 입력되는 도메인 값은 분해될 수 없는 형태로 입력되어야 함.
  - 속성의 무순서 : 속성 간의 논리적인 순서는 의미가 없음.
  - 속성 이름의 유일성 : 속성 이름은 중복되어서는 안 됨.
- RDBMS의 키

  - 후보키(Candidate Key)
    - 하나의 릴레이션에 있는 모든 튜플에 대해 유일성과 최소성을 모두 만족시켜야 함.
    - 유일성은 모든 튜플을 유일하게 구분할 수 있는 성질이고, 최소성은 가장 작은 개수의 속성으로 구성될 수 있는가를 나타내는 성질임.
    - 슈퍼키 중에서 최소성을 만족하는 것이 후보키가 됨.
    - 후보키를 선정할 때는 현재의 릴레이션 내용만 보고 유일성과 최소성을 판단해서는 안 됨.

  - 기본키(Primary Key)
    - 후보키들 중 데이터베이스의 설계자에 의해서 튜플 구별을 위해 선택된 한 개의 키임.
    - 기본키로 선택된 속성은 NULL 값을 가질 수 없음.
    - 값이 자주 변경될 수 있는 속성이 포함된 후보키는 기본키로 부적합함.
    - 단순한 후보키를 기본키로 선택하는 것이 좋음.

  - 대체키(Alternate Key, 보조키)
    - 후보키 중에서 기본키를 제외한 모든 키는 대체키가 됨.
  - 외래키(Foreign Key)
    - 어떤 릴레이션에 소속된 속성 또는 속성 집합이 다른 릴레이션의 기본키가 되는 키.

    - 릴레이션들 사이의 관계를 올바르게 표현하기 위해 필요함.

  - 슈퍼키(Super Key)
    - 유일성의 특성을 만족하는 속성 또는 속성들의 집합.
    - 유일성은 키가 갖추어야 하는 기본 특성으로, 하나의 릴레이션에서 키로 지정된 속성 값은 튜플마다 달라야 한다는 의미임.
    - 키 값이 같은 튜플은 존재할 수 없음.
    - 튜플을 식별하기 위한 두 개 이상의 속성들의 집합으로 이루어진 키로 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못함.

- 무결성의 제약조건 (Integrity Constraint)

  - 도메인 무결성
    - 하나의 속성에 입력되는 값에 대한 정확성을 유지하는 성질.
    - 테이블에 존재하는 필드의 무결성을 보장하기 위한 것.
    - 특정 속성값은 그 속성이 정의된 도메인에 속한 값이어야 함.
  - 개체 무결성
    - 기본키를 설정하여 그 기본키에 대해 NULL 값을 허용하지 않으므로 하나의 릴레이션으로 삽입되거나 변경되는 튜플들에 대해 정확한 값을 유지하는 성질로 하나의 릴레이션에 있는 튜플은 중복된 튜플이 있어서는 안 된다는 성질임.
  - 참조 무결성
    - 외래키는 참조할 수 없는 값을 가질 수 없다는 규칙.
    - 외래키는 자신이 참조하는 릴레이션에 기본키 값으로 존재하는 값, 즉 참조 가능한 값만 가져야 함.
    - 참조 관계의 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지하는 것.



## 2. 논리 데이터베이스 설계

### 개체와 속성(하)

### 정보 모델링과 데이터 모델링(하)

#### 데이터 모델링

- 개념
  - 현실 세계의 데이터 구조를 컴퓨터 세계의 데이터 구조로 변환하는 개념적인 도구임.
  - 현실 세계의 요구사항을 컴퓨터 세계의 데이터 구조로 변환하기 위하여 개체와 관계를 중심으로 분석, 설계하여 점차적으로 자료 구조를 만들어 가는 과정.

- 데이터 모델링의 구성 요소
  - 논리적 구조(Logical Structure) : 논리적으로 표현된 데이터 구조임.
  - 연산(Operation) : 데이터 구조에서 삽입, 삭제, 변경하는 방법임. 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업.
  - 제약조건(Constraint) : 데이터 구조에서 허용할 수 있는 관계를 명세화함.



#### 데이터 모델링 절차

- 데이터 관점의 데이터 모델링 절차
  - 개념 데이터 모델링
  - 논리 데이터 모델링
  - 물리 데이터 모델링
  - 데이터베이스 구축



#### 논리(Logical) 데이터 모델링

- 개념
- 3단계
- 특성

#### 물리(Physical) 데이터 모델링



#### 데이터베이스 구축

- 설계된 데이터를 저장하기 위해 DBMS를 이용하여 데이터베이스를 생성하는 것.
- 구축 시 고려사항
  - 무결성 : 수정, 삽입, 삭제 후에도 데이터에 문제가 없어야 함.
  - 일관성 : DB 저장된 값의 질의응답 시에 모호성이 없어야 함.
  - 회복성 : 장애 발생 시에 원래 상태로 복구할 수 있어야 함.
  - 보안성 : 불법적인 데이터 접근이나 변경에 보호될 수 있어야 함.
  - 효율성 : 응답 시간의 단축, 저장 공간의 절약, 생산성 등을 고려해야 함.
  - 확장성 : 시스템에 영향을 받지 않는 범위 내에서 새로운 데이터 추가하거나 확대 가능해야 함.



### E-R 다이어그램(ERD) 작성(하)

#### E-R 다이어그램(ERD) 표기법

- 개체 Entity
  - 저장할 만한 가치가 있는 중요 데이터를 가지고 있는 사람이나 사물 등을 가리킴.
  - 개념이나 사건처럼 개념적으로만 존재하는 것도 개체가 될 수 있음.
  - 이름, 하나 이상의 속성을 가지고 있음.
  - 개체 타입은 정의, 개체 인스턴스는 정의를 통해 실체화된 개체를 말함.
  - 사각형으로 표현. 사각형 안에 개체의 이름을 표기함.

- 속성 Attribute
  - 개체가 가지고 있는 고유한 특성.
  - 일반적으로 의미 있는 데이터의 가장 작은 논리적 단위로 인식됨.
  - 타원으로 표현됨. 타원 안에 속성의 이름을 표기함.
  - 단일 값 속성 : 특정 개체를 구성하는 속성 값 하나.
  - 다중 값 속성 : 특정 개체를 구성하는 속성 값 여러 개. -> 이중 타원으로 표현됨.
  - 복합 속성 : 의미를 분해할 수 있어 값이 여러 개의 의미를 포함하는 속성 -> -E 이런 식으로 표시함.
  - 유도 속성 : 값이 별도로 저장되는 것이 아니라 기존의 다른 속성 값에서 유도되어 결정되는 속성. derived attribute. 유도 속성 계산에 사용되는 속성은 저장 속성(stored attribute)라고 함. 점선 타원으로 표현됨.
  - 키 속성 : 개체 집합에 존재하는 각 개체 인스턴스들을 식별하는 데 사용되는 속성. 간단히 키라고도 함. 밑줄을 그어 표현함.

- 관계 Relationship
  - 개체와 개체가 맺고 있는 의미 있는 연관성.
  - 개체 집합들 사이의 대응 관계, 매핑을 의미함.
  - 관계도 개체처럼 속성을 가질 수 있음. 관계를 맺음으로써 발생하는 중요한 데이터들이 관계의 속성이 됨.
  - 마름모로 표현함. 관계의 속성은 타원으로 표현함.
  - 매핑 카디널리티를 기준으로 일대일, 일대다, 다대다 세 가지 유형으로 분류할 수 있음.
  - 개체 B가 개체 A에 종속되면 A를 강한 개체, B를 약한 개체라고 함. 약한 개체는 이중 사각형으로 표현함. 약한 개체가 강한 개체와 맺는 관계는 이중 마름모로 표현함.

- 연결
  - 선으로 표현함.
  - 필수적 참여 관계 : 이중선으로 표현함.




#### 확장 ERD

- 슈퍼 타입과 서브 타입
- 특수화
- 일반화
- 상속
- 집단화
- 분류화



### 관계 스키마와 함수적 종속(상)

#### 관계 스키마

- 관계 스키마 잘못 설계되면 이상 현상 발생함.

- 이상 현상 (Anomaly)

  - 개념
    - 릴레이션에 대한 데이터의 삽입, 수정, 삭제 연산을 수행할 때 부작용이 발생하는 것.
    - 관련이 없는 데이터, 즉 관련 없는 속성들을 하나의 릴레이션에 모아두면 이상 현상 발생함.


  - 이상 현상 종류
    - 삽입 이상 : 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
    - 갱신 이상 : 중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제
    - 삭제 이상 : 튜플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제



#### 함수 종속

- 개념
  - 릴레이션 내의 모든 튜플에서 X 값에 대한 Y값이 항상 하나면 "X가 Y를 함수적으로 결정한다" 또는 "Y가 X에 함수적으로 종속되어 있다"라고 함.
  - 함수 종속 관계는 X -> Y 로 표현하고 X를 결정자, Y를 종속자라고 함.
  - 함수 종속 관계를 판단할 때 유의할 점은, 현재 시점에 릴레이션에 포함된 속성 값만으로 판단하면 안 된다는 것임. 릴레이션 속성 값은 계속 변할 수 있기 때문에 속성 자체가 가지고 있는 특성과 의미를 기반으로 판단해야 함.
  - 기본키나 후보키가 아니더라도 속성 Y 값을 유일하게 결정하는 속성 X는 함수 종속 관계에서 모두 결정자가 될 수 있음.
  - 결정자와 종속자가 같거나, 결정자가 종속자를 포함하는 것처럼 당연한 함수 종속 관계는 고려하지 않음.
- 부분 함수 종속(PFD: Partial Functional Dependency)
  - {A, B} -> C 이면서 동시에 A->C 인 경우 C가 {A,B} 속성 집합에 부분 함수 종속되었다고 함.
  - X->Y 함수 종속에서 속성 집합 Y가 속성 집합 X의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미함.
  - 부분 함수 종속이 되려면 결정자가 여러 개의 속성들로 구성되어 있어야 함. {A, B} -> C

- 완전 함수 종속(FFD: Full Functional Dependency)
  - {A, B} -> C 에서 {A,B} 의 일부분이 아닌 속성 집합 전체에만 종속되는 경우 C가 {A, B} 속성 집합에 완전 함수 종속되었다고 함.
  - 릴레이션에서 속성 집합 Y가 속성 집합 X에 함수적으로 종속되어 있지만, 속성 집합 X 전체에 종속된 것이지 일부분에 종속된 것이 아님을 의미함.
- 함수 종속일 때의 추론 규식
  - 반사 규칙 : B가 A에 포함됨. ==  A -> B
  - 첨가 규칙 : A -> B 이면 AC -> BC 임.
  - 이행 규칙 : A -> B 이고 B -> C 이면 A -> C
  - 분해 규칙 : A -> BC 이면 A -> B 또는 A -> C
  - 결합 규칙 : A -> B 이고 A -> C 이면 A -> BC




#### 관계 대수

- 개념
  - Relational Algebra
  - 관계 데이터 연산 중 하나.
  - 원하는 결과를 얻기 위해 데이터의 처리 과정을 순서대로 기술, 절차적 언어
  - 관계 대수와 관계 해석은 상용화된 관계 데이터베이스에서는 실제로 사용되지 않는 개념적 언어임. 관계 대수나 관계 해석으로 기술할 수 있는 모든 질의를 새로 제안된 데이터 언어로 기술할 수 있으면 관계적으로 완전(relationally complete)하다고 하고, 이를 통해 해당 언어가 어느 정도 검증됐다고 판단함. 보통 상용화된 관계 데이터베이스에서 사용하는 데이터 언어들도 관계적으로 완전하다고 판단된 것들임.
  - 관계 대수는 연산자들의 집합임. 관계 대수는 릴레이션을 연산함. 피연산자가 릴레이션. 피연산자와 결과가 모두 릴레이션임.
  - 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시함.
- 일반 집합 연산자
  - 합병 가능 union compatible : 차수+도메인 같음
    - 두 릴레이션의 차수가 같아야 함. (속성 개수가 같음)
    - 두 릴레이션에서 서로 대응되는 속성의 도메인이 같아야 함. (도메인 같으면 속성 이름 달라도 됨)

  - 합집합 : 일반 집합의 합집합
  - 교집합 : 일반 집합의 교집합
  - 차집합 (-)
    - 교집합을 제외한 부분을 반환함.

  - 카티션 프로덕트 (*)
    - 곱집합(Cartesian Product)
    - 릴레이션 R의 각 튜플과 릴레이션 S의 각 튜플을 모두 연결하여 만든 새로운 튜플을 반환함.
    - 두 릴레이션이 합병은 불가능한 경우에도 카티션 프로덕트 연산은 가능함.
    - 카티션 프로덕트 연산을 한 후 얻게 되는 결과 릴레이션의 차수는 피연산자인 릴레이션 R과 S의 차수를 더한 것과 같음.
    - 카티션 프로덕트 연산을 한 후 얻게 되는 결과 릴레이션의 카디널리티는 릴레이션 R과 S의 카디널리티를 곱한 것과 같음.
    - 카티션 프로덕트 연산은 교환법칙과 결합법칙이 성립함.
- 순수 관계 연산자
  - 셀렉트
    - 시그마 기호 사용함.
    - 릴레이션 R에서 조건을 만족하는 튜플들을 반환.
    - 결과 릴레이션은 주어진 릴레이션을 수평으로 절단한 모양이 됨. 해당 릴레이션에서 수평적 부분집합을 생성한 것과 같음. horizontal subset
    - 하나의 릴레이션을 대상으로 수행함.
    - 조건식은 비교 연산자를 이용해 구성함.
    - 조건식을 비교식 또는 프레디킷(predicate)이라고도 함.
    - 릴레이션 where 조건식

  - 프로젝트
    -  파이 기호 사용함.
    -  릴레이션 R에서 주어진 속성들의 값으로만 구성된 튜플들을 반환.
    -  결과 릴레이션이 주어진 릴레이션의 일부 열로만 구성되어 해당 릴레이션에서 수직적 부분집합을 생성한 것과 같음. vertical subset.
    -  릴레이션[속성리스트]

  - 조인
    - 릴레이션 하나로 원하는 데이터를 얻을 수 없어 관계가 있는 여러 릴레이션을 함께 사용해야 하는 경우 조인 연산을 이용함.
    - 기호 |> <|
    - 공통 속성을 이용해 릴레이션 R과 S의 튜플들을 연결하여 만든 새로운 튜플들을 반환.
    - 동등 조인 : 조인 속성 중복 표시됨.
    - 세타 조인 : 비교 연산자 사용. 세타 조인에서 = 연산자를 사용한 것이 동등 조인임.
    - 자연 조인 : 조인 속성 한 번만 표시됨.

  - 디비전
    - 기호 나누기
    - 릴레이션 S의 모든 튜플과 관련이 있는 릴레이션 R의 튜플들을 반환.




#### 관계 해석

- 개념
  - 관계 데이터 연산의 한 종류.
  - 원하는 결과를 얻기 위해 처리를 원하는 데이터가 무엇인지만 기술, 비절차적 언어
  - 데이터를 처리하는 기능과 처리를 요구하는 표현력에서 관계 대수와 관계 해석은 능력이 모두 동일함.
  - 수학의 프레디킷 해석에 기반을 두고 있음.
- 기호
  - 존재한다 E 거꾸로 exist
  - 모든것에대하여 A 거꾸로 for all
  - 속한다 E
  - 합집합 U 눕힌거



### 데이터베이스의 정규화(중)

#### 정규화

- 개념
  - 하나의 릴레이션에 하나의 의미만 존재할 수 있도록 릴레이션을 분해해나가는 과정.
  - 데이터 모델링의 단계 중 가장 중요한 단계로써 논리 데이터 모델링을 상세화하는 단계임.
  - 중복성을 최소화하고 정보의 일관성을 보장하기 위한 개념임.
  - 정규형(Normal Form)이란 특정 조건에 만족하는 릴레이션 스키마의 형태를 의미함.
  - 이상 현상이 발생하지 않도록, 릴레이션을 관련이 있는 속성들로만 구성하기 위해 릴레이션을 분해(decomposition)하는 과정.
  - 정규화를 수행하려면 먼저 릴레이션을 구성하는 속성들 간의 관련성을 판단할 수 있어야 함. 정규화 과정에서 고려해야 하는 속성들 간의 관련성을 함수적 종속성(FD, Functional Dependency)이라고 함.
  - 일반적으로 릴레이션에 함수적 종속성이 하나만 존재하도록 정규화를 통해 릴레이션을 분해함.
- 목적
  - 구성되는 모든 릴레이션이 중복되지 않게 효과적으로 데이터베이스 내에 표현이 가능하도록 함.
  - 보다 간단한 연산자에 의해 효과적인 연산이 가능하도록 구성함.
  - 새로운 형태의 데이터가 삽입될 때 릴레이션을 재구성할 필요성을 감소시키도록 함
  - 자료 검색과 추출의 효율성을 추구할 수 있음
  - 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만듦.
- 필요성
  - 자료의 저장 공간을 최소화
  - 자료의 불일치를 최소화
  - 자료 구조를 안정화
  - 자료의 삽입, 삭제, 갱신 시 이상 현상을 방지
- 장점
  - 정규화 수준이 높으면 유연한 데이터 구축이 가능함.
  - 정규화 수준이 높으면 데이터의 정확성 높아짐.
- 단점
  - 정규화 수준이 높으면 물리적 접근이 복잡해짐.
  - 정규화 수준이 높으면 길이가 짧은 데이터 생성으로 많은 조인이 발생함.
- **정규화 과정**

  - 비정규형

  - 제1NF(제1정규형) : 도메인을 원자 값만 갖도록 분해함.

  - 제2NF(제2정규형) : 부분 함수 종속을 제거함.

  - 제3NF(제3정규형) : 이행적 함수 종속을 제거함.

  - 보이스 코드 정규형 : 결정자가 후보키가 아닌 함수 종속을 제거함.

  - 제4NF(제4정규형) : 다중치 종속을 제거함.

  - 제5NF(제5정규형) : 후보키를 통하지 않은 조인 종속을 제거함.
- 기본 정규형 : 1,2,3,보이스코드 정규형
- 고급 정규형 : 4,5 정규형



#### 정규화의 단계 (도부이결다조)

- 제1정규형(1NF : First Normal Form)
  - 하나의 튜플에서 여러 개의 값이 들어와 원자성을 가지지 못하는 경우(비정규형)에 도메인 값을 분해하면 1정규형이라고 함.
  - 비정규형 릴레이션에서 속성의 도메인이 원자값으로만 구성되도록 릴레이션 분해한 것.
  - 릴레이션에 속한 모든 속성의 도메인이 원자 값으로만 구성되어 있으면 제 1 정규형에 속함.
  - 반복 그룹(Repeat Group) 속성을 제거함.
  - 모든 속성은 반드시 하나의 값을 가져야 함. 반복 형태가 있어서는 안 됨.
- 제2정규형(2NF : Second Normal Form)
  - 릴레이션이 제1정규형이 속하고 기본키에 속하지 않는 모든 속성들이 기본키에 완전 함수 종속이면 제2정규형이 속함.
  - 제1정규형 릴레이션에서 부분 함수 종속을 제거한 것.
  - 주 식별자 전체에 완전 함수 종속(Full Function Dependency)이 되지 않는 속성을 제거함.
  - 주 식별자 속성 일부에만 함수적 종속되는 속성들을 상위 개체로 도출함.
  - 릴레이션 분해 시 주의할 점은 분해된 릴레이션들을 자연 조인하여 분해 전의 릴레이션으로 다시 복원할 수 있어야 한다는 것임. 릴레이션들이 의미상 동등한 릴레이션들로 분해되어야 하고, 릴레이션을 분해했을 때 정보 손실이 발생하지 않아야 함.
- 제3정규형(3NF : Third Normal Form)
  - 릴레이션이 제2정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제 3 정규형에 속함.
  - 제2정규형 릴레이션에서 이행적 함수 종속을 제거한 것.
  - A->B, B->C, A->C 관계를 이행적 함수 종속이라고 함. 일종의 여자 양다리.
  - 학생, 학과, 지도교수의 관계에서 학생이 학과를 선택하면 지도교수가 배정되는 것인데, 마치 학생이 지도교수를 선택한 것처럼 보이는 경우가 이행적 함수 종속임.
  - 학생-학과 릴레이션과 학과-지도교수 릴레이션으로 분리하면 됨. 학과는 교수 릴레이션의 기본키이면서 학생 릴레이션의 외래키가 됨.
  - 중간 다리인 학과를 외래키와 기본키 역할을 하는 릴레이션 2개로 분할하는 것이 제3정규형임.
  - 주 식별자에 이행 종속(Transitive Dependency)되는 속성을 제거함.

- 보이스 코드 정규형(BCNF : Noyce-Codd NF)
  - 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키이면 보이스 코드 정규형에 속함.
  - 제3정규형에서 후보키가 아닌 결정자를 제거한 것.
  - 하나의 릴레이션에 여러 개의 후보키가 존재할 수 있는데, 이 경우에는 제3정규형까지 모두 만족하더라도 이상 현상이 발생할 수 있음.
  - 강한 제 3 정규형(strong 3NF)이라고도 함. 제 3 정규형에 추가적인 제약조건이 있음.
  - 비결정자에 의한 함수 종속을 제거하여 모든 결정자가 후보키가 되도록 하는 데 있음.
  - {A, B} -> C 이면서 동시에 C -> B 인 경우 => A->C , C->B 2개의 릴레이션으로 분해. C는 후보키가 아닌 결정자가 됨.
  - 고객아이디 / 인터넷강좌 / 담당강사 3개의 속성으로 구성된 릴레이션에서 발생함. {고객아이디, 인터넷강좌} -> 담당강사 / 담당강사 -> 인터넷강좌
  - 비결정자에 의한 함수적 종속 제거 -> 기본키가 아닌 다른 속성에 의해  함수적 종속되는 것을 제거

- 제4정규형(4NF : Four Normal Form)
  - 1:1인 함수 종속 관계가 아닌 1:N 형태로 종속되는 관계를 다치 종속 관계라고 함.
  - A ->> B
  - 보이스/코드 정규형을 만족하면서, 함수 종속이 아닌 다치 종속을 제거해야 만족할 수 있음.
  - 만약 과목 10개, 교수10명, 출판사 10개를 하나의 릴레이션으로 표현하면 최대 1000개의 데이터 조합이 발생할 수 있음. 과목과 교수, 과목과 출판사로 릴레이션을 분해하면 각각 100개의 데이터씩 200개로 데이터 조합이 줄어듦. 데이터의 개수도 줄고 이상 현상도 발생하지 않게 됨.
- 제5정규형(5NF : Five Normal Form)
  - 제 4 정규형을 만족하면서, 후보키를 통하지 않는 조인 종속을 제거해야 만족할 수 있음.
  - 어떤 릴레이션 R에 존재하는 모든 조인 종속성이 릴레이션 R의 후보키를 통해서만 성립됨.
  - 정규화를 통해서 분해된 각 릴레이션들은 처음의 릴레이션으로 재구성될 수 있다면 조인 종속성을 만족시킴.
  - 복원 확인 : 릴레이션의 이상 현상을 제거하기 위해 여러 개의 릴레이션으로 분해했다면, 분해된 릴레이션들로 자연조인 했을 때, 원래의 릴레이션이 될 수 있는지 확인해야 함.
  - 원래의 릴레이션으로 복원될 수 있다면 제5정규형이 완료되는 것이고, 그렇지 않다면 새롭게 릴레이션을 추가해서라도 원래의 릴레이션으로 복원되도록 해야 함.
  - 자연조인할 때 존재하지 않는 튜플이 생성되는 것을 부당 튜플이라고 함.



### 논리 데이터 모델 품질 검증(하)



## 3. SQL

### SQL 명령어(상)

#### 데이터 정의어

- 개념
  - DDL : Data Definition Language
  - 데이터베이스를 정의하거나 그 정의를 수정할 목적으로 사용하는 언어.
  - 기본 테이블, 뷰 테이블, 또는 인덱스 등을 생성, 변경, 제거하는데 사용되는 명령어.

- DDL 명령어 종류
  - CREATE : 테이블 생성
  - ALTER : 테이블 변경
  - DROP : 테이블 삭제
  - TRUNCATE : 테이블 내용 삭제

- 삭제, 갱신의 제약조건 CONSTRAINT
  - 참조된 기본키의 값이 삭제 또는 수정될 경우
  - CASCADE : 참조한 테이블에 있는 외래키와 일치하는 모든 행 삭제, 갱신
  - RESTRICT : 참조한 테이블에 있는 외래키에 없는 것만 삭제, 갱신. 테이블을 삭제 갱신할 때 참조하는 테이블이 있다면 실행을 취소함.
  - NULLIFY : 참조한 테이블에 정의된 외래키와 일치하는 것을 NULL로 수정

- CHECK는 개발자가 정의하는 제약조건. 상황에 따라 다양한 조건 설정이 가능함.



#### CREATE 명령어

- CREATE TABLE 테이블명 ( 내용 );
- 내용
  - 필드명 데이터타입 [DEFAULT 값] [NOT NULL]
  - [PRIMARY KEY (필드 리스트)]
  - [FOREIGN KEY (필드 리스트) REFERENCES 테이블명 [(필드명)] [ON DELETE 옵션] [ON UPDATE 옵션]]
  - [CHECK (조건식) | UNIQUE(필드명)]



#### ALTER 명령어

- ALTER TABLE 테이블명 내용;
- 내용
  - ADD 필드명 데이터타입 [DEFAULT 값]
  - FIRST
  - AFTER 앞필드명
  - MODIFY 필드명 데이터타입 [DEFAULT 값]
  - DROP 필드명
  - ADD [CONSTRAINT 제약조건명] 제약조건(필드명)
  - DISABLE CONSTRAINT 제약조건명
  - ENABLE CONSTRAINT 제약조건명
- ALTER TABLE 이전테이블명 RENAME 새테이블명;
  - RENAME TABLE 이전테이블명 TO 새테이블명;



#### DROP 명령어

- DROP TABLE 테이블명 [CASCADE or RESTICT]



#### TRUNCATE 명령어

- TRUNCATE TABLE 테이블명;



#### 데이터 조작어

- DML : Data Manipulation Language
- 데이터 삽입(INSERT)
- 데이터 수정(UPDATE)
- 데이터 삭제(DELETE)
- 데이터 조회(SELECT)



#### SELECT 명령어

- SELECT 명령어 옵션
  - DISTINCT : 중복 튜플을 제거하여 조회.
  - \* : 모든 필드 조회
  - AS 별명 : 필드명이나 연산 결과를 별명으로 제목 부여
  - WHERE 조건 : 조건 만족하는 튜플들만 조회
  - GROUP BY 필드명 : 그룹별로 묶을 필드명을 지정함.
    - 그룹화하기 위해 집계함수 COUNT(), MAX(), MIN(), SUM(), AVG()와 함께 자주 사용됨.

  - HAVING 조건 : GROUP BY 절에 의해 생성된 결과 값 중 원하는 조건에 부합하는 데이터만 보고자 할 때 사용함.
  - ORDER BY : ASC(오름차순, 생략 가능) , DESC(내림차순)

- 집계 함수
  - COUNT(), SUM(), AVG(), MAX(), MIN()
  - STDDEV() : 표준편차
  - VARIAN() : 분산


- 조건 지정 검색 명령
  - 학점 IS NULL : 학점이 NULL.
  - 과제 IN(0, 1) : 과제가 0 또는 1
  - 이름 LIKE '김%' : 이름이 '김'으로 시작되는
  - 이름 LIKE '%김%' : 이름에 '김'이 표함된
  - 이름 LIKE '%김' : 이름이 '김'으로 끝나는
  - 시험점수 BETWEEN 60 AND 90 : 시험 점수가 60이상 90점 이하
- 부속, 복수 질의 명령
  - ANY : 부속 SELECT 앞에 ANY를 붙이면 결과들의 OR 연산 수행함. 합집합.
  - ALL : 부속 SELECT 앞에 ALL을 붙이면 결과들의 AND 연산 수행함. 교집합.
- 그룹 지정 명령
  - WHERE 구문은 GROUP BY보다 먼저 실행되고 WHERE 구문 안에 포함되지 않음.
  - GROUP BY ~ HAVING 조건
  - `SELECT 학번, COUNT(*) FROM 성적테이블 GROUP BY 학번;`
- 집합 명령
  - UNION : 중복 제거한 합집합
  - UNION ALL : 중복 제거 안 한 합집합
  - INTERSECT : 중복 제거한 교집합
  - EXCEPT : 차집합. 중복행이 제거됨.
- 테이블 생성
  - 새롭게 생성하고자 하는 테이블이 기존에 사용하고 있는 테이블과 동일한 구조를 갖고 있다면 기존에 존재하는 테이블 정보를 이용하여 새로운 테이블을 만들 수 있음.
  - CREATE TABLE 신규테이블 AS SELECT * FROM 기존테이블;



#### 데이터 제어어

- DCL : Data Control Language
- DCL 명령어 : 사용자 권한.
  - GRANT : 사용자 권한 부여
  - REVOKE : 사용자 권한 회수
- TCL 명령어 : 트랜잭션
  - COMMIT : 트랜잭션을 확정함.
  - ROLLBACK : 트랜잭션 취소
  - CHECKPOINT : 복귀지점 설정




#### 트랜잭션 제어어(TCL)

- TCL 명령어
  - COMMIT
    - 변경 사항이 물리적인 디스크에 저장됨.
    - COMMIT 명령 이후에는 COMMIT 이전 상태로 복구할 수 없음.
    - 모든 사용자가 변경된 결과를 볼 수 있음
  - ROLLBACK
    - 데이터베이스의 연산에 문제가 발생하면 이미 수행되었던 모든 작업을 취소하고 원래 상태로 복귀함.
    - ROLLBACK 명령 이후 메모리상의 버퍼(Buffer)에만 영향을 미치기 때문에 복구가 가능함.
  - SAVEPOINT
    - 특정 중간 시점을 SAVEPOINT로 지정하고, SAVEPOINT 이후에 오류가 발생하면, 처음부터 다시 시작하는 것이 아니라 SAVEPOINT부터 실행을 할 수 있음.



#### 트랜잭션

- 개념

  - 데이터베이스의 현재 상태를 하나의 일관된 상태에서 또 다른 일관된 상태로 변환시키는 논리적인 연산의 집합.
  - 트랜잭션은 일 처리 단위를 의미함.

- 특징

  - 트랜잭션은 논리적 연산 단위임.
  - 한 개 이상의 데이터베이스 조작임.
  - 하나 이상의 SQL 문장이 포함됨.
  - 트랜잭션은 거래임. 거래 결과가 모두 반영되거나 또는 모두 취소되어야 함.

- 특성 4가지

  - 원자성(Atomicity)
    - 트랜잭션의 연산은 모두 실행되거나 모두 실행되지 않아야 함.
    - 트랜잭션은 일부만 수행된 상태로 종료되어서는 안 됨.
    - 트랜잭션 A가 수행되는 동안 다른 트랜잭션 B는 트랜잭션 A가 지금까지 수행한 중간 결과를 참조할 수 없음.
  - 일관성(Consistency, 무결성)
    - 트랜잭션 실행 전과 후 동일하게 오류가 없어야 함.
    - 트랜잭션을 완전히 실행하면 데이터베이스를 하나의 일관된 상태에서 다른 일관된 상태로 바꿔야 함.

  - 고립성(Isolation, 독립성, 격리성)
    - 트랜잭션 실행 중 다른 트랜잭션에 영향을 받지 않아야 함.
    - 하나의 트랜잭션의 실행은 동시에 실행 중인 다른 트랜잭션의 간섭을 받아서는 안 됨.
  - 지속성(Durability, 계속성, 영속성, 장애 대응성)
    - 트랜잭션 결과는 항상 보존되어야 함.
    - 트랜잭션에 의해서 변화된 상태는 계속해서 유지될 수 있어야 함.
    - 완료한 트랜잭션에 의해 데이터베이스에 가해진 변경은 어떠한 고장에도 손실되지 않아야 함.

- 트랜잭션 상태 제어
  - 트랜잭션 상태를 제어한다는 것은 흐름의 구조를 바꾼다는 것이 아니라 트랜잭션의 결과를 수용하거나 취소하는 것을 의미함.
  - 활동(Active) : 트랜잭션 실행 중.
  - 부분 완료(Partially Committed) : 트랜잭션이 마지막 연산을 끝내고 데이터베이스에 실행 결과를 적용하기 직전의 상태.
  - 완료(Comitted) : 트랜잭션이 연산을 완료하고 연산의 결과를 데이터베이스에 적용한 상태(거래 확정)
  - 실패(Failed) : 트랜잭션이 실행 중 어떤 오류에 의해서 더 이상 진행될 수 없는 상태임.
  - 철회(Aborted) : 트랜잭션 실행이 실패하여 복귀되어 있는 상태. ROLLBACK 연산 수행한 상태.
  - Redo(Re+Do, 다시 실행) : 갱신이 완료된 데이터를 로그 파일을 이용하여 복원함. 이미 진행 중이었던 작업을 다시 함.
  - Undo(Un+Do, 실행취소 = ROLLBACK) : 변경되었던 데이터를 취소하여 원래의 내용으로 복원함. 했던 작업을 다시 하지 않고 원상태로 되돌림.
- 타임스탬프 기법
  - 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임스탬프를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하여 트랜잭션 간의 처리순서를 미리 정하는 기법.

- 로킹 기법
  - 같은 자원을 액세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장하는 직렬화 기법.




#### CRUD

- C(Create), R(Read), U(Update), D(Delete)
- CRUD Matrix
- CRUD 분석



### 절차형 SQL(하)

#### 트리거

- Trigger



### 인덱스와 뷰(하)

#### 인덱스

- Index
- 개념
  - 데이터베이스 성능에 많은 영향을 주는 DBMS의 구성 요소로 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유함.
  - 문헌의 색인, 사전과 같이 데이터를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조.
  - 테이블에 붙여진 색인으로 데이터 검색 시 처리 속도 향상에 도움이 됨.
  - 인덱스는 기본 테이블의 특정 레코드 위치를 알려주는 용도로 사용함.
  - 인덱스는 자동 생성되지 않기 때문에 데이터베이스 사용자가 지정해주어야 함. 다만 데이터베이스 사용자가 특정 컬럼을 기본키(PK)로 지정할 경우에 인덱스는 자동 생성됨.
  - 인덱스는 조건절에 '='로 비교되는 컬럼을 대상으로 인덱스를 생성하면 검색 속도를 높일 수 있음.
  - 인덱스의 기본 목적은 검색 성능을 최적화하는 것으로 볼 수 있음.
  - B-트리 인덱스는 분기를 목적으로 하는 Branch Block을 가지고 있음.
  - BETWEEN 등 범위(Range) 검색에 활용될 수 있음.
- 생성 : `CREATE [UNIQUE] INDEX <인덱스명> ON <테이블명> (<필드명들>);`
- 삭제 : `ALTER TABLE <테이블명> DROP INDEX <인덱스명>`
  - 보통 인덱스를 테이블의 종속 구조로 생각하기 때문에 인덱스를 삭제하기 위해 테이블에 변경을 가하는 형식의 명령을 사용함.
- 조회 : `SHOW INDEX FROM <테이블명>`



#### 뷰

- View.

- 개념
  - 하나 이상의 뷰 테이블은 기본 테이블로부터 유도되어 정의되는 가상 테이블이며 뷰 테이블로 정의한 정보는 시스템 카탈로그에 저장됨.
  - 뷰 테이블은 물리적으로 존재하지 않고 또한 물리적으로 분리될 수도 없음.
  - 외부 스키마를 구성하는 데 쓰임.
  - 같은 데이터를 동시에 여러 사용자에게 상이한 방법으로 제공할 수 있음.
  - 제공되지 않은 데이터에 대해서는 자동적으로 보안을 유지할 수 있음.
  - 뷰 위에 또 다른 뷰를 정의할 수 있음.
  - 뷰 테이블을 변경하려면 뷰 테이블을 DROP으로 삭제하고 다시 생성해야 함.
- 뷰(View)의 장점
  - 논리적 독립성 제공 : 테이블의 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 됨.
  - 사용자 데이터 관리 용이 : 복수 테이블에 존재하는 여러 종류의 데이터에 대해 단순한 질의어 사용이 가능함.
  - 데이터 보안 용이 : 중요 보안 데이터를 저장 중인 테이블에는 접근 불허하며, 해당 테이블의 일부 정보만을 볼 수 있는 뷰에는 접근을 허용하는 방식.
- 뷰의 단점
  - 뷰 자체 인덱스 불가능
  - 뷰 정의 변경 불가능
  - 데이터 변경 제약 존재
- 뷰의 생성
  - `CREATE VIEW <뷰 이름>(컬럼 목록) AS <SELECT문> [옵션];`
- 뷰의 옵션
  - REPLACE / FORCE / NOFORCE / WITH CHECK OPTION / WITH READ ONLY
- 뷰의 삭제
  - `DROP VIEW <뷰 이름>;`
- 뷰의 조회
  - `SELECT * FROM <뷰 이름>;`



### SQL 지원 도구(하)



#### 시스템 카탈로그

- System Catalog. 데이터 사전. 시스템 데이터베이스
- 개념
  - 테이블 정보, 인덱스 정보, 뷰 정보 등을 저장하는 시스템 테이블임.
  - 사용자들이 검색은 가능하나 직접적인 변경은 불가능함.
  - 시스템이 필요로 하는 모든 객체에 대한 정보를 가지고 있는 시스템 데이터베이스로 사용자 데이터베이스와는 구별됨.
  - 시스템 데이터베이스에는 카탈로그와 디렉토리로 나누어 저장하는데 카탈로그에는 객체에 대한 정보를 저장하고 디렉토리에는 그 정보를 어떻게 액세스할 것인가하는 시스템만이 사용하는 정보를 저장하게 됨.
- 구성 요소
  - 시스템 카탈로그 : 생성된 테이블에 관련된 정보를 기록함.
  - 데이터 디렉토리 : 데이터 사전에 수록된 데이터를 실제로 접근하는 데 필요한 정보를 기록하며 시스템만이 접근할 수 있는 구역.
  - 메타 데이터 : 사용자의 데이터를 설명해 놓은 데이터 사전임.
  - 데이터 사전 : 사용자의 테이블과 속성의 관련 정보를 기록함.



### 병행 제어와 로킹(중)

#### 병행 제어

- 개념
  - Concurrency Control, 동시성 제어
  - 여러 사용자들이 데이터베이스의 공동 사용을 최대화함.
  - 사용자의 응답 시간을 최소화함.
  - 데이터베이스 시스템의 활용도를 최대화함.
  - 데이터베이스의 일관성을 유지함.
- 병행 처리의 문제점
  - 분실된 갱신 Lost update
  - 모순성 Inconsistency
  - 연쇄 복귀 Cascading Rollback
  - 비완료 의존성 Uncommitted Dependency
- 병행 제어 기법 종류
  - 로킹(Locking) : 일관성과 무결성을 유지하기 위한 트랜잭션의 순차적 진행을 보장하는 직렬화 기법
  - 낙관적 검증 : 일단 트랜잭션을 수행하고, 트랜잭션 종료 시 검증을 수행
  - 타임 스탬프 순서 : 타임 스탬프를 부여해 부여된 시간에 따라 트랜잭션 수행. 트랜잭션 간의 처리 순서를 미리 정하는 방법.
  - 다중버전 동시성 제어(MVCC) : 타임스탬프를 비교해 직렬가능성이 보장되는 적절한 버전을 선택해 접근하도록 함




#### 로킹

- 개념
  - Locking
  - 병행 제어 기법 중 하나. 동시성 제어 기법 중 하나.
  - 데이터베이스에서 하나의 트랜잭션에 사용하는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는 행위.
  - 데이터베이스, 파일, 레코드 등은 로킹단위가 될 수 있음.
- 로킹 단위
  - 로킹의 대상이 되는 객체의 크기. 한꺼번에 로킹할 수 있는 객체의 크기.
  - 로킹 단위가 작아짐 : 로크의 수 많음, 병행성 수준 높음, 오버헤드 증가, 복잡함, DB공유도증가
  - 로킹 단위가 커짐 : 로크의 수 적음, 병행성 수준 낮음, 오버헤드 감소, 단순함, DB공유도감소
  - 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음.
  - 오버헤드 : 로크의 단위가 작아지면 로크의 수는 많이 늘어날 것이고, 많은 로크를 관리하기 위한 간접 비용 부담인 오버헤드는 증가할 수밖에 없다.




#### 회복

- 개념
  - Recovery
  - 데이터베이스의 상태가 일관성 유지에 제약이 걸렸을 때 장애 이전의 일관된 상태가 되도록 복원하는 일.
- 장애의 유형
  - 실행 장애 : 사용자 실수
  - 트랜잭션 장애 : 트랜잭션 내의 논리적 오류
  - 시스템 장애 : hw 오작동으로 내용 유실, 교착상태
  - 미디어 장애 : 데이터 전송 중에 헤드 충격이나 고장으로 인하여 디스크 등이 작동하지 못하는 상태

- 회복에 따른 연산자
  - Redo : 갱신이 완료된 데이터를 로그를 이용해 데이터베이스에 적용하는 연산. 데이터베이스 내용 손상됐을 때 백업.
  - Undo : 변경된 데이터를 취소하여 원래의 내용으로 복원시키는 연산. 트랜잭션 실행 중 실패했을 경우.

- 회복 기법
  - 연기 갱신 (Differed Update) : 트랜잭션이 성공적으로 종료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기하고 그 동안 변경 내용은 로그에 보관하는 기법. 회복 작업 시 Redo 작업만 수행됨.
  - 즉각 갱신 (Immediate Update) : 트랜잭션이 데이터를 변경하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 데이터베이스에 반영하는 기법. 회복 작업 시 Redo, Undo 모두 수행.
  - 그림자 페이지 (Shadow Paging) : 갱신 이전의 데이터베이스를 일정 크기의 페이지 단위로 구성하여 각 페이지마다 복사본인 그림자 페이지로 별도 보관해 두고, 실제 페이지를 대상으로 트랜잭션에 대한 변경 작업을 수행하는 기법. 회복을 위해 로그 유지할 필요 없음. 회복 작업 시 Redo, Undo 수행 안함.
  - 검사점 (Check Point) : 장애 발생 시 로그 전체를 조사하지 않고 로그 내에서 가장 최근의 검사점으로부터 회복 작업을 수행하여 회복 시간을 단축함.
  - 미디어 회복 (Media Recovery) : 데이터베이스 내용을 주기적으로 안전한 저장 장치에 덤프함.



## 4. 물리 데이터베이스 설계

### 물리 데이터 모델 설계(하)

#### 파티션

- 종류
  - 범위 분할
  - 해시 분할
  - 조합 분할
- 장점



### 저장 레코드 형식 설계(하)



### 반정규화 수행(하)

#### 반정규화

- 개념
  - De-Normalization



#### 반정규화 유형

- 중복 테이블 추가
  - 중복 테이블 추가 용도
  - 집계(통계) 테이블을 추가하는 방법
  - 진행 테이블 추가 상황 확인
  - 진행 테이블 생성 시 유의 사항 확인
  - 특정 부분만 포함하는 테이블을 추가하는 방법
  - 테이블 추가 시 고려사항

- 테이블 조합
- 테이블 분할
  - 수평 분할 (Horizontal Partitioning)
  - 수직 분할 (Vertical Partitioning)



### 분산 데이터베이스 설계(중)

#### 분산 데이터베이스

- 개념
  - 하나의 논리적 데이터베이스가 물리적으로 네트워크에서 복수의 컴퓨터에 분산되어 있을 경우에도 사용자가 단일 데이터베이스와 같이 인식하는 것이 가능하도록 논리적으로 통합 및 공유되는 데이터베이스를 의미함.
- 구성 요소
  - 분산 처리기 : 물리적으로 분산되어 지역별로 필요한 데이터를 처리할 수 있는 지역 컴퓨터(Local Computer)를 분산 처리기(Distributed Processor)라고 함.
  - 분산 데이터베이스 : 지리적으로 분산된 데이터베이스
  - 통신 네트워크 : 분산 처리기들을 통신망으로 연결
- 장점
  - 데이터에 대한 지역적 분산 제어를 통해 원격 데이터에 대한 의존도를 감소시킬 수 있음.
  - 단일 서버에서 처리가 어렵거나, 불가능한 규모의 대용량 데이터 처리가 가능해짐.
  - 기존 시스템에 서버를 추가하는 방식을 통해 점진적 확장이 용이함.
  - 하나의 사이트에 문제가 생겨도 다른 사이트에서 사용할 수 있기 때문에 신뢰도와 가용성이 향상됨.
- 단점
  - 복잡도와 SW 개발 비용, 처리비용이 증가함.
  - 통제 기능이 상대적으로 취약함.
  - 오류 발생 가능성 증가함.
  - 응답 속도가 불규칙적으로 나타날 수 있으며 데이터의 무결성을 완전히 보장하기 어려움.



#### 분산 DBMS

- 투명성 (Transparency)
  - 복수의 분할된 물리적 데이터베이스를 논리적으로 단일화된 데이터베이스처럼 인식하려면 사용자들이 데이터의 물리적 배치와 특정 지역 사이트의 데이터에 대한 액세스 방법을 별도로 알 필요가 없어야 함.

- 분할 투명성 (Fragmentation Trasparency, 단편화 투명성)
  - 사용자에게 전역 스키마의 분할 상태를 알려주는 역할을 함.
  - 사용자가 입력한 전역 질의를 여러 개의 단편 질의로 변환해 주기 때문에 사용자는 전역 스키마가 어떻게 분할되어 있는지를 알 필요가 없게 됨.
- 위치 투명성 (Location Transparency)
  - 사용자나 애플리케이션에서 어떤 작업을 수행하기 위해 분산 데이터베이스상에 존재하는 어떠한 데이터의 물리적인 위치도 알 필요가 없어야 함.
  - 사용자는 분산 환경과는 무관하게 동일한 명령을 사용할 수 있어야 함.
- 중복 투명성 (Replication Transparency, 복제 투명성)
  - 중복된 데이터가 무엇인지와 저장 위치 등에 대한 정보를 사용자가 별도로 인지할 필요가 없어야 한다는 것임.
  - 사용하고 있는 데이터가 논리적으로 유일하다고 생각할 수 있는 환경을 제공해야 함.
- 장애 투명성 (Failure Transparency, 장애 고장 투명성)
  - 데이터베이스의 분산된 물리적 환경에서 특정 지역의 컴퓨터 시스템이나 네트워크에 장애가 발생해도 데이터 무결성이 보장된다는 것.
- 병행 투명성 (Concurrency Transparency)
  - 다수의 트랜잭션이 동시에 수행되는 경우에도 결과의 일관성이 유지되어야 한다는 것.



#### 데이터웨어하우스

- 개념
  - DataWarehouse
  - 기업의 정보 자산을 효율적으로 활용하기 위한 하나의 패러다임.
  - 기업의 전략적 관점에서 효율적인 의사 결정을 지원하기 위해 데이터의 시계열적 축적과 통합을 목표로 하는 기술의 구조적, 통합적 환경.
- 기존 데이터베이스와 차이점
  - 기능 : 의사결정 vs 업무데이터
  - 데이터 형태 : 주제별 요약 데이터 vs 기능별 상세 데이터
  - 연산 명령 : SELECT vs SELECT, INSERT, UPDATE, DELETE
  - 목표 : 다양한 분석 정보 제공 vs 신속한처리

- 데이터웨어하우스 활용
  - 데이터 마트(Data Mart) : 단일 주제, 예측 가능한 질의에 대해서 매우 빠르게 응답할 수 있도록 데이터를 제공하는 시스템
  - 온라인 분석 시스템 (OLAP) 온라인으로 다양한 분석 정보 제공하는 시스템
    - roll-up : 구체 -> 요약 접근
    - drill-down : 요약 -> 구체 접근
    - pivoting : 보고서 차원 변경해서 조회.
    - slicing : 다양한 형태로 조회, 비교
    - dicing : slicing보다 더 구체적으로 구분하여 조회하고 비교.

  - 데이터 마이닝(Data Mining) : 전략적 정보 발견, 정보 간의 새로운 패턴 찾아내는 지식 추출 기법. 일정한 패턴을 찾아내는 기법.




#### 하둡

- 개념
  - Hadoop

  - 빅데이터 저장과 분석을 위한 분산 컴퓨팅 솔루션.

  - 일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성함.

  - 아들이 소중히 여기던 코끼리 인형의 이름으로 이 기술을 명명함.

- 스쿱 (Sqoop)
  - 하둡과 관계형 데이터베이스 간 데이터를 전송할 수 있도록 설계된 도구.

- 타조 (Tajo)
  - 하둡 기반의 데이터웨어하우스.

- 맵리듀스 (MapReduce)
  - 대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델.
  - Google에 의해 고안된 기술. 대표적인 대용량 데이터 처리를 위한 병렬 처리 기법을 제공함.
  - 임의의 순서로 정렬된 데이터를 분산 처리하고 이를 다시 합치는 과정을 거침.
  - 맵(Map) : 데이터가 텍스트 형태로 입력되면 64KB로 분할함. 텍스트 안에 단어를 분류하여 카운트함.
  - 리듀스(Reduce) : 각 텍스트에서 정리된 맵들을 결합하여 동일한 단어를 카운트함.




## 5. 데이터 전환

### 데이터 전환(하)



### 데이터 정제(하)

