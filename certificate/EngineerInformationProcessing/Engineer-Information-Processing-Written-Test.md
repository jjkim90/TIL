1-18



# 1과목 소프트웨어 설계

## 1. 소프트웨어의 종류 및 개발 방법론

### 소프트웨어 분류 및 특성(중)

#### 시스템 소프트웨어

- 시스템의 기본 요소



#### 플랫폼

- 플랫폼의 성능 특성 분석 항목 : 가용성, 응답 시간 등등등



#### 프레임워크

- 반제품 상태의 제품을 토대로 도메인별로 필요한 서비스 컴포넌트를 사용하여 재사용성 확대와 성능을 보장 받을 수 있게 하는 개발 소프트웨어.
- 설계 관점에 개발 방식을 패턴화시키기 위한 노력의 결과물인 소프트웨어 디자인 패턴을 반제품 소프트웨어 상태로 집적화시킨 것으로 볼 수 있음.
- 프레임워크의 동작 원리를 그 제어 흐름의 일반적인 프로그램 흐름과 반대로 동작한다고 해서 IoC(Inversion of Control)이라고 설명하기도 함.



#### 컴포넌트

- CBD



#### 소프트웨어 공학



### 소프트웨어 개발 방법론(상)



#### 미들웨어

- 개념
  - 미들과 소프트웨어의 합성어
  - 운영체제와 해당 운영체제에서 실행되는 응용 프로그램 사이에서 운영체제가 제공하는 서비스 이외에 추가적인 서비스를 제공하는 소프트웨어
  - 클라이언트와 서버 간의 통신을 담당하는 소프트웨어
  - 시스템 간의 데이터 교환에 일관성을 보장함
  - 여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어
  - 소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공함
  - 여러 컴포넌트를 1대1, 1대다, 다대다 등 여러 가지 형태로 연결이 가능함.
  - 이기종 하드웨어, 소프트웨어, 네트워크, 프로토콜, PC 환경, 운영체제 환경 등에서 시스템 간의 표준화된 연결을 도와주는 소프트웨어임.
- **미들웨어의 종류**
  - DBMS(Database Management System, 데이터베이스)
    - 데이터베이스 벤더에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어
    - DB를 사용해 시스템을 구축하는 경우 보통 2-Tier 아키텍처라고 함
    - 마이크로소프트 ODBC, 볼랜드의 IDAPI, 오라클의 Glue
  - RPC(Remote Procedure Call, 원격 프로시저 호출)
    - 응용 프로그램의 프로시저를 사용해 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어.
    - 이큐브 시스템즈의 Entera, OSF의 ONC/RPC
  - MOM(Message Oriented Middleware, 메시지 지향 미들웨어)
    - 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어
    - 온라인 업무보다 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용됨.
    - IBM의 MQ, 오라클의 Message Q, JPC의 JMS
  - TP-Monitor(Transaction Processing Monitor, TP모니터)
    - 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션을 처리 및 감시하는 미들웨어
    - 사용자 수가 증가하더라도 빠른 응답속도를 유지해야 할 경우 주로 사용됨.
    - 오라클의 tuxedo, 티맥스소프트의 tmax
  - ORB(Object Request Broker, 객체 요청 브로커)
    - 객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현한 미들웨어
    - TP-Monitor의 장점인 트랜잭션 처리와 모니터링을 추가한 제품도 나오고 있음.
  - WAS(Web Application Server, 웹 어플리케이션 서버, 와스)
    - 정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위한 미들웨어
    - 클라이언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어임
    - HTTP 세션 처리를 위한 웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현이 가능함.
    - 오라클의 WebLogic, IBM의 WebSphere



#### DBMS



#### WAS

- 종류



#### 소프트웨어 개발 방법론

- 구조적 방법론
  - 프로세스 중심의 하향식 방법론
  - 복잡한 문제를 다루기 위해 분할과 정복(Divide and Conquer) 원리를 적용함.
  - 구조적 프로그래밍 표현을 위해 나씨-슈나이더만 차트를 사용한다.
- 정보공학 방법론
  - 정보 시스템 개발에 필요한 절차와 작업 기법을 체계화한 방법론
  - 개발주기를 이용해 대형 프로젝트를 수행하는 체계적인 방법론
  - 정보공학 방법론에서 데이터베이스 설계의 표현으로 사용하는 모델링 언어는 E-R 다이어그램
- 객체지향 방법론
  - 객체라는 기본 단위로 시스템을 분석 및 설계하는 방법론
- 컴포넌트 기반 방법론(CBD, Component Based Development)
  - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
  - 개발 기간 단축으로 인한 생산성 향상
  - 새로운 기능 추가가 쉬운 확장성
  - 소프트웨어 재사용이 가능
- 애자일 방법론
  - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론
- 제품 계열 방법론(Product Line Development)
  - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
- 나씨-슈나이더만(Nassi-Shneiderman) 차트
  - 논리의 기술에 중점을 둔 도형식 표현 방법
  - 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현함
  - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합함.



#### 객체지향

- 개념
  - 현실 세계의 개체(Entity)를 기계 부품처럼 하나의 객체(Object)로 만들어, 기계적인 부품들을 조립해 제품을 만들듯이 소프트웨어를 개발할 때에도 객체들을 조립해서 작성할 수 있는 기법
  - 소프트웨어의 재사용 및 확장 용이, 유지 보수 쉬움
  - 복잡한 구조를 단계적 계층적으로 표현
- 객체(Object)
  - 데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 소프트웨어 모듈
  - 데이터 = 속성, 상태, 변수, 상수, 자료구조
  - 함수 = 메소드, 서비스, 동작, 행위
  - 독립적으로 식별 가능한 이름을 가짐
  - 객체가 가질 수 있는 조건 = 상태(State)
- 클래스(Class)
  - 공통된 속성과 연산을 갖는 객체의 집합, 객체의 일반적인 타입을 의미
  - 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
  - 클래스에 속한 각각의 객체 = 인스턴스(Instance)
  - 동일한 클래스에 속한 각각의 개체들은 공통된 속성과 행위를 갖음
- 캡슐화(Encapsulation)
  - 데이터와 데이터를 처리하는 함수를 하나로 묶은 것을 의미
  - 불필요한 기능 최소화
  - 소프트웨어 개발 비용 절감
  - 개발 속도 향상
- 상속(Inheritance)
  - 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려 받는 것
  - 하위 클래스는 상위 클래스로부터 받은 속성과 연산 외에도 새로운 것을 첨가할 수 있음.
  - 소프트웨어의 재사용을 높이는 중요한 개념임
  - 다중 상속 : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속 받는 것
- 다형성(Polymorphism)
  - 하나의 메시지에 대해 여러 가지 형태의 응답이 있는 것.
  - 하나의 메시지에 대해 각 객체가 갖고 있는 고유한 방법대로 응답하는 것을 의미함
  - 하나의 클래스나 메소드가 다양한 방식으로 동작이 가능한 것을 의미함.
  - 오버로딩과 오버라이딩이 존재함.
    - 다형성의 오버라이딩 : 상속 관계에서 상위 클래스 메소드를 하위 클래스에서 재정의하는 것
    - 다형성의 오버로딩 : 하나의 클래스 내에서 같은 이름으로 여러 개 메소드 정의
- 정보은닉(Information Hiding)
  - 캡슐화에서 가장 중요한 개념으로 다른 객체에 자신의 정보를 숨기는 것을 말함.

  - 연산만을 통해 접근을 허용함.

  - 각 객체의 수정이 다른 객체에 주는 Side Effect를 최소화하는 기술임.
  
  - 필요하지 않은 정보는 접근할 수 없도록 하여 한 모듈 또는 하부 시스템이 다른 모듈의 구현에 영향을 받지 않게 설계되는 것을 의미함.
  
  - 모듈들 사이의 독립성을 유지시키는 데 도움이 됨.
  
  - 설계에서 은닉되어야 할 기본 정보로는 IP주소와 같은 물리적 코드, 상세 데이터 구조 등이 있음.
- 추상화(Abstraction)
  - 불필요한 부분을 생략, 객체 속성 중 가장 유용한 것에 중점을 두어 모델화하는 것을 말함.

  - 완전한 시스템 구축 전, 그 시스템과 유사한 모델을 만들어 여러 요인들을 테스트할 수 있음.



#### 객체지향 5 원칙 SOLID

- 단일 책임 원칙
  - SRP, Single Responsibility Principle
  - 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙.
- 개방 폐쇄의 원칙
  - OCP, Open Close Principle
  - 소프트웨의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원리.
  - 요구사항의 변경이나 추가사항이 발생하더라도 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다는 뜻.
- 리스코프 교체의 원칙
  - LSP, Liskov Substitution Principle, 리스코프 치환 원칙
  - 서브 타입은 언제나 기반 타입으로 교체될 수 있어야 한다는 원칙.
  - 부모 객체와 이를 상속한 자식 객체가 있을 때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 원칙.
  - 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙.
  - 상속되는 객체는 반드시 부모 객체를 완전히 대체해도 아무런 문제가 없도록 권고함.
  - 가급적 부모 객체의 일반 메소드를 그 의도와 다르게 오버라이딩 하지 않는 것이 중요함.
  - 특정 메소드가 상위 타입을 인자로 사용할 때, 그 타입의 하위 타입도 문제 없이 작동해야 함.
- 인터페이스 분리 원칙
  - ISP, Interface Segregation Principle
  - 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다는 원칙.
  - 구현할 객체에게 무의미한 메소드의 구현을 방지하기 위해 반드시 필요한 메소드만을 상속/구현하도록 권고함
  - 인터페이스 분리 원칙은 객체가 반드시 필요한 기능만을 가지도록 제한하는 원칙임.
  - 불필요한 기능의 상속/구현을 최대한 방지함으로써 객체의 불필요한 책임을 제거함.
  - 큰 규모의 객체는 필요에 따라 인터페이스로 잘게 나누어 확장성을 향상시킴.
- 의존관계 역전의 원칙
  - DIP, Dependency Inversion Principle
  - 객체는 저수준 모듈보다 고수준 모듈에 의존해야한다는 원칙.
  - 고수준 모듈은 인터페이스와 같은 객체의 형태나 추상적 개념을 말하고 저수준 모듈은 구현된 객체를 말함.
  - 객체는 객체보다 인터페이스에 의존해야 함.
  - 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있음.
  - 상위 계층이 하위 계층에 의존하는 전통적인 의존 관계를 역전시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있음.




#### 애자일

- 개념

  - 애자일 방법론은 소프트웨어 개발방법론의 하나로 개발과 함께 즉시 피드백을 받아서 유동적으로 개발하는 방법

- 특징

  - 프로젝트의 요구사항은 기능 중심으로 정의
  - 절차와 도구보다 개인과 소통을 중요하게 생각
  - 작업 계획을 짧게 세워 요구 변화에 유연하고 신속하게 대응
  - 소프트웨어가 잘 실행되는 데 가치를 둠
  - 고객과의 피드백을 중요하게 생각

- 애자일 선언문

  - 공정과 도구보다 개인과 상호작용
  - 계획을 따르기보다 변화에 대응하기
  - 포괄적인 문서보다 동작하는 소프트웨어
  - 계약 협상보다 고객과의 협력

- 애자일 방법론 유형

  - 익스트림 프로그래밍
    - XP(eXtreme Programming) 기법
    - 애자일 방법 중 제일 많이 알려진 기법
    - 소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법
    - 익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것.
    - 기존의 방법론에 비해 실용성(Pragmatism)을 강조한 것이라고 볼 수 있음.
    - 5가지 핵심가치 (피존의용단)
      - 용기
      - 단순성
      - 의사소통
      - 피드백
      - 존중
    - XP 개발 프로세스
      - 사용자 스토리
      - 릴리즈 계획 수립
      - 스파이크 : 간단한 프로그램. 처리할 문제 외의 다른 조건 모두 무시
      - 주기(Iteration) : 1~3주 정도의 기간으로 진행.
      - 승인 검사(인수 테스트) : 고객이 직접 수행. 오류 발견시 다음 이터레이션에 포함
      - 소규모 릴리즈
    - XP의 주요 실천 방법
      - Pair Programming(짝 프로그래밍) : 책임 분산
      - Test-Driven Development(테스트 주도 개발)
      - Whole Team(전체 팀)
      - Continuous Integration(계속적인 통합) : 모듈 하나 마무리될 때마다 지속적 통합
      - Design Improvement(Refactoring, 리팩토링) : 기능 변경 없이 재구성
      - Small Release(소규모 릴리즈)
      - 40-Hour Work
      - On Site Customer(고객 상주)
      - Collective Ownership(공통 코드 소유)
  - 스크럼(SCRUM)
    - 팀이 중심이 되어 개발의 효율성을 높인다
    - 제품 책임자(PO, Product Owner) : 개발 의뢰자, 백로그 작성
    - 스크럼 마스터(SM, Scrum Master) : 조언. 진행 사항 점검. 장애 요소 공론화. 스크럼 프로세스를 따르고 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할 등을 맡음.
    - 개발팀(DT, Development Team) : PO, SM 제외한 모든 팀원, 백로그 우선순위x
    - 스크럼 개발 프로세스
      - 제품 백로그(Product Backlog)
      - 스프린트 계획회의(Sprint Planning Meeting)
      - 스프린트(Sprint)
      - 일일 스크럼 회의(Daily Scrum Meeting)
      - 스프린트 검토 회의(Sprint Review)
      - 스프린트 회고(Sprint Retrospective)
    - 제품 백로그 : 스크럼 팀이 해결해야 하는 목록. 소프트웨어 요구사항, 아키텍처 정의 등이 포함될 수 있음.
    - 스프린트 : 실제 개발을 2~4주간 진행하는 과정. 
    - 속도(Velocity) : 한 번의 스프린트에서 한 팀이 어느 정도의 제품 백로그를 감당할 수 있는지에 대한 추정치로 볼 수 있음.
    
  - 린(LEAN)
    - 도요타의 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론
    - 린의 7가지 원칙(낭품지 확인사전)
      - 낭비제거
      - 품질 내재화
      - 지식 창출
      - 늦은 확정
      - 빠른 인도
      - 사람 존중
      - 전체 최적화



#### 테일러링

- 필요성 내부기준 외부기준



#### 보안 개발 방법론

- MS-SDL, Seven Touchpoints 등



### 프로젝트 관리 및 생명주기 모형(상)

#### 인적 자원

- 개발자팀 구성
  - 책임 프로그래머팀 : 1인 독재 체제. 다수는 1인을 위해 보조 역할 담당.
  - 민주주의식팀 : 다수 책임 체제. 개개인의 담당 분야가 독립적으로 존재함.
  - 혼합형팀 : 책임 프로그래머팀과 민주주의식팀의 장점을 결합한 팀 구성.
- 책임 프로그래머팀의 구성
  - 책임 프로그래머(Chief Programmer)
  - 보조 프로그래머(Back-up Programmer) : 책임 프로그래머를 보좌, 기술적인 자문
  - 프로그래머(Programmer) : 책임 프로그래머의 지시에 따라 원시 코드 작성, 검사, 디버깅 및 문서 작성 등을 담당함.
  - 프로그램 사서(Program Librarian) : 프로그램 리스트, 설계 문서, 검사 계획서 등의 문서를 관리함.

- 책임 프로그래머팀
  - 중앙 집중형
  - 소규모 소프트웨어 개발에 유리함
  - 이직률이 높음
  - 단기적인 소프트웨어 개발에 유리함
  - 쉬운 프로젝트에 유리함
  - 스타형 구조
- 민주주의식팀
  - 분산형
  - 대규모 소프트웨어 개발에 유리함
  - 팀원들 대다수 만족도 높음
  - 이직률 낮음
  - 장기적인 소프트웨어 개발에 유리함
  - 복잡한 프로젝트에 유리함
  - 링형 구조



#### 위험 분석

- 개념
  - Risk Analysis
  - 프로젝트 추진 과정에서 예상되는 각종 돌발 상황을 예상하고 이에 대한 적절한 대책을 수립하는 일련의 활동.
- 위험 분석 절차
  - 위험 식별(Identification) : 위험 요소가 될 사항들을 파악함.
  - 위험 분석 및 평가 : 위험의 비중과 영향력을 파악함.
  - 위험 관리 계획 : 문서화.
  - 위험 감시 및 조치 : 위험을 항상 관찰하고, 발생 시 조치함.
- 위험 감시
  - Risk Monitoring
  - 위험 요소 징후들을 계속적으로 인지하는 것.
- 위험 회피
  - Risk Avoidance
  - 예상할 수 있는 위험을 회피하는 것. 상책.



#### PERT 차트

- Project Evaluation and Review Technique
- 작업과 시간을 매핑하고 추적하는 데 사용되는 시각적 프로젝트 관리 도구.
- Gantt 차트와의 차이점
  - 갠트 차트는 막대 그래프이고 PERT 차트는 자유 형식임
  - PERT 차트는 작업 종속성을 보여주지만 갠트 차트는 그렇지 않음.
- 전체 작업의 상호 관계를 표시하는 네트워크
- 개발 경험이 없어 소요 기간 예측이 어려운 프로젝트 일정 계획에 사용함.
- 작업 예측치 계산 공식 = (비관치 + 4x기대치 + 낙관치) / 6



#### CPM

- Critical Path Method, 임계 경로 기법
- 작업을 나열하고 작업에 필요한 소요 기간을 예측하는 데 사용하는 기법.
- 노드와 간선으로 구성된 네트워크.
- 원형 노드는 작업을 의미하고 작업 이름과 소요 기간을 표시함
- 박스 노드는 이정표를 의미하며 이정표 이름과 예상 완료 시간을 표시함.
- 간선을 나타내는 화살표의 흐름에 따라 각 작업이 진행됨.
- 전 작업이 완료되어야 다음 작업을 진행할 수 있음.
- 소요 기간이 확실한 경우에 유리함.



#### Gantt Chart

- 간트 차트, 갠트 차트, 시간선 차트
- 프로젝트 작업 일정을 막대 그래프를 이용하여 표시하는 프로젝트 일정표
- 프로젝트를 이루는 소작업 별로 언제 시작되고 언제 끝나야 하는지를 한 눈에 볼 수 있도록 도와줌.
- 자원 배치 계획에 유용하게 사용됨.
- CPM 네트워크로부터 만드는 것이 가능함.
- 중간 목표 미달성 시 그 이유와 기간을 예측할 수 있게 함.
- 활동이 다른 활동과 겹치는 부분과 그 정도를 한 눈에 볼 수 있음
- 이정표 / 작업 일정 / 작업 기간 / 산출물
- 수평 막대의 길이는 각 작업의 기간을 나타냄



#### 비용 측정

- 인월 : 한 사람이 1개월 동안 작업할 양. Man Month
- LOC : Line Of Code
- 생산성 : LOC / 인월
- 개발 기간 : 인월 / 개발 비용
- 개발 비용 : 인월 x 단위 비용



#### 비용 측정 방법론의 분류

- 하향식 : 전문가 측정, 델파이식 측정 (Delphi)
- 상향식 : LOC 측정, 단계별 인월, Walston 모형, COCOMO 모형, Putnam 모형, 기능 점수 모형, 간이 기능 점수



#### LOC 측정

- 예측치 = (낙관치 + (4x기대치) + 비관치) / 6



#### COCOMO 모형

- Basic COCOMO
- 유형
  - 유기형(Organic)
    - 기관 내부에서 개발된 중소 규모의 소프트웨어.
    - 일괄 처리나 과학기술 계산용, 비즈니스 자료 처리용
    - 5만 라인 이하의 소프트웨어를 평가하는 유형
  - 준 분리형(Semi-Detached)
    - 트랜잭션 처리 시스템이나 운영체제, 데이터베이스 관리 시스템 등
    - 30만 라인 이하의 소프트웨어를 평가하는 유형
  - 내재형(Embedded)
    - 초대형 규모의 트랜잭션 시스템이나 운영체제 등의 소프트웨어를 평가하는 유형
  -  규모 커질수록 MM 증가.



#### Putnam 모형

- 대형 프로젝트에서 이용되는 기법.
- Rayleigh-Norden 곡선의 노력 분포도 곡선으로 그려짐.
- 개발 기간이 연장될수록 프로젝트 적용 인원의 노력이 감소하므로 대형 프로젝트의 노력 분포 산정에 용이함.
- 개발 기술 지수는 임의로 부여할 수 있는 값으로 최악 환경 12000 보통 환경 8000 최상 환경 5000 등



#### 형상 관리



#### 소프트웨어 생명주기

- Software Life Cycle
- 폭포수 모형(Waterfall)
  - 이전 단계를 확실히 마무리하고 다음 단계로 진행
  - 가장 오래됐고 폭넓게 사용
  - 선형 순차적 모델
  - 매뉴얼 작성 필수
  - 결과물 명확
- 프로토타입 모형(Prototype, 원형 모형)
  - 시제품을 만들어 최종 결과물 예측
  - 사용자와 시스템 사이 인터페이스에 중점
- 나선형 모형(Spiral)
  - 폭포수모형+프로토타입모형+위험분석 기능
  - 나선을 따라 돌듯이 여러 번의 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어 개발
  - 위험 관리 및 최소화가 목적
  - 누락되거나 추가된 요구사항을 첨가할 수 있음
  - 정밀하고 유지보수 과정이 필요 없음
  - 요구사항이나 아키텍처를 이해하기 어렵다거나 중심이 되는 기술에 문제가 있는 경우 적합한 모델임.
- V 모형 (V Model)
  - 요구분석1 -> 시스템 설계2 -> 상세 설계3-> 코딩 -> 단위 검사(3대응) -> 통합 검사(2대응) -> 시스템 검사(1대응) -> 인수/설치 / 1에서 모듈 검증 / 2에서 인터페이스 검증 / 3에서 요구분석 검증
  - Perry에 의해 제안되었으며 세부적인 테스트 과정으로 구성되어 신뢰도 높은 시스템을 개발하는데 효과적임.
  - 개발 작업과 검증 작업 사이의 관계를 명확히 들어내 놓은 폭포수 모델의 변형이라고 볼 수 있음.
  - 폭포수 모델이 산출물 중심이라면 V 모델은 작업과 결과의 검증에 초점을 둠.

- 애자일 모형(Agile)
  - 고객 요구사항 변화에 빠르고 유연하게 대응
  - 일정한 주기를 반복하며 진행
  - 고객과의 소통에 초점을 맞춘 모든 방법론을 통칭
  - 스프린트 또는 이터레이션이라 불리는 짧은 개발 주기 반복
  - 반복되는 주기마다 결과물에 대한 평과와 요구 수용



#### 테일러링을 위한 품질 관리

- ISO 12207 표준
  - 소프트웨어와 관련된 이해관계자들이 각자의 입장에서 수행해야 할 일을 정의하고 지속적으로 개선시키기 위한 활동임.
  - 기본 공정 : 공급, 획득, 개발, 운영, 유지보수
  - 지원 공정 : 문서화, 형상 관리, 문제 해결, 품질 보증, 검증, 확인, 합동 검토, 감리
  - 조직 공정 : 관리, 기반 구조, 개선, 교육 훈련

- ISO/IEC
  - ISO/IEC 9126 : 소프트웨어 품질 특성과 척도에 관한 표준 지침서
    - 기능성 : 적합성 / 정확성 / 상호 운용성 / 보안성 / 준수성
    - 신뢰성 : 성숙성 / 결함 허용성 / 회복성
    - 사용성 : 이해성 / 학습성 / 운용성 / 호감성
    - 효율성 : 시간 반응성 / 자원 효율성
    - 유지보수성 : 분석성 / 변경성 / 안정성 / 시험성
    - 이식성 : 적응성 / 설치성 / 상호공존성 / 대체성

  - ISO/IEC 12119 : 패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준.
  - ISO/IEC 29119 : 국제 표준.
  - ISO/IEC 25000 : SQuaRE. ISO/IEC 9126과 ISO/IEC 12119, ISO/IEC 14598 통합. 품질평가 통합모델 표준.
    - 2500n : 개요 및 품질 관리
    - 2501n : 품질 모델
    - 2502n : 품질 측정
    - 2503n : 품질 요구
    - 2504n : 품질 평가
    - 2505n : 확장 분야

- CMM 모델
  - Capability Maturity Model
  - 5가지 성숙 단계
    - 초기 단계
    - 반복 단계
    - 정의 단계
    - 관리 단계
    - 최적 단계

- SPICE 모델
  - Software Process Improvement and Capability dEtermination
  - 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준.
  - 수준 0 불안정 단계
  - 수준 1 수행 단계
  - 수준 2 관리 단계
  - 수준 3 확립 단계
  - 수준 4 예측 단계
  - 수준 5 최적화 단계

- CMMI 모델
  - CMM의 후속 모델
  - CMMI의 프로세스 영역
    - 프로세스 관리 영역
    - 프로젝트 관리 영역
    - 엔지니어링 영역
    - 지원 영역

  - CMMI 모델의 종류
    - SW-CMM
    - SECM
    - IPD-CMM
    - People-CMM
    - SA-CMM
    - SECAM




## 2. 요구사항 확인

### 현행 시스템 파악(하)

#### 현행 시스템 파악 개념

#### 저장 장치

- DAS
  - Direct Attached Storage
  - 하드 디스크와 같은 데이터 저장 장치를 호스트 버스 어댑터에 직접 연결하는 방식.
  - 저장 장치와 호스트 기기 사이에 네트워크 디바이스가 없음.
  - 서버 장비에 직접 연결하여 운용하는 방식.
  - RAID : 하드디스크를 여러 개 연결해 용량 확장. 신뢰성 보장.

- NAS
  - Network Attached Storage
  - 서버와 저장 장치를 네트워크로 연결하는 방식. 구성 설정이 간편함.
  - 별도의 운영체제를 가진 서버 한 곳에서 파일을 관리하기 때문에 서버 간에 스토리지 및 파일 공유가 용이함.

- SAN
  - Storage Area Network
  - DAS의 빠른 처리와 NAS의 스토리지 공유 장점을 합친 방식.
  - 케이블과 광채널 스위치를 통해 근거리 네트워크 환경을 구성하여 빠른 속도로 데이터를 처리할 수 있음.
  - 파이버 채널 스위치로 서버들과 스토리지들을 연결함.

- SDS
  - Software Defined Storage
  - 기존의 저장 장치(스토리지) 시스템의 한계점(데이터의 폭증, 예측 불가능한 데이터 등)을 극복하기 위한 소프트웨어 시스템.
  - 하드웨어와 소프트웨어 분리, 가상화, 클라우드 시스템을 포함하는 개념.




#### 모듈화

- 79p



### 요구사항 정의(상)

#### 요구사항 정의

- 개념
  - 어떠한 문제를 해결하기 위해 필요한 조건이나 제약사항을 요구하는 것.
- 요구사항의 유형
  - 기능적 요구사항(Functional)
    - 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항
    - 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지, 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사항
    - 시스템이 반드시 수행해야 하는 기능
    - 사용자가 시스템을 통해 제공받기를 원하는 기능
  - 비기능적 요구사항(Non-functional)
    - 시스템 장비 구성 요구사항
    - 성능 요구사항
    - 인터페이스 요구사항
    - 데이터 요구사항
    - 테스트 요구사항
    - 보안 요구사항
    - 품질 요구사항
    - 제약 사항
    - 프로젝트 관리 요구사항
    - 프로젝트 지원 요구사항


#### 요구사항 개발 프로세스

- 도출(Elicitation) -> 분석(Analysis) -> 명세(Specification) -> 확인(Validation)
- 요구사항 도출(Elicitation, 요구도출, 요구수집, 요구추출)
  - 시스템, 사용자, 그리고 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항이 어디에 있는지, 어떻게 수집할 것인지를 식별하고 이해하는 과정
  - 요구사항 도출 단계에서 개발자와 고객 사이의 관계가 만들어지고 이해관계자가 식별됨.
  - 프로젝트 계획 단계에 정의한 문제의 범위 안에 있는 사용자의 요구를 찾는 단계.
  - 주요 기법
    - 인터뷰
    - 설문
    - 브레인스토밍
    - 프로토타이핑
    - 유스케이스 : 사용자의 요구 사항을 기능 단위로 표현하는 것
- 요구사항 분석(Analysis, 요구분석)
  - 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정
  - 소프트웨어가 무엇을 해야하는가를 추적하여 요구사항 명세를 작성하는 작업.
  - 사용자의 요구를 추출하여 목표를 정하고 어떤 방식으로 해결할 것인지 결정하는 단계
  - 소프트웨어 개발의 출발점이면서 실질적인 첫 번째 단계
- 요구사항 명세(Specification, 문서화)
  - 요구사항 분석 후 승인될 수 있도록 문서화하는 것
- 요구사항 확인(Validation, 검증)
  - 개발 자원을 요구사항에 할당하기 전에 요구사항 명세서가 정확하고 완전하게 작성되었는지 검토하는 활동
  - 요구사항 문서는 이해관계자들이 검토해야 함



#### 자료 흐름도(DFD)

- Data Flow Diagram
-  4가지 구성 요소
  - 처리Process : 원
  - 자료 흐름Data Flow : 화살표
  - 자료 저장소Data Store : 평행선
  - 단말Terminal : 사각형



#### 자료 사전(DD)

- Data Dictionary
- 자료, 자료들의 집합, 자료의 흐름, 자료 저장소와 그들간의 관계, 범위, 단위들을 구체적으로 명시.
- 사용 기호
  - = : is composed of
  - \+ : and
  - () : optional
  - {} : iteration
  - [] : selection
  - | : or
  - @ : key field
  - \* : comment
  - \** : no comment



#### 요구사항 검증

- 개념
- 절차

#### 요구사항 검토

- Peer Review
  - 동료 검토
  - 2~3명 정도의 검토 담당자가 수행하는 검토.
  - 다수의 이해관계자에게 요구사항 명세서 작성자가 명세서를 설명하면 이해관계자들이 설명을 들으면서 결함을 발견하는 형태로 진행됨.

- Walk Through
  - 소프트웨어 개발 단계마다 실시하는 비정형 검토회의
  - 오류 조기 검출이 목적
  - 검토 자료를 회의 전에 배포하고 사전 검토한 후 짧은 시간 동안 회의를 진행함
  - 사용사례를 확장하여 명세하거나 설계 다이어그램, 원시코드, 테스트 케이스 등에 적용할 수 있음.
  - 복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용함.
  - 단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해 보는 것임.

- Inspection
  - 소프트웨어 개발에 참여하지 않은 다른 전문가에 의해 오류를 찾아내는 공식적 검토 방법임.
  - 프그램을 수행시켜 보는 것 대신에 읽어보고 눈으로 확인하는 방법.
  - 코드 품질 향상 기법 중 하나
  - 결함과 함께 코딩 표준 준수 여부, 효율성 등의 다른 품질 이슈를 검사하기도 함.
  - 순서는 계획 - 사전교육 - 준비 - 인스펙션 회의 - 수정 - 후속조치
  - 
- Prototype
  - 프로토타입.
  - 검증하려는 주요 기능이나 일부분을 임시적으로 개발하여 이해관계자나 고객을 대상으로 시연하면서 요구사항을 검증함.
- Re-Factoring
  - 리펙토링.
  - 오류를 제거하고 새로운 기능을 추가하는 것이 아니라 결과의 변경 없이 프로그램 소스의 구조를 재조정하는 것.
  - 리펙토링은 가독성을 높이고 유지보수를 편하게 함



#### CASE

- 개념
- 특징
- 종류 : SADT BS PSL/PSA SREM



## 3. 화면 설계

### UI 요구사항 확인(하)

#### 사용자 인터페이스(UI)

- 3가지 분야
  - 물리적 제어
  - 기능적 제어
  - 전체 구성 제어
- UI의 특징
  - SW 영역 중 변경이 가장 많이 발생
  - 사용자의 만족도에 가장 큰 영향을 미침
  - 수행 결과의 오류를 줄임
  - 작업 시간 단축, 업무에 대한 이해도 높임
  - 편리성과 가독성 높임
  - 사용자 인터페이스 설계를 위해선 소프트웨어 아키텍처를 반드시 숙지해야 함
- UI의 종류
  - CLI(Command Line Interface) : 명령과 출력이 텍스트 형태
  - GUI(Graphic User Interface) : 아이콘이나 마우스 사용하는 그래픽 형태
  - NUL(Natural User Interface) : 사용자의 말이나 행동으로 기기 조작 형태
  - OUI(Organic User Interface) : 평면 아닌 화면 조작 형태
- UI의 설계 지침
  - 사용자 중심 / 일관성 / 단순성 / 결과 예측 가능 / 가시성 / 표준화 / 접그성 / 명확성 / 오류 발생 해결 등
- UI 요소
  - Text box
  - Password box
  - Radio button
  - Checkbox button
  - Select box
  - Textarea box
  - submit button
  - reset button
  - Toggle button



### UI 설계(하)

#### UI 설계

- UI 설계 원칙
  - 직관성 : 누구나 쉽게 이해, 사용
  - 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 함
  - 학습성 : 누구나 쉽게 배워야
  - 유연성 : 사용자 요구사항 최대한 수용하고 실수 최소화
- UI 개발 필수 기능
  - 사용자 명령을 받아들일 프롬프트 기능
  - 사용자 명령 입력의 검증 기능
  - 에러 처리와 에러 메시지 처리 기능
  - 도움말 지원 기능



#### 오류 메시지, 경고

- 메시지는 이해하기 쉬워야 함
- 오류로부터 회복을 위한 구체적인 설명이 제공되어야 함
- 오류로 인해 발생될 수 있는 부정적인 내용을 적극적으로 사용자들에게 알려야 함.



#### UI 설계 도구

- 와이어프레임 (Wireframe)
  - 기획 단계의 초기에 제작하는 것.
  - 페이지에 대한 개략적인 레이아웃이나 UI 요소 등에 대한 뼈대를 설계하는 단계
  - 개발자나 디자이너 등이 레이아웃을 협의하거나 현재 진행 상태 등을 공유하기 위해 사용함.
  - 각 페이지의 영역 구분, 콘텐츠, 텍스트 배치 등을 화면 단위로 설계함.
  - 와이어프레임 툴 : 손그림, 파워포인트, 키노트, 스케치, 일러스트, 포토샵 등
- 목업 (Mockup)
  - 디자인, 사용 방법 설명, 평가 등을 위해 와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형
  - 시각적으로만 구성 요소를 배치하는 것으로 일반적으로 실제로 구현되지는 않음.
  - 목업 툴 : 파워 목업, 발사믹 목업 등
- 스토리보드 (Story Board)
  - 와이어프레임 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가한 문서.
  - 디자이너와 개발자가 최종적으로 참고하는 작업 지침서.
  - 정책, 프로세스, 콘텐츠 구성, 와이어프레임, 기능 정의 등 서비스 구축을 위한 모든 정보가 들어 있음.
  - 스토리보드 구성
    - 상단이나 우측 : 제목, 작성자
    - 좌측 : UI 화면
    - 우측 : 디스크립션(Description)
  - 스토리보드 툴 : 파워포인트, 키노트, 스케치, Axure 등
- 프로토타입 (Prototype)
  - 와이어프레임이나 스토리보드 등에 인터랙션을 적용함으로써 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형
  - 사용성 테스트나 작업자 간 서비스 이해를 위해 작성하는 샘플
  - 작성 방법에 따라 페이퍼 프로토타입과 디지털 프로토타입으로 나뉨.
  - 프로토타입 툴 : HTML/CSS, Axure, Flinto, 네이버 프로토나우, 카카오 오븐 등
- 유스케이스 (Usecase)
  - 사용자 측면에서의 요구사항.
  - 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술함.
  - 자연어로 작성된 사용자의 요구사항을 구조적으로 표현한 것.
  - 일반적으로 다이어그램 형식으로 묘사함.
  - 유스케이스 다이어그램이 완성되면 각각의 유스케이스에 대해 유스케이스 명세서 작성함.



## 4. 애플리케이션 설계

### 공통 모듈(중)

#### 모듈

- 개념
  - SW구조를 이루며, 다른 것들과 구별할 수 있는 독립적인 기능을 갖는 단위
  - 서로 모여 하나의 완전한 프로그램으로 만들어질 수 있음.
  - 추상화되어 재사용 및 공유 가능한 수준으로 만들어진 기능 단위를 모듈로 규정함.
  - 다른 것들과 구별될 수 있는 독립적인 기능을 가진 단위(Unit)
  - 독립적인 컴파일이 가능하며 유일한 이름을 가져야 함.
- 모듈의 기본 요소
  - 입력 요소, 파라미터
  - 출력 요소 RETURN
  - 기능 요소
  - 기관 요소 : 모듈 내부의 알고리즘을 의미
  - 내부 자료 요소 : 모듈 내부의 기억 장소를 의미

- 모듈의 공유도(Fan-in)와 제어도(Fan-out)
  - 공유도는 얼마나 많은 모듈이 주어진 모듈을 호출하는가를 나타내는 척도. 상위 모듈의 수. 공통 모듈화 측면에서 잘 설계되어 있으나, 단일 실패점이 발생할 수 있으므로 중점 관리 및 더 많은 테스트를 통한 검증이 필요함.
  - 제어도는 주어진 모듈이 호출하는 모듈의 개수, 하위 모듈의 수. 불필요한 기능을 호출하고 있지 않은지 추가 검토를 진행하고 업무 로직을 단순화시킬 수 있는지에 대해서도 검토.

- 모듈의 개수 및 비용 간 상관도
  - x축은 모듈 개수, y축은 노력 비용
  - 모듈 별 개발 비용 : 모듈의 개수가 많을수록 노력 비용 감소(반비례)
  - 모듈 통합 비용 : 모듈의 개수가 많을수록 모듈 통합 비용 증가(비례)
  - 전체 SW 개발 비용 : 모듈 통합 비용과 모듈 개발 비용이 교차되는 부분의 영역이 최소 노력 비용이 됨(두 그래프가 교차되는 지점)



#### 공통 모듈

- 원칙

- 공통 모듈의 재사용 범위 따른 분류



#### 재공학

- 소프트웨어 재사용의 2가지 기본 기술 : 생성 중심, 합성 중심 120p

- 소프트웨어 재사용의 이점



### 모듈의 평가(상)

#### 모듈의 평가 기준

- 결합도
  - 결합도 낮음(높은 품질)
  - 결합도 높음(낮은 품질)

- 응집도
  - 응집도 낮음(낮은 품질)
  - 응집도 높음(높은 품질)




#### 모듈 결합도

- 자료 결합도 -> 스탬프 결합도 -> 제어 결합도 -> 외부 결합도 -> 공통 결합도 -> 내용 결합도

- 자료 결합도
  - Data Coupling
  - 두 모듈 간의 인터페이스가 자료 요소만으로 구성된 결합.
  - Call By Value 형태로 가장 좋은 결합 형태.
  - 실인수(호출 시 넘겨주는 변수)와 가인수(호출 시 넘겨받는 변수)의 번지가 독립적으로 사용됨.

- 스탬프 결합도
  - Stamp Coupling, 구조 결합
  - 두 모듈 간에 같은 레코드를 부분적으로 공유함.
  - 모듈 간 독립성은 유지되지만 같은 작업 대상인 자료로 묶인 결합을 말함.
  - 모듈 간의 인터페이스로 객체나 구조적인 데이터(배열, 레코드 등)가 전달되는 경우임.
  - 모듈 input 자료가 결합되어 있음.

- 제어 결합도
  - Control Coupling
  - 처리하는 방법을 제어 요소로 전달되는 경우임.

- 외부 결합도
  - Extern Coupling
  - 외부 변수에 의해 영향을 받는 두 모듈이 결합된 관계
  - 모듈 외부에서 데이터, 프로토콜, 인터페이스 등을 공유할 때 발생하는 경우.

- 공통 결합도
  - Common Coupling
  - 모듈이 다른 모듈의 내부 자료를 참조하는 형태의 결합된 관계
  - 모듈 외부에 선언되어 있는 전역 변수를 참조하고 상호 작용하는 경우임.
  - Call by Reference 형태임.
  - 실인수와 가인수의 번지가 같음.

- 내용 결합도
  - 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 형태의 결합된 관계
  - 가장 좋지 않은 결합으로 내용 결합도를 갖는 모듈들은 다시 설계해야 함.
  - 모듈 내부에 있는 변수나 기능을 다른 모듈에서 직접적으로 사용하는 경우임.




#### 모듈 응집도

- 우연적 응집도 -> 논리적 응집도 -> 시간적 응집도 -> 절차적 응집도 -> 통신적 응집도 -> 순차적 응집도 -> 기능적 응집도

- 우연적 응집도
  - Coincidental Cohesion
  - 모듈 내부의 루틴들이 뚜렷한 관계없이 묶인 경우로 응집도가 가장 약하고 가장 좋지 않은 모듈 설계임.
  - 서로 간에 어떠한 의미 있는 연관 관계도 지니지 않은 기능 요소로 구성되는 경우임.

- 논리적 응집도
  - Logical Cohesion
  - 모듈 내부의 루틴들이 같은 범주에 속하는 기능끼리 묶인 모듈
  - 오류 처리 모듈, 출력 처리 모듈, 파일 모듈


- 시간적 응집도
  - Temporal Cohesion
  - 모듈 내부의 루틴들이 시간적으로 수행 시기가 같은 기능끼리 묶인 모듈.
  - 여러 파일 OPEN 모듈, CLOSE 모듈, 변수 초기화 모듈
- 절차적 응집도
  - Procedure Cohesion
  - 모듈 내부의 루틴들이 수행 시기가 순위가 있는 기능끼리 묶인 모듈
  - 모듈 안의 구성 요소들이 순차적으로 수행할 경우
  - 재시작 모듈(총계 출력 -> 화면 지움 -> 메뉴 표시)
- 통신적 응집도
  - Communication Cohesion, 정보적, 교환적
  - 모듈 내부의 루틴들 중 작업 대상이 같은 기능끼리 묶인 모듈.
  - 일반적으로 하나의 파일을 대상으로 갱신 작업을 하는 루틴끼리 묶인 모듈이 여기에 속함.
  - 같은 입력 자료를 사용하여 A를 계산한 후 B를 계산하는 경우.

- 순차적 응집도
  - Sequential Cohesion
  - 모듈 내부의 루틴들이 이전의 명령어로부터 나온 출력 결과를 그 다음 명령어의 입력 자료로 사용하는 경우의 응집도
  - 행렬 입력 후 그 행렬의 역행렬을 구해서 이를 출력하는 경우임
- 기능적 응집도
  - Functional Cohesion, 함수적 응집도
  - 모듈 내부가 하나의 단일 기능으로 존재하는 경우로 프로그램 언어에서 지원받는 라이브러리가 모두 이에 속함.
  - 구조도 최하위 모듈(트리 구조의 단노드)에서 많이 발견됨.
  - 응집도 중 가장 강하고 좋은 모듈이라고 할 수 있음



### 설계 모델링(하)

#### N-S 도표

- NS Chart, Nassi Shneiderman Chart, 상자 도표
- 논리의 기술에 중점을 둔 도형을 이용한 표현 방법
- 순차, 선택, 반복으로 표현함
- 임의의 제어 이동이 어려움 (goto 구조가 어려움)
- 조건이 복합되어 있는 곳의 처리를 명확히 식별하기에 적합함. (if문 여러 개일 때)



#### HIPO 도표

- Hierarchical Input Process Output
- 인풋 - 프로세스 - 아웃풋으로 이루어진 모듈을 계층적으로 나타낸 도표.
- 가시적 도표 Visual Table of Contents : 시스템의 전체적인 기능과 흐름을 보여주는 Tree 형태의 구조도.
- 총체적 도표 Overview Diagram : 프로그램을 구성하는 기능을 기술한 것으로 입력-처리-출력에 대한 전반적인 정보를 제공하는 도표
- 세부적 도표 Detail Diagram : 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표. 총체적 도표와 모양은 같지만 내용이 좀 더 복잡하게 들어감.
- 세 가지가 모두 모여야만 HIPO 도표라고 하는 것은 아님. 가시적 도표를 이야기하는 경우가 많음.



### 소프트웨어 아키텍처(하)

#### 시스템 아키텍처

- 개념
  - HW와 SW를 포함하는 시스템 전체에 대한 논리적인 기능 체계.
  - 시스템이 어떻게 작동하는지를 설명하는 프레임워크.
- 시스템 아키텍처 설계
  - 소프트웨어 아키텍처 설계에 제약을 하는 상위 설계임.
  - 시스템 아키텍처 설계 -> 소프트웨어 아키텍처 설계 -> 소프트웨어 상세 설계



#### 소프트웨어 아키텍처

- 개념
  - 소프트웨어의 골격이 되는 기본 구조로 소프트웨어 전체에 대한 큰 밑그림임.
  - 소프트웨어 구성 요소의 유기적인 결합 형태와 전체 구조임.
  - 소프트웨어를 이루고 잇는 구성 요소인 모듈이나 컴포넌트를 다룸.
- 소프트웨어 아키텍처 설계 과정
  - 설계 목표 설정
  - 시스템 타입 결정
  - 아키텍처 패턴 적용 (스타일 적용 및 커스터마이즈)
  - 서브시스템 구체화 (서브시스템의 기능, 인터페이스 동작 작성)
  - 아키텍처 설계 검토
- 아키텍처 드라이버
  - 요구사항 중 아키텍처에 영향을 주는 요구사항을 아키텍처 드라이버라고 함.
  - 아키텍처 드라이버를 입력물로 태스크에 의해 아키텍처 설계가 진행되고 그 결과물로 아키텍처 문서와 아키텍처 가이드라인이 출력됨.
- 소프트웨어 아키텍처의 시스템 품질 속성
  - 가용성(Availability) : 인가된 사용자가 원하는 시간이나 장소에서 필요 정보에 접근할 수 있고 사용할 수 있도록 보장하는 성질.
  - 변경 용이성(Modifiability) : 기능 추가, 변경에 부담 없이 변경할 수 있어야 함.
  - 성능(Performance) : 처리량, 응답 시간, 사용 가능도 등을 측정함.
  - 보안성(Security) : 권한 없는 사용자 데이터나 프로그램 사용할 수 없도록 함.
  - 사용 편의성(Usability) : 쉽게 사용할 수 있는가정도 
  - 시험 용이성(Testability) : 쉽게 검사할 수 있는가의 정도



#### 아키텍처 계층

- 소프트웨어 아키텍처 모델의 하나

- 표현 계층(Presentation Layer) : UI 계층
- 프로세스 계층(Process Layer) : 서비스 계층
- 비즈니스 논리 계층(Business Logic Layer) : 도메인 계층
- 데이터 접근 계층(Data Access Layer) : 영속 계층(Persistence Layer)



#### 마스터 슬레이브 패턴

- Master Slave Pattern
- 소프트웨어 아키텍처 모델의 하나
- 마스터가 슬레이브에게 작업을 분산하면 슬레이브가 처리한 결과로 최종 결과를 계산하는 패턴.
- 마스터 데이터베이스는 원본 데이터를 가지고 있고, 슬레이브는 복제본을 동기화하는 형태로 활용할 수 있음.
- 일반적으로 실시간 시스템에서 사용됨.
- 실시간 시스템에 적용할 수 있지만 마스터와 슬레이브 간에 Latency 문제가 발생할 수 있음.
- 마스터 프로세스는 일반적으로 연산, 통신, 조정을 책임짐.
- 마스터 프로세스는 슬레이브 프로세스들을 제어할 수 있음.
- 슬레이브 프로세스들은 마스터가 요청한 작업만을 수행함.



#### 파이프 필터 패턴

- Pipe filter Pattern
- 소프트웨어 아키텍처 모델의 하나
- 데이터 스트림을 생성하고 처리하는 시스템에서 사용됨.
- 서브 시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복함.
- 처리 과정은 필터(Filter)를 통해 이루어지며, 처리되는 데이터 스트림은 파이프(Pipe)를 통해 흐름.
- 파이프는 버퍼링 또는 동기화 목적으로 사용될 수 있음.
- 컴파일러, 연속한 필터들은 어휘 분석, 파싱 등에 활용됨.



### 코드 설계(하)

#### 코드의 기능

- 3대 기능, 추가 기능

#### 순차 코드

#### 표의 숫자 코드

#### 코드 오류의 종류

- 사본오류 전위오류 이중오류 등등



### 파일 설계(하)



## 5. 인터페이스 설계

### 인터페이스 요구사항(하)

#### 인터페이스 송신 시스템



### 인터페이스 설계(하)



# 2과목 소프트웨어 개발

## 1. 데이터 입출력 구현

### 자료 표현 단위와 진법(하)

### 고정 소수점과 부동 소수점(하)

### 자료 구조(중)

#### 자료 구조 분류

- 단순 구조(Simple)
  - 프로그래밍 언어에서 제공하는 기본 데이터 타입
  - int, float, double, char 등

- 선형 구조(Linear)
  - 데이터들 사이의 선후 관계가 일대일인 구조.
  - 선형 구조는 크게 순차 구조와 연결 구조로 나눌 수 있음
  - 순차 구조는 삽입과 제거가 자주 일어날 때 처리 시간이 가장 많이 소요되는 자료 구조이며, 연결 구조인 연결 리스트는 데이터의 삽입, 삭제가 가장 용이한 방법임.
  - 스택, 큐, 데크, 선형 리스트, 연결 리스트가 있음.

- 비선형 구조(Non-Linear)
  - 데이터들 사이의 선후 관계가 계층 또는 그물 형태를 가지는 구조.
  - 데이터를 저장시키는 데 있어 데이터와 대응되는 다른 데이터가 여러 개 존재하는 경우의 관계성을 1:N, N:M 구조로 저장시키는 형태 구조를 비선형 구조라고 함.
  - 트리 구조, 그래프 구조가 있음.

- 파일 구조(File)
  - 보조 기억 장치에 데이터값이 실제로 기록되는 자료 구조임.
  - 순차 파일, 색인 파일 등이 있음.




#### 스택

- Stack
- 스택의 구조
  - 데이터를 저장하는 기억 장치가 한쪽으로만 입구와 출구가 있음.
  - 데이터가 저장될 때 입력된 데이터의 위치를 스택 포인터(TOP)가 가리키고 있음.
  - 스택 포인터는 데이터가 입력(PUSH)될 때마다 1씩 증가하며 스택 크기보다 큰 값을 갖게 되면 데이터를 더 이상 기억할 수 없는 오버플로우(Overflow) 상태가 됨.
  - 스택에 데이터가 출력(POP)될 때에는 1씩 감소하며 저장된 데이터가 없을 경우에는 스택 포인터는 0값을 기억하게 됨.

- 스택의 특징
  - 데이터의 삽입과 삭제가 같은 쪽에서 이루어지는 구조임.
  - 스택의 자료 삽입 : TOP 포인트가 스택의 크기(N) 이상이면 오버플로우, 아니면 TOP포인트 1 증가하고 스택에 TOP 포인트가 가리키는 곳에 자료 삽입함.
  - 스택의 자료 삭제 : TOP 포인트가 비어 있으면 언더플로우, 아니면 스택에 TOP 포인트가 가리키는 곳에 자료 삭제하고 TOP 포인트 1 감소.
  - 나중에 입력된 데이터가 먼저 출력하는 메모리 사용 방법.
  - 후입선출(LIFO) 구조.
  - 데이터와 데이터 사이는 1:1 관계임.
  - 함수 호출하여 복귀할 때 / 깊이 우선 탐색 / 재귀적 함수를 호출 사용할 때 / 인터럽트 수행 시 현재 수행 중인 프로세스의 복귀 주소를 저장할 때 / 수식을 우선적으로 연산하기 위한 방법으로 / 0-주소 명령어 방법에서 사용됨.




#### 큐

- Queue
- 큐의 구조
  - 한쪽 방향으로 데이터가 삽입되고 반대 방향으로 데이터가 삭제되는 데이터 구조임.
  - 큐는 가장 먼저 삽입된 데이터가 가장 먼저 삭제되므로 선입선출(FIFO) 구조라고도 함.
  - 데이터를 저장하는 기억 장치가 양쪽으로 있으며 한쪽으로는 입구, 다른 한쪽으로는 출구가 있음.
  - 데이터가 저장될 때 입력된 데이터의 위치를 삽입 포인터(Rear)가 가리키고 있고, 출력된 데이터는 삭제 포인터(Front)가 가리키고 있음.
  - 삽입(Rear), 삭제(Front)

- 큐의 구조
  - 프린터 스풀(Spool) / 입출력 버퍼(Buffer) / 은행 번호표 서비스 / 각종 스케줄링 / 동영상 버퍼 / 인터넷에서 동영상을 실시간으로 받아보는 스트리밍 서비스
  - 키보드를 입력하면 바로 CPU로 전달되지 않고 큐 구조의 버퍼에 대기했다가 CPU에 전달됨.




#### 트리

- Tree

- 트리의 구조
  - 그래프의 특수한 형태로 노드(Node)와 선분(Branch)으로 되어 있고, 정점 사이에 사이클(Cycle)이 형성되어 있지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조임.
  - 트리 구조는 나무를 뒤집은 모습으로 계층 구조를 표현하기에 적합함.
  - 트리는 프로그램의 에러를 찾아내는 구문 분석에서 필요한 기본 이론을 제공함.

- 트리의 용어
  - 노드(Node) : 원
  - 간선(Edge), 링크(Link) : 노드와 연결된 선
  - 루트(Root) 노드 : 뿌리가 되는 노드
  - 단노드 단말노드(Terminal) : 자식이 없는 노드
  - 간노드(Nonterminal) : 자식이 있는 노드
  - 노드의 차수(Degree) : 자식 노드의 개수
  - 노드의 레벨(Level) : 특정 깊이를 가지는 노드 집합. 루트 노드는 1레벨.
  - 노드의 크기(Size) : 자신을 포함한 자식 노드의 수. 차수+1.
  - 노드의 깊이(Depth) : 루트에서 거쳐 간 간선의 수. 레벨-1.
  - 노드의 높이(Height) : 루트에서 가장 깊은 노드. 레벨.
  - 부노드 부모노드(Parent) : 부모 노드
  - 자노드 자식노드(Children) : 자식 노드
  - 제노드(Sibling) : 형제 노드
  - 숲(Forest) : 루트를 제외한 나머지 부분
  - 서브 트리(Sub Tree) : 부분 집합 트리




#### 이진 트리 순회

- 중위 순회 방법(In-order) : 좌근우
- 전위 순회 방법(Pre-order) : 근좌우
- 후위 순회 방법(Post-order) : 좌우근
- 순회 방법 3가지



#### 폴리쉬 표기법

- 중위식(Infix) : 수학식처럼 연산자가 중간에 있는 것.
- 전위식(Prefix) : 연산자가 앞에 있는 것.
- 후위식(Postfix) : 연산자가 뒤에 있는 것.
- 전위식은 CPU 명령어 형식, 후위식은 프로그램의 문법 에러를 확인하는데 주로 사용됨.



### 검색(하)

#### 검색의 시간 복잡도

- 일반적인 알고리즘에서 시간 복잡도는 O(log_2n)이 가장 빠르고 O(n!)이 가장 느림.
- 입력 자료의 개수가 무한히 크다고 가정하는 경우
  - O(long_2n) : 로그형. 이진 검색, 이진 트리 검색에 해당함
  - O(n) : 선형. 수열이나 순차 검색에 해당함
  - O(nlog_2n) : 로그 선형. 퀵 정렬, 힙 정렬, 합병 정렬 시 비교 횟수에 해당함.
  - O(n^2) : 2차형. 선택 정렬, 버블 정렬 시 자료 비교 횟수에 해당함.
  - O(n^3) : 3차형. 행렬 곱셈 알고리즘에 해당함.



#### 이진 검색

- 이분 검색. Binary Search.
- 이진 검색을 하려면 검색 대상의 전체 자료의 수를 알고 있어야 하고, 검색 대상의 자료들이 정렬되어 있어야 함.
- 시간 복잡도는 O(log_2n) 로그형.



#### 이진 트리 검색

- Binary Tree Search
- 검색 대상의 자료를 이진 트리로 변형한 뒤 검색하는 방법.
- 처음 자료는 근노드가 되고 두 번째 자료는 근노드와 비교해서 작으면 왼쪽으로 크면 오른쪽에 연결함.
- 시간 복잡도는 O(log_2n) 로그형.



#### AVL 트리 검색

- Adelson, Velskii, Landis. 균형 이진 트리
- 이진 트리 검색의 효율을 높이기 위해 구성함.
- 트리의 좌우 균형이 맞지 않으면 균형이 맞도록 균형 인수를 +-1이나 0으로 맞추는 트리.
- 노드가 삽입되거나 삭제될 때 트리의 모양이 변함.
- 균형을 측정할 때는 절대적 개수가 아니라 레벨을 비교함.



#### 해싱 검색

- 자료를 찾는 특별한 규칙으로 검색 대상의 자료를 저장하여 자료를 찾음.
- 특별한 규칙이란 해싱 함수를 말하며 해싱 함수의 결과로 자료들의 저장 위치(주소)가 결정됨.
- 해싱 함수로 계산된 저장 위치가 중복될 때에는 충돌이라고 하며 충돌에 대비한 조치가 필요함.
- 서로 다른 탐색키가 해싱 함수를 통해 동일한 해시 주소로 사상될 수 있음.
- 충돌이 발생하지 않는 해싱 함수를 사용한다면 시간 복잡도는 O(1)임.
- 해싱 함수 종류
  - 제산법(Division) : 레코드 키 값을 소수나 전체 자료수로 나누어 그 나머지 값으로 저장할 위치를 정하는 방법.
  - 폴딩법(Folding) : 레코드 키 값을 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방법.
  - 제곱법(Square) : 레코드 키 값을 제곱한 결과 값의 일부를 선택하여 저장할 위치를 정하는 방법.
  - 중간 제곱법(Mid-Square) : 레코드 키 값을 제곱하고, 이 값의 중간 부분을 취하여 홈 주소로 취하는 해싱 방법.
  - 숫자 분석법(Digit Analysis) : 레코드 키 값을 이루는 숫자들의 분포를 파악해서 분포가 고른 부분을 선택해 저장할 위치를 정하는 방법.
  - 기수 변환법(Radix Transformation) : 레코드 키 값을 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수는 절단하고, 이를 다시 버킷의 개수 범위에 맞게 조정하는 방법.
  - 의사 무작위법(Pseudo-random) : 난수를 발생시킨 후 그 난수를 이용하여 저장할 홈 주소의 위치를 정하는 방법.
- 해싱 함수
  - 홈 주소 : 해싱 함수에 의해서 결정됨. 해싱 주소라고도 함.
  - 버킷 : 자료가 저장될 공간.
  - 슬롯 : 하나의 버킷은 여러 개의 슬롯을 가질 수 있음. 충돌 대비
    - 동거자(Synonym, 동의어) : 서로 다른 키 값이지만 해싱 함수에 의해 같은 버킷에 저장되는 키 값들.
  - 충돌 : 해싱 함수에 의해 서로 다른 키가 같은 홈 주소를 갖게 되는 현상.
  - 오버플로우 : 버킷에 할당된 슬롯 수보다 많이 발생하게 되면 버킷에 더 이상 항목을 저장할 수 없는 경우에 발생함.
  - 프로빙(Probing, 조사법) : 충돌이 발생하여 더 이상 같은 홈 주소를 갖는 버킷을 사용할 수 없을 때 사용하지 않는 다른 버킷을 찾아 저장하는 방법으로 1차 조사법, 2차 조사법 등이 있음.
  - 체인법(Chaining) : 해싱에서 오버플로우 발생 시 이를 해결하기 위한 방법으로 연결 리스트를 사용하며 버킷의 크기에 제한을 두지 않는 기법.

#### 그래프 탐색

- 그래프의 모든 정점을 방문하는 것을 그래프 탐색이라고 함.
- 깊이 우선 탐색(DFS : Depth First Search)
  - 스택(Stack) 구조를 이용하여 운용함.
  - 시작 노드(A)에서 인접한 노드 중 하나를 알파벳순으로 스택에 삽입함.
- 너비 우선 탐색(BFS : Breadth First Search)
  - 큐(Queue) 구조를 이용하여 운용함.
  - 시작 노드(A)에서 인접한 노드를 모두 알파벳순으로 큐에 삽입함.



### 정렬(하)

#### 정렬의 시간 복잡도

|      정렬의 분류       |    평균    |    최상    |    최하    |
| :--------------------: | :--------: | :--------: | :--------: |
|    삽입(Insertion)     |   O(n^2)   |    O(n)    |   O(n^2)   |
|      버블(Bubble)      |   O(n^2)   |   O(n^2)   |   O(n^2)   |
|    선택(Selection)     |   O(n^2)   |   O(n^2)   |   O(n^2)   |
|       쉘(Shell)        |  O(n^1.5)  |    O(n)    |  O(n^1.5)  |
|       퀵(Quick)        | O(nlog_2n) | O(nlog_2n) |   O(n^2)   |
|        힙(Heap)        | O(nlog_2n) | O(nlog_2n) | O(nlog_2n) |
| 이진 병합(2-Way Merge) | O(nlog_2n) | O(nlog_2n) | O(nlog_2n) |
|      버킷(Bucket)      |   O(dn)    |   O(dn)    |   O(dn)    |



#### 선택 정렬

- 첫 번째 위치에 가장 작은 값을 위치시킴.

- Pass 2에서는 첫 번째 위치를 제외한 자리 중 첫 번째 위치에 가장 작은 값을 위치시킴.

  

#### 버블 정렬

- Pass 1 : 1,2 비교 2,3 비교 3,4비교 끝까지
- Pass 2 : 제일 뒤를 제외하고 다시 처음부터 Pass 1 진행함.



#### 삽입 정렬

- Pass 1 : 2를 키값으로 설정하여 1,2 비교
- Pass 2 : 3을 키값으로 설정하여 1,2,3 비교
- 정렬할 자료 일부가 정렬되어 있는 경우에 유리한 방법.



#### 힙 정렬

- 임의의 자료에서 최솟값 또는 최댓값을 구할 경우 가장 적합한 정렬 방법
- 자료를 순서적으로 완전 이진 트리 형태로 만들어 정렬하는 방법.
- 공식을 통해 시작하는 하위 노드 그룹을 결정하고 오름차순 정렬인 경우 자노드가 부노드보다 크면 자료를 교환함. 공식은 k = n/2



#### 퀵 정렬

- 레코드의 키를 기준으로 작은 값은 왼쪽에 큰 값은 오른쪽 서브 파일로 분해하여 정렬하는 방식.
- 정렬 방식 중에서는 가장 빠른 방식이며, 프로그램에서 재귀적 함수를 이용하기 때문에 스택을 필요로 함.



### 모듈 구현(하)



## 2. 통합 구현

### 통합 구현 도구(하)

#### 형상 관리 도구

- 개념
  - Software Configuration Management. 소프트웨어 구성 관리.
  - 소프트웨어의 변경 사항을 체계적으로 추적하고 통제하는 것.
  - 형상 관리는 일반적인 단순 버전 관리 기반의 소프트웨어 운용을 좀 더 포괄적인 학술 분야의 형태로 넓히는 근간을 의미함.
  - 프로그램 소스 코드나 문서의 버전 관리, 이력 관리, 추적, 변경 사항을 체계적으로 관리할 수 있는 기능을 제공하는 프로그램.
  - 동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구.
- 형상 관리 도구 기능
  - check-out : 저장소에서 개발자 PC로 가져오는 기능. PULL. 최신 버전 아닌 원하는 버전으로 체크아웃하는 것도 가능함.
  - check-in : 개발자가 수정한 소스를 저장소로 업로드하는 기능. PUSH.
  - commit : 개발자가 소스를 형상 관리 도구 저장소에 업로드한 후 최종적으로 업데이트가 되었을 때 형상 관리 서버에 반영되도록 하는 기능. COMMIT.
  - update : 변경 사항이 있는 경우 서버 형상을 로컬 형상으로 가져오는 기능. FETCH.
  - import : 아무것도 들어있지 않은 저장소에 맨 처음 소스를 넣는 기능.
  - export : 버전 관리 파일을 뺀 순수한 소스 파일을 받아올 수 있음. 오픈소스 프로젝트의 경우 소스를 압축하여 릴리즈할 때 사용함.
- 형상 관리 도구 종류
  - RCS (Revision Control System)
    - 파일, 잠금 방식으로 소스 파일 수정은 한 명으로 제한하여 버전 관리.
    - 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식.
  - CVS (Concurrent Versions System)
    - 가장 오랫동안 사용한 형상 관리 도구임.
    - 중앙 집중형 서버 저장소에 클라이언트가 접속해서 버전 관리를 실행함.
    - Diff를 통해 이전 버전과 현재 버전을 비교함.
    - 파일 단위로 변경 사항을 관리함.
    - 직관적이고 비교적 단순한 명령 구조.
    - Commit 실패 시 Rollback하지 못함.
  - SVN(Subversion)
    - CVS의 단점을 보완한 방식이며 CVS 사용자도 쉽게 도입하여 사용 가능.
    - Auto Commit을 사용하기 때문에 실패 시 Rollback할 수 있음.
  - Git
    - 공개 소프트웨어 커뮤니티 중심으로 사용하는 개발자가 많이 확대되고 있는 도구.
    - 분산형 저장소 사용함.
    - 중앙 집중 방식으로도 사용할 수 있는 융통성이 있음.
    - Commit은 로컬 저장소에 이루어지고, PUSH 동작에 원격 저장소에 반영됨.
  - Perforce(P4D)
    - 2014 출시. Merge 속도가 빠름.
    - 여러 가지 편리함.
    - CLI가 상대적으로 약함.



### 연계 통합 구현(하)



### 연계 메커니즘(하)



### 연계 장애 및 오류 처리 구현(하)



### 연계 모듈 구현 환경 구성 및 개발(하)



## 3. 제품 소프트웨어 패키징

### 제품 소프트웨어 패키징(하)

#### 제품 소프트웨어 패키징

- 특징

#### 제품 소프트웨어 패키징 도구

- 개념
  - 제품 소프트웨어의 배포를 위한 패키징 시 디지털 콘텐츠의 지적 재산권을 보호하고 관리하는 기능을 제공함
  - 안전한 유통과 배포를 보장하는 도구이자 솔루션임.
  - 불법 복제로부터 디지털 콘텐츠의 지적 재산권을 보호해 주는 사용 권한 제어 기술, 패키징 기술, 라이선스 관리, 권한 통제 기술 등을 포함함.

- 패키징 도구 활용시 고려사항
  - 반드시 암호화 및 보안 기능을 고려한다
  - 다양한 다른 기종 연동을 고려한다
  - 사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려한다
  - 제품 소프트웨어의 종류에 적합한 암호화 알고리즘을 적용한다
  - 지속적인 배포를 고려한다



### 제품 소프트웨어 매뉴얼(하)

#### 제품 소프트웨어 설치 매뉴얼

- 기본 사항

#### 제품 소프트웨어 사용자 매뉴얼

- 준비절차 / 작성절차



### 제품 소프트웨어 버전 관리(하)

#### 제품 소프트웨어 버전 관리

- 버전 관리 항목 : 가져오기 , 체크아웃, 체크인, 커밋, 리파지토리 등

#### 제품 소프트웨어 버전 관리 도구

- 도구 유형 : 공유폴더방식 클라서버방식 분산저장소방식 등

#### 빌드 자동화 도구

- 개념
  - Build, IC(지속적인 통합)
  - 제품 소프트웨어의 실행 파일을 자동으로 만들어 주는 도구.
  - 실행 파일을 한 번 만들어 놓고, 새롭게 추가되는 프로그램이 있으면 자동으로 실행 파일에 추가함.

- 종류
  - Make : 유닉스 계열.
  - Ant : 아파치 앤트. 자바 언어에서 사용.
  - Maven : 아파치 메이븐. 자바 언어에서 사용.
  - Gradle : 오픈소스. 그루비 기반. 안드로이드 환경 적합함. 태스트 단위로 실행함.
  - Jenkins : 오픈소스. 자바기반. 아파치톰캣과 같은 웹 서버 기반.




## 4. 애플리케이션 테스트 관리

### 애플리케이션 테스트(하)

#### 테스트 관련 용어

- 디버그 Debug 디버깅 Debugging
  - 컴퓨터 프로그램의 논리적인 오류를 찾아내는 과정.
  - 문법적 오류는 실행 자체가 안되지만 논리적 오류는 실행은 되지만 실행 결과가 안맞는 오류를 말함.

- 디버거 Debugger
  - 디버그를 돕는 도구
  - 디버깅 하려는 코드에 중단점을 지정하여 프로그램 실행을 중단하고, 코드를 단계적으로 실행하여 저장된 값을 확인할 수 있도록 지원함.

- 워크스루 Walk-Through
  - 소프트웨어 생명주기의 각 단계마다 산출된 명세서를 가지고 오류를 찾아내는 비정형 검토회의
  - 검토회의 전에 요구사항 명세서를 미리 배포하여 사전에 검토한 후 짧은 검토회의를 통해 오류를 조기에 검출하는 데 목적을 두는 요구사항 검토 방법임.

- 정형 기술 검토 FTR
  - 체계적이며 규칙적으로 오류를 찾는 작업.
  - 소프트웨어 개발이 완성된 상태에서 검사함.
  - 개발자와 검토자 모두 많은 준비를 해야 함
  - 검토 지침
    - 제품 검토의 집중성 : 오류 검출에 초점을 두고 해결책은 나중으로 미룸.
    - 사전 준비성
    - 의제의 제한성
    - 안건 고수성
    - 논쟁 반박의 제한성
    - 문제 공개성
    - 참가 인원의 제한성
    - 문서성




#### 테스트의 원칙

- 테스트는 결함이 존재함을 밝히는 것.
- 완벽한 테스트는 불가능함.
- 테스트는 계획 단계부터 해야 함.
- 결함 집중 Defect Clustering 고려해야 함.
- 살충제 패러독스 Pesticide Paradox 고려해야 함. 테스트 케이스 주기적 업데이트.
- 오류 부재의 궤변 Absence of Errors Fallacy 고려해야 함. 사용자 만족이 제일 중요함.
- 테스트는 정황에 의존적임. 정황과 비즈니스 도메인에 따라 테스트를 다르게 수행해야 함.



### 단위 테스트(중)

#### 단위 테스트

- 개념
  - 원시 프로그램의 모듈이나(함수, 프로시저, 독립적인 루틴 등) 컴포넌트 대상으로 화이트박스 테스트를 실시하는 방법.
  - 모듈의 기능 수행 여부를 판정하고 내부에 존재하는 논리적인 오류를 검출함.
  - 개별 모듈을 시험하는 것으로 예정된 기능이 제대로 수행하는지를 점검하는 검사임.
  - 구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트한다.
  - 모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다.
  - 테스트할 모듈을 호출하는 모듈도 있고, 테스트할 모듈이 호출하는 모듈도 있다.


- 종류
  - 정적 테스트
    - 애플리케이션 실행하지 않고, 명세서나 소스코드 대상으로 분석하는 테스트
    - 코드 워크쓰루
    - 인스펙션
  - 동적 테스트
    - 애플리케이션을 직접 실행해 오류를 찾음, 소프트웨어 모든 단계에서 테스트
      - 블랙박스 테스트(기능 테스트)
      - 화이트박스 테스트



#### 화이트박스 테스트

- 개념
  - 단위 테스트의 가장 기본적인 방법.
  - 소스 코드의 모든 문장을 한 번 이상 수행함으로써 진행됨.
  - 소스 코드를 보면서 테스트 케이스를 다양화하게 만들어 테스트함.
  - 모듈의 내부 구현을 자세히 테스트함.
- 화이트박스 테스트의 종류
  - 기초 경로 테스트(Base Path Testing, Structure Testing, 구조 테스트)
  - 루프 테스트(Loop Testing)
  - 데이터 흐름 테스트(Data Flow Testing, 논리흐름도)
  - 조건 커버리지(Condition Coverage, 검증 기준)
- 화이트박스 테스트를 통해 찾을 수 있는 오류
  - 세부적 오류
  - 논리 구조상의 오류
  - 반복문 오류
  - 수행 경로 오류
  - 알고리즘 오류에 따른 원치 않는 결과
  - 무한 루프
  - 틀린 계산 수식에 의한 잘못된 결과



#### 블랙박스 테스트

- 개념
  - 프로그램의 외부 사용자 요구사항 명세를 보면서 테스트함.
  - 프로그램의 동작만으로 오류를 찾아 내는 방법.
  - 주로 구현된 기능을 테스트함.
  - 모듈의 내부 구현보다는 입력과 출력에 의해 기능을 테스트함.
  - 프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정함.
- 블랙박스 테스트의 종류
  - 동등 분할 (균등 분할, 동치 분할) (Equivalence Partitioning)
  - 경계값 분석(Boundary Value Analysis)
  - 오류 예측(Error Forecast)
  - 원인 결과 그래프(Cause and Effect Graphing)
  - 비교 테스트(Compare Testing)
- 블랙박스 테스트를 통해 찾을 수 있는 오류
  - 인터페이스 오류
  - 자료 구조상의 오류
  - 성능 오류
  - 시작과 종결상의 오류
  - 부정확하거나 빠진 오류
  - 비정상적인 자료를 입력해도 오류 처리를 수행하지 않는 경우
  - 정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우
  - 경계값을 입력할 경우 요구된 출력 결과가 나오지 않는 경우



#### 기초 경로 테스트

- Basic Path Testing, Structure Testing(구조 테스트)이라고 함.
- 흐름 도표 작성 -> 복잡도 계산 -> 복잡도 1당 테스트 1번 시행 -> 복잡도 판정
- 복잡도 계산 방법 : 받는 화살표의 수 + 1
- 복잡도 판정 : 5이하 단순, 6~10 구조적&안정적, 20이상 매우 복잡, 50이상 비구조적&불안정 -> 다시 작성
- 모든 프로그램의 복잡도를 6~10 이하로 만들기 위해서는 모듈화가 필수적임.



#### 경계값 테스트

- 개념
  - 범위의 한계 부분을 집중적으로 검사.
  - 해당 경계값 주변에 값들을 입력하여 정상적으로 출력되는지 확인하여 오류가 발생하면 소스 코드를 수정함.



#### 단위 테스트 도구

- 단위 디버깅의 자동화 도구임.

- JUnit : 자바 프로그래밍 언어용.
- CppUnit : C++ 프로그래밍 언어용.
- HttpUnit : 웹 브라우저 없이 웹 사이트 테스트를 수행하는 데 사용되는 오픈 소스 소프트웨어 테스트 프레임워크.
- Unitest : Python 기반의 단위 모듈 테스트, 디버깅 도구.
- NUnit : .NET 플랫폼 기반의 단위 테스트 프레임워크.



### 통합 테스트(하)

#### 통합 테스트

- 개념
  - 통합 테스트는 소프트웨어 각 모듈 간의 인터페이스 관련 오류 및 결함을 찾아내기 위한 체계적인 테스트 기법을 말함.
  - 단위 테스트가 끝난 모듈 또는 컴포넌트 단위의 프로그램이 설계 단계에서 제시한 동일한 구조와 기능으로 구현된 것인지를 확인하는 것.
  - 설계 명세서와 통합된 프로그램과의 차이를 확인하는 것.
- 수행 방법
  - 점증적인 방식 : 드라이버나 스터브를 사용하여 테스트함. 일부 먼저 테스트
    - 상향식 통합 테스트
    - 하향식 통합 테스트
  - 빅뱅 방식(비 점증적) : 한꺼번에. 드라이버나 스터브 없이 실제 모듈로. 단시간 테스트에 적당하고 작은 시스템에 유리함. 장애 위치 파악 어려우며 모든 모듈이 개발되어야 테스트가 가능함.



#### 하향식 통합 테스트

- 메인 제어 모듈로부터 아래 방향으로 제어의 경로를 따라 이동하면서 하향식으로 통합하면서 테스트함.
- 하위 모듈과 최하위 모듈은 깊이우선 또는 너비우선 방식으로 통합됨.(선택 가능)
- 아직 작성되지 않은 하위 제어 모듈 및 모든 하위 컴포넌트를 대신하여 더미 모듈인 스터브(Stub)를 개발함. 테스트 완료되면 스터브는 실제 모듈 또는 컴포넌트로 대치함.
- 주요 제어 모듈은 작성된 프로그램을 사용하고, 주요 제어 모듈의 종속 모듈들은 스텁으로 대체함.
- 테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음.
- 인터페이스가 이미 정의되어 있어 통합이 간단함.
- 레벨이 낮은 데이터 구조의 세부 사항은 설계초기 단계에서 필요함.



#### 상향식 통합 테스트

- 최하위 레벨의 모듈 또는 컴포넌트로부터 위쪽 방향으로 제어의 경로를 따라 이동하면서 테스트함.
- 최하위 레벨의 모듈 또는 컴포넌트들이 하위 모듈의 기능을 수행하는 클러스터(Cluster)로 결합함.
- 상위 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈은 드라이버(Driver)를 작성함.
- 필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 드라이버(Driver)라고 함.
- 통합된 클러스터 단위를 테스트함.
- 테스트할 때 프로그램 전체를 실행할 수 없음 (하향식은 가능)
- 테스트할 때 독립적인 구조를 갖지 못함 (클러스터로 묶어야 함. 하향식은 독립적인 구조 가능)
- Stub 필요없음. Driver 필요함
- 하위 모듈 그룹(클러스터) 형성이 필요함
- 중요 모듈을 우선 테스트할 때 적당함
- 최하위 수준에서 각각의 모듈을 설계하고 이러한 모듈이 완성되면 이들을 결합하여 검사함.
- 인터페이스가 이미 성립되어 있지 않으면 드라이버를 추가해야 함. 쉽지 않음.



### 시스템 테스트(중)

#### V-모델

- 확인
- 검증
- 부하 테스트

#### 인수 테스트

- 수행 방법 : 알파 / 베타

#### 테스트 자동화 도구

- 정적 분석 도구
- 성능 테스트 도구

#### 테스트 장치 구성

- 드라이버 / 스터브 / 수트 등

#### 테스트 케이스

- 개념
  - 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서를 의미함.
  - 테스트 케이스의 가장 핵심적인 사항은 테스트 항목의 도출임.
  - 프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는 것이 중요함.
- 테스트 케이스 작성 순서
  1. 테스트 계획 검토 및 자료 확보
  2. 위험 평가 및 우선순위 결정
  3. 테스트 요구사항 정의
  4. 테스트 구조 설계 및 테스트 방법 결정
  5. 테스트 케이스 정의
  6. 테스트 케이스 타당성 확인 및 유지 보수



#### 테스트 오라클

- 개념
  - 테스트 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법 및 활동을 말함.
  - 테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준임.
  - 결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 계산하거나 확인함.
- 특징
  - 제한된 검증
  - 수학적 기법
  - 자동화 가능
- 테스트 오라클의 유형
  - 참 오라클(True Oracle) : 모든 입력값에 대해 기대하는 결과를 생성함으로써 발생한 오류를 모두 검출할 수 있는 오라클.
  - 샘플링 오라클(Sampling Oracle) : 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클.
  - 추정 오라클(Heuristic Oracle) : 샘플링 오라클을 개선한 오라클. 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 추정으로 처리하는 오라클.
  - 일관성 테스트 오라클(Consistent Test Oracle) : 소프트웨어 변경이 있을 때, 수행 전과 수행 후의 결과 값이 동일한지 확인하는 오라클.
- 테스트 오라클의 적용 방안
  - 참 오라클은 주로 항공기, 임베디드, 발전소 소프트웨어 등 작은 실수만으로도 치명적인 결과를 초래하는 업무에 적용함.
  - 샘플링/추정 오라클은 일반, 업무용, 게임, 오락 등의 일반적인 업무에 적용함.



### 테스트 결과 분석(하)

#### 테스트 결과 분석

- 결함 종류 : 오류, 결함, 실패 등



### 연계 테스트 및 검증(하)



### 테스트 커버리지(하)



### 성능 분석 및 품질 평가(중)

#### 테스트 관리 지원 도구

- 소스코드 품질 분석 도구(정적 분석 지원 도구) 종류

#### 품질 목표 항목

- 정확성 / 신뢰성 / 효율성 등등등

#### 외계인 코드



## 5. 인터페이스 구현

### 인터페이스 설계 명세(중)

#### EAI

- 개념
  - Enterprise Application Integration 기업 응용 프로그램 통합
  - 기업서 운영되는 서로 다른 플랫폼 밑 응용 프로그램 간의 정보 전달, 연계, 통합을 가능하게 해주는 솔루션.
- EAI 구축 유형
  - Point-to-Point : 중간에 미들웨어 없음. 솔루션 구매 없이 통합 가능. 변경이나 재사용 어려움
  - Hub & Spoke : 단일 접점 허브 시스템 통해 데이터 전송. 중앙 집중적 방식. 허브 장애 시 전체 시스템 영향 받음.
  - Message Bus : 미들웨어를 통한 통합. 뛰어난 확장성과 대용량 처리 가능
  - Hybrid : 그룹내 허브, 그룹간 메시지버스 방식 사용. 표준 통합 기술.



#### ESB

- 개념
  - Enterprise Service Bus
  - 응용 프로그램보다는 서비스 중심으로 통합을 지향하는 기술.
  - 웹 서비스 중심으로 ESB 통해 서로 다른 앱을 유연하게 통합하는 핵심 플랫폼 기술.
  - 표준화가 미비하고 특정 벤더에 종속되어 있음. 특정 업체의 제품만을 사용하므로 부담될 수 있음.



#### 인터페이스 구현 도구

- 데이터 통신
  - 응용 프로그램 영역에서 인터페이스 형식에 맞춘 데이터 포맷을 인터페이스 대상으로 전송하고 이를 수신측에서 파싱하여 해석하는 방식.
  - JSON 및 XML 형식의 데이터 포맷을 사용하여 인터페이스를 구현함.
- JSON
  - JavaScript Object Notation, 제이슨
  - 속성과 값으로 이루어진 데이터 객체를 전달하기 위해 사용하는 개방형 표준 포맷.
  - AJAX에서 많이 사용되고 XML을 대체하는 주요 데이터 포맷임.
  - 언어 독립형 포맷으로 다양한 프로그래밍 언어에서 사용됨.
- XML
  - eXtensible Markup Language
  - 다 특수한 목적을 갖는 마크업 언어를 만드는 데 사용하도록 권장하는 다목적 마크업 언어.
  - 마크업 언어는 소프트웨어에서 문장이나 표의 배치 방법, 글자 크기와 모양 등에 대한 정보를 나타내는 언어를 말함.
  - 다른 종류의 시스템끼리 데이터를 쉽게 주고받을 수 있음.
- YAML
  - 스페이스 공백을 통해 데이터의 layer을 나누고, 정리하는 정보양식.
  - 띄어쓰기와 '-' 대시를 통해 정보가 나뉘어지고, 사람이 보기 쉽게 정리한 정보 양식임.
- AJAX
  - Asynchronous Javascript And XML
  - 함께 사용하는 기술의 묶음을 지칭하는 용어
  - 자바스크립트를 사용한 비동기 통신 기술로 클라이언트와 서버 간에 XML 데이터를 주고 받는 기술임.
  - 웹 페이지 화면에서 페이지 이동 없이 고속으로 화면 전환 가능.

### 인터페이스 구현 검증(하)

#### 인터페이스 구현 검증 도구

- xUnit / STAF / FitNEsse 등등등



# 3과목 데이터베이스 구축

## 1. 데이터베이스의 개요

### 데이터베이스의 개요(하)

#### 데이터베이스 설계

- 데이터베이스 설계 순서
  1. 요구 조건 분석 : 요구 조건 명세서 작성
  2. 개념적 설계 : DBMS에 독립적인 개념 스키마, 트랜잭션 모델링, E-R 모델
  3. 논리적 설계 : 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계
  4. 물리적 설계 : 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
  5. 구현 : 목표 DBMS의 DDL로 데이터베이스 생성, 트랜잭션 생성
- 3단계 데이터베이스 구조 3level Database Architecture
  - 스키마 3단계와 동일함.
  - 미국의 표준화 기관인 ANSI/SPARC에서는 데이터베이스의 복잡한 내부 구조를 감추고 일반 사용자가 데이터베이스에 쉽게 이해하고 이용할 수 있도록 3단계 데이터베이스 구조를 제안하였음.




#### 스키마

- 개념
  - 데이터베이스를 구성하는 자료 개체, 이들의 성질, 이들 간의 관계, 자료의 조작 및 이들 자료 값들이 갖는 제약조건에 관한 정의를 총칭해서 스키마라고 함.
  - 데이터베이스의 논리적 구조 기술임
  - DBMS 특성과 구현 환경을 감안한 데이터 구조.
  - 직관적으로 하나의 데이터베이스로 이해 가능함.
  - 스키마는 데이터 사전에 저장되며 메타데이터라고도 함.
  
- 스키마 3단계
  - 외부 스키마(External Schema)
    - 서브스키마, 사용자 뷰
    - 응용 프로그래머나 사용자 그룹 입장에서의 데이터베이스 모습으로 조직의 일부분을 정의한 것.
    - 공용의 의미보다는 어느 개인이나 특정 응용에 한정된 논리적 데이터 구조이며, 데이터베이스의 개별 사용자나 응용 프로그래머가 접근하는 데이터베이스임.
    - 각 개인의 입장에서 필요로 하는 구조를 정의함
    - 하나의 데이터베이스 시스템에는 여러 개의 외부스키마가 존재할 수 있음.
    
  - 개념 스키마(Conceptual Schema)
    - 전체적인 뷰
    - 모든 응용 프로그램과 사용자들이 필요로 하는 데이터베이스 전체를 정의함.
    - 데이터베이스를 이용하는 사용자들의 관점을 통합하여 데이터베이스를 조직 전체의 관점에서 이해하고 표현함.
    - 전체적인 논리적 구조
    - 트랜잭션 모델링을 하는 단계임.
    - 데이터베이스에서 데이터에 대한 접근 권한, 보안 정책, 무결성 규칙들이 포함됨.
    
  - 내부 스키마(Internal Schema)
    - 물리적 저장 장치의 입장에서 본 데이터베이스 구조
    
    - 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄.
    
    - 데이터베이스를 디스크나 테이프 같은 저장 장치의 관점에서 이해하고 표현함
    
      
  
- 인터페이스
  - 응용 인터페이스 : 외부 스키마와 개념 스키마 간의 사상 관계를 나타내는 인터페이스.
  - 저장 인터페이스 : 개념 스키마와 내부 스키마 간의 사상 관계를 나타내는 인터페이스



### 데이터베이스 관리 시스템(DBMS)(하)

### 데이터베이스의 종류(상)

#### RDBMS

- 기본 용어

  - 속성(Attribute)
    - 개체 정보의 특성에 대한 이름임.
    - 프로그래밍 언어에서 기억 장소 이름인 변수명에 해당됨.
    - 파일 시스템에서 레코드의 필드에 해당됨.
    - 각 속성은 유일한 값(원자 값)을 갖고 있어야 함.
    - 한 릴레이션을 구성하는 애트리뷰트 사이에는 순서가 없음.
  - 도메인(Domain)
    - 한 속성에 입력되는 실제 원자 값들의 범위임.
    - 하나의 속성이 가질 수 있는 원자 값들의 집합임.
    - 수험번호가 2byte 정수형으로 선언했다면 수험번호의 도메인은 -32768~32767 사이의 값임.

  - 튜플(Tuple)
    - 속성들에 실제 입력된 값들의 집합임.
    - 하나의 행, 하나의 줄에 해당되는 값임.
    - 파일 시스템에서 레코드에 해당됨.

  - 릴레이션(Relation)
    - 데이터 간에 나타내는 표 자체임.
    - 한 개 이상의 속성들 집합으로 이루어져 있음.
    - 릴레이션 스키마와 릴레이션 어커런스가 결합된 명칭임.
  - 릴레이션 스키마(Relation Schema)
    - 하나 이상의 속성을 합쳐 정의하는 이름임.
    - 릴레이션의 이름과 릴레이션에 포함된 모든 속성의 이름으로 정의하는 릴레이션의 논리적 구조.
    - 릴레이션이름(속성이름1, 속성이름2, ..., 속성이름n)과 같은 형태로 쉽게 표현함.
  - 릴레이션 어커런스(Relation Occurrence)
    - 실제 입력된 튜플들의 집합으로 시간에 따라 변화됨.
    - 릴레이션 인스턴스와 사실상 동의어임.
  - 차수(Degree)
    - 하나의 릴레이션에서 정의된 속성의 개수.
    - 레코드의 필드 수.
  - 카디널리티(Cardinality, 기수)
    - 하나의 릴레이션에 형성된 튜플의 개수 혹은 기수라고 함.
    - 레코드의 수를 의미함.
  - 널(NULL)
    - 속성 값이 비어 있는 상태임.
    - 숫자 0과 공백 문자는 속성 값에 입력된 데이터로 NULL은 아님.
    - 한 바이트가 모두 0인 상태임. 00000000. 초기화 상태. 무 상태. 공백, 숫자 0은 바이트로 00100000, 00110000 임. 
    - 메모리에 가장 많이 분포되어 있는 값.
- 릴레이션의 특징

  - 튜플의 유일성 : 입력되는 모든 튜플은 중복된 튜플이 존재하지 않음.
  - 튜플의 무순서 : 입력되는 모든 튜플은 순서적으로 입력되지 않고 상황에 따라 순서 없이 입력됨.
  - 속성의 원자성 : 속성으로 입력되는 도메인 값은 분해될 수 없는 형태로 입력되어야 함.
  - 속성의 무순서 : 속성 간의 논리적인 순서는 의미가 없음.
  - 속성 이름의 유일성 : 속성 이름은 중복되어서는 안 됨.
- RDBMS의 키

  - 후보키(Candidate Key)
    - 하나의 릴레이션에 있는 모든 튜플에 대해 유일성과 최소성을 모두 만족시켜야 함.
    - 유일성은 모든 튜플을 유일하게 구분할 수 있는 성질이고, 최소성은 가장 작은 개수의 속성으로 구성될 수 있는가를 나타내는 성질임.
    - 슈퍼키 중에서 최소성을 만족하는 것이 후보키가 됨.
    - 후보키를 선정할 때는 현재의 릴레이션 내용만 보고 유일성과 최소성을 판단해서는 안 됨.
    
  - 기본키(Primary Key)
    - 후보키들 중 데이터베이스의 설계자에 의해서 튜플 구별을 위해 선택된 한 개의 키임.
    - 기본키로 선택된 속성은 NULL 값을 가질 수 없음.
    - 값이 자주 변경될 수 있는 속성이 포함된 후보키는 기본키로 부적합함.
    - 단순한 후보키를 기본키로 선택하는 것이 좋음.
    
  - 대체키(Alternate Key, 보조키)
    - 후보키 중에서 기본키를 제외한 모든 키는 대체키가 됨.
  - 외래키(Foreign Key)
    - 어떤 릴레이션에 소속된 속성 또는 속성 집합이 다른 릴레이션의 기본키가 되는 키.

    - 릴레이션들 사이의 관계를 올바르게 표현하기 위해 필요함.

  - 슈퍼키(Super Key)
    - 유일성의 특성을 만족하는 속성 또는 속성들의 집합.
    - 유일성은 키가 갖추어야 하는 기본 특성으로, 하나의 릴레이션에서 키로 지정된 속성 값은 튜플마다 달라야 한다는 의미임.
    - 키 값이 같은 튜플은 존재할 수 없음.
    - 튜플을 식별하기 위한 두 개 이상의 속성들의 집합으로 이루어진 키로 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못함.

- 무결성의 제약조건 (Integrity Constraint)

  - 도메인 무결성
    - 하나의 속성에 입력되는 값에 대한 정확성을 유지하는 성질.
  - 개체 무결성
    - 기본키를 설정하여 그 기본키에 대해 NULL 값을 허용하지 않으므로 하나의 릴레이션으로 삽입되거나 변경되는 튜플들에 대해 정확한 값을 유지하는 성질로 하나의 릴레이션에 있는 튜플은 중복된 튜플이 있어서는 안 된다는 성질임.
  - 참조 무결성
    - 외래키는 참조할 수 없는 값을 가질 수 없다는 규칙.
    - 외래키는 자신이 참조하는 릴레이션에 기본키 값으로 존재하는 값, 즉 참조 가능한 값만 가져야 함.



## 2. 논리 데이터베이스 설계

### 개체와 속성(하)

### 정보 모델링과 데이터 모델링(하)

#### 데이터 모델링

- 개념
  - 현실 세계의 데이터 구조를 컴퓨터 세계의 데이터 구조로 변환하는 개념적인 도구임.
  - 현실 세계의 요구사항을 컴퓨터 세계의 데이터 구조로 변환하기 위하여 개체와 관계를 중심으로 분석, 설계하여 점차적으로 자료 구조를 만들어 가는 과정.

- 데이터 모델링의 구성 요소
  - 논리적 구조(Logical Structure) : 논리적으로 표현된 데이터 구조임.
  - 연산(Operation) : 데이터 구조에서 삽입, 삭제, 변경하는 방법임. 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업.
  - 제약조건(Constraint) : 데이터 구조에서 허용할 수 있는 관계를 명세화함.



#### 데이터 모델링 절차

- 데이터 관점의 데이터 모델링 절차
  - 개념 데이터 모델링
  - 논리 데이터 모델링
  - 물리 데이터 모델링
  - 데이터베이스 구축



#### 논리(Logical) 데이터 모델링

- 개념
- 3단계
- 특성

#### 물리(Physical) 데이터 모델링



#### 데이터베이스 구축

- 설계된 데이터를 저장하기 위해 DBMS를 이용하여 데이터베이스를 생성하는 것.
- 구축 시 고려사항
  - 무결성 : 수정, 삽입, 삭제 후에도 데이터에 문제가 없어야 함.
  - 일관성 : DB 저장된 값의 질의응답 시에 모호성이 없어야 함.
  - 회복성 : 장애 발생 시에 원래 상태로 복구할 수 있어야 함.
  - 보안성 : 불법적인 데이터 접근이나 변경에 보호될 수 있어야 함.
  - 효율성 : 응답 시간의 단축, 저장 공간의 절약, 생산성 등을 고려해야 함.
  - 확장성 : 시스템에 영향을 받지 않는 범위 내에서 새로운 데이터 추가하거나 확대 가능해야 함.



### E-R 다이어그램(ERD) 작성(하)

#### E-R 다이어그램(ERD) 표기법

- 개체 Entity
  - 저장할 만한 가치가 있는 중요 데이터를 가지고 있는 사람이나 사물 등을 가리킴.
  - 개념이나 사건처럼 개념적으로만 존재하는 것도 개체가 될 수 있음.
  - 이름, 하나 이상의 속성을 가지고 있음.
  - 개체 타입은 정의, 개체 인스턴스는 정의를 통해 실체화된 개체를 말함.
  - 사각형으로 표현. 사각형 안에 개체의 이름을 표기함.

- 속성 Attribute
  - 개체가 가지고 있는 고유한 특성.
  - 일반적으로 의미 있는 데이터의 가장 작은 논리적 단위로 인식됨.
  - 타원으로 표현됨. 타원 안에 속성의 이름을 표기함.
  - 단일 값 속성 : 특정 개체를 구성하는 속성 값 하나.
  - 다중 값 속성 : 특정 개체를 구성하는 속성 값 여러 개. -> 이중 타원으로 표현됨.
  - 복합 속성 : 의미를 분해할 수 있어 값이 여러 개의 의미를 포함하는 속성 -> -E 이런 식으로 표시함.
  - 유도 속성 : 값이 별도로 저장되는 것이 아니라 기존의 다른 속성 값에서 유도되어 결정되는 속성. derived attribute. 유도 속성 계산에 사용되는 속성은 저장 속성(stored attribute)라고 함. 점선 타원으로 표현됨.
  - 키 속성 : 개체 집합에 존재하는 각 개체 인스턴스들을 식별하는 데 사용되는 속성. 간단히 키라고도 함. 밑줄을 그어 표현함.

- 관계 Relationship
  - 개체와 개체가 맺고 있는 의미 있는 연관성.
  - 개체 집합들 사이의 대응 관계, 매핑을 의미함.
  - 관계도 개체처럼 속성을 가질 수 있음. 관계를 맺음으로써 발생하는 중요한 데이터들이 관계의 속성이 됨.
  - 마름모로 표현함. 관계의 속성은 타원으로 표현함.
  - 매핑 카디널리티를 기준으로 일대일, 일대다, 다대다 세 가지 유형으로 분류할 수 있음.
  - 개체 B가 개체 A에 종속되면 A를 강한 개체, B를 약한 개체라고 함. 약한 개체는 이중 사각형으로 표현함. 약한 개체가 강한 개체와 맺는 관계는 이중 마름모로 표현함.

- 연결
  - 선으로 표현함.
  - 필수적 참여 관계 : 이중선으로 표현함.




#### 확장 ERD

- 슈퍼 타입과 서브 타입
- 특수화
- 일반화
- 상속
- 집단화
- 분류화



### 관계 스키마와 함수적 종속(상)

#### 관계 스키마

- 개념
- 설계 원칙
- 이상 현상 (Anomaly)
- - 개념
    - 릴레이션에 대한 데이터의 삽입, 수정, 삭제 연산을 수행할 때 부작용이 발생하는 것.
    - 관련이 없는 데이터, 즉 관련 없는 속성들을 하나의 릴레이션에 모아두면 이상 현상 발생함.
  - 이상 현상 종류
    - 삽입 이상 : 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
    - 갱신 이상 : 중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제
    - 삭제 이상 : 튜플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제



#### 함수 종속

- 개념
  - 릴레이션 내의 모든 튜플에서 X 값에 대한 Y값이 항상 하나면 "X가 Y를 함수적으로 결정한다" 또는 "Y가 X에 함수적으로 종속되어 있다"라고 함.
  - 함수 종속 관계는 X -> Y 로 표현하고 X를 결정자, Y를 종속자라고 함.
  - 함수 종속 관계를 판단할 때 유의할 점은, 현재 시점에 릴레이션에 포함된 속성 값만으로 판단하면 안 된다는 것임. 릴레이션 속성 값은 계속 변할 수 있기 때문에 속성 자체가 가지고 있는 특성과 의미를 기반으로 판단해야 함.
  - 기본키나 후보키가 아니더라도 속성 Y 값을 유일하게 결정하는 속성 X는 함수 종속 관계에서 모두 결정자가 될 수 있음.
  - 결정자와 종속자가 같거나, 결정자가 종속자를 포함하는 것처럼 당연한 함수 종속 관계는 고려하지 않음.
- 부분 함수 종속(PFD: Partial Functional Dependency)
  - {A, B} -> C 이면서 동시에 A->C 인 경우 C가 {A,B} 속성 집합에 부분 함수 종속되었다고 함.
  - X->Y 함수 종속에서 속성 집합 Y가 속성 집합 X의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미함.
  - 부분 함수 종속이 되려면 결정자가 여러 개의 속성들로 구성되어 있어야 함. {A, B} -> C

- 완전 함수 종속(FFD: Full Functional Dependency)
  - {A, B} -> C 에서 {A,B} 의 일부분이 아닌 속성 집합 전체에만 종속되는 경우 C가 {A, B} 속성 집합에 완전 함수 종속되었다고 함.
  - 릴레이션에서 속성 집합 Y가 속성 집합 X에 함수적으로 종속되어 있지만, 속성 집합 X 전체에 종속된 것이지 일부분에 종속된 것이 아님을 의미함.
- 함수 종속일 때의 추론 규식
  - 반사 규칙 : B가 A에 포함됨. ==  A -> B
  - 첨가 규칙 : A -> B 이면 AC -> BC 임.
  - 이행 규칙 : A -> B 이고 B -> C 이면 A -> C
  - 분해 규칙 : A -> BC 이면 A -> B 또는 A -> C
  - 결합 규칙 : A -> B 이고 A -> C 이면 A -> BC




#### 관계 대수

- 개념
  - Relational Algebra
  - 관계 데이터 연산 중 하나.
  - 원하는 결과를 얻기 위해 데이터의 처리 과정을 순서대로 기술, 절차적 언어
  - 관계 대수와 관계 해석은 상용화된 관계 데이터베이스에서는 실제로 사용되지 않는 개념적 언어임. 관계 대수나 관계 해석으로 기술할 수 있는 모든 질의를 새로 제안된 데이터 언어로 기술할 수 있으면 관계적으로 완전(relationally complete)하다고 하고, 이를 통해 해당 언어가 어느 정도 검증됐다고 판단함. 보통 상용화된 관계 데이터베이스에서 사용하는 데이터 언어들도 관계적으로 완전하다고 판단된 것들임.
  - 관계 대수는 연산자들의 집합임. 관계 대수는 릴레이션을 연산함. 피연산자가 릴레이션.
- 일반 집합 연산자
  - 합병 가능 union compatible : 차수+도메인 같음
    - 두 릴레이션의 차수가 같아야 함. (속성 개수가 같음)
    - 두 릴레이션에서 서로 대응되는 속성의 도메인이 같아야 함. (도메인 같으면 속성 이름 달라도 됨)

  - 합집합 : 일반 집합의 합집합
  - 교집합 : 일반 집합의 교집합
  - 차집합 (-)
    - 교집합을 제외한 부분을 반환함.

  - 카티션 프로덕트 (*)
    - 곱집합(Cartesian Product)
    - 릴레이션 R의 각 튜플과 릴레이션 S의 각 튜플을 모두 연결하여 만든 새로운 튜플을 반환함.
    - 두 릴레이션이 합병은 불가능한 경우에도 카티션 프로덕트 연산은 가능함.
    - 카티션 프로덕트 연산을 한 후 얻게 되는 결과 릴레이션의 차수는 피연산자인 릴레이션 R과 S의 차수를 더한 것과 같음.
    - 카티션 프로덕트 연산을 한 후 얻게 되는 결과 릴레이션의 카디널리티는 릴레이션 R과 S의 카디널리티를 곱한 것과 같음.
    - 카티션 프로덕트 연산은 교환법칙과 결합법칙이 성립함.

- 순수 관계 연산자
  - 셀렉트
    - 시그마 기호 사용함.
    - 릴레이션 R에서 조건을 만족하는 튜플들을 반환.
    - 결과 릴레이션은 주어진 릴레이션을 수평으로 절단한 모양이 됨. 해당 릴레이션에서 수평적 부분집합을 생성한 것과 같음. horizontal subset
    - 하나의 릴레이션을 대상으로 수행함.
    - 조건식은 비교 연산자를 이용해 구성함.
    - 조건식을 비교식 또는 프레디킷(predicate)이라고도 함.
    - 릴레이션 where 조건식

  - 프로젝트
    -  파이 기호 사용함.
    - 릴레이션 R에서 주어진 속성들의 값으로만 구성된 튜플들을 반환.
    - 결과 릴레이션이 주어진 릴레이션의 일부 열로만 구성되어 해당 릴레이션에서 수직적 부분집합을 생성한 것과 같음. vertical subset.
    - 릴레이션[속성리스트]

  - 조인
    - 릴레이션 하나로 원하는 데이터를 얻을 수 없어 관계가 있는 여러 릴레이션을 함께 사용해야 하는 경우 조인 연산을 이용함.
    - 기호 |> <|
    - 공통 속성을 이용해 릴레이션 R과 S의 튜플들을 연결하여 만든 새로운 튜플들을 반환.
    - 동등 조인 : 조인 속성 중복 표시됨.
    - 세타 조인 : 비교 연산자 사용. 세타 조인에서 = 연산자를 사용한 것이 동등 조인임.
    - 자연 조인 : 조인 속성 한 번만 표시됨.

  - 디비전
    - 기호 나누기
    - 릴레이션 S의 모든 튜플과 관련이 있는 릴레이션 R의 튜플들을 반환.




#### 관계 해석

- 개념
  - 관계 데이터 연산의 한 종류.
  - 원하는 결과를 얻기 위해 처리를 원하는 데이터가 무엇인지만 기술, 비절차적 언어
  - 데이터를 처리하는 기능과 처리를 요구하는 표현력에서 관계 대수와 관계 해석은 능력이 모두 동일함.
  - 수학의 프레디킷 해석에 기반을 두고 있음.
- 기호
  - 존재한다 E 거꾸로 exist
  - 모든것에대하여 A 거꾸로 for all
  - 속한다 E
  - 합집합 U 눕힌거



### 데이터베이스의 정규화(중)

#### 정규화

- 개념
  - 하나의 릴레이션에 하나의 의미만 존재할 수 있도록 릴레이션을 분해해나가는 과정.
  - 데이터 모델링의 단계 중 가장 중요한 단계로써 논리 데이터 모델링을 상세화하는 단계임.
  - 중복성을 최소화하고 정보의 일관성을 보장하기 위한 개념임.
  - 정규형(Normal Form)이란 특정 조건에 만족하는 릴레이션 스키마의 형태를 의미함.
  - 이상 현상이 발생하지 않도록, 릴레이션을 관련이 있는 속성들로만 구성하기 위해 릴레이션을 분해(decomposition)하는 과정.
  - 정규화를 수행하려면 먼저 릴레이션을 구성하는 속성들 간의 관련성을 판단할 수 있어야 함. 정규화 과정에서 고려해야 하는 속성들 간의 관련성을 함수적 종속성(FD, Functional Dependency)이라고 함.
  - 일반적으로 릴레이션에 함수적 종속성이 하나만 존재하도록 정규화를 통해 릴레이션을 분해함.
- 목적
  - 구성되는 모든 릴레이션이 중복되지 않게 효과적으로 데이터베이스 내에 표현이 가능하도록 함.
  - 보다 간단한 연산자에 의해 효과적인 연산이 가능하도록 구성함.
  - 새로운 형태의 데이터가 삽입될 때 릴레이션을 재구성할 필요성을 감소시키도록 함
  - 자료 검색과 추출의 효율성을 추구할 수 있음
  - 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만듦.
- 필요성
  - 자료의 저장 공간을 최소화
  - 자료의 불일치를 최소화
  - 자료 구조를 안정화
  - 자료의 삽입, 삭제, 갱신 시 이상 현상을 방지
- 장점
  - 정규화 수준이 높으면 유연한 데이터 구축이 가능함.
  - 정규화 수준이 높으면 데이터의 정확성 높아짐.
- 단점
  - 정규화 수준이 높으면 물리적 접근이 복잡해짐.
  - 정규화 수준이 높으면 길이가 짧은 데이터 생성으로 많은 조인이 발생함.
- **정규화 과정**

  - 비정규형

  - 제1NF(제1정규형) : 도메인을 원자 값만 갖도록 분해함.

  - 제2NF(제2정규형) : 부분 함수 종속을 제거함.

  - 제3NF(제3정규형) : 이행적 함수 종속을 제거함.

  - 보이스 코드 정규형 : 결정자가 후보키가 아닌 함수 종속을 제거함.

  - 제4NF(제4정규형) : 다중치 종속을 제거함.

  - 제5NF(제5정규형) : 후보키를 통하지 않은 조인 종속을 제거함.
- 기본 정규형 : 1,2,3,보이스코드 정규형
- 고급 정규형 : 4,5 정규형



#### 정규화의 단계 (도부이결다조)

- 제1정규형(1NF : First Normal Form)
  - 하나의 튜플에서 여러 개의 값이 들어와 원자성을 가지지 못하는 경우(비정규형)에 도메인 값을 분해하면 1정규형이라고 함.
  - 비정규형 릴레이션에서 속성의 도메인이 원자값으로만 구성되도록 릴레이션 분해한 것.
  - 릴레이션에 속한 모든 속성의 도메인이 원자 값으로만 구성되어 있으면 제 1 정규형에 속함.
  - 반복 그룹(Repeat Group) 속성을 제거함.
  - 모든 속성은 반드시 하나의 값을 가져야 함. 반복 형태가 있어서는 안 됨.
- 제2정규형(2NF : Second Normal Form)
  - 릴레이션이 제1정규형이 속하고 기본키에 속하지 않는 모든 속성들이 기본키에 완전 함수 종속이면 제2정규형이 속함.
  - 제1정규형 릴레이션에서 부분 함수 종속을 제거한 것.
  - 주 식별자 전체에 완전 함수 종속(Full Function Dependency)이 되지 않는 속성을 제거함.
  - 주 식별자 속성 일부에만 함수적 종속되는 속성들을 상위 개체로 도출함.
  - 릴레이션 분해 시 주의할 점은 분해된 릴레이션들을 자연 조인하여 분해 전의 릴레이션으로 다시 복원할 수 있어야 한다는 것임. 릴레이션들이 의미상 동등한 릴레이션들로 분해되어야 하고, 릴레이션을 분해했을 때 정보 손실이 발생하지 않아야 함.
- 제3정규형(3NF : Third Normal Form)
  - 릴레이션이 제2정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제 3 정규형에 속함.
  - 제2정규형 릴레이션에서 이행적 함수 종속을 제거한 것.
  - A->B, B->C, A->C 관계를 이행적 함수 종속이라고 함. 일종의 여자 양다리.
  - 학생, 학과, 지도교수의 관계에서 학생이 학과를 선택하면 지도교수가 배정되는 것인데, 마치 학생이 지도교수를 선택한 것처럼 보이는 경우가 이행적 함수 종속임.
  - 학생-학과 릴레이션과 학과-지도교수 릴레이션으로 분리하면 됨. 학과는 교수 릴레이션의 기본키이면서 학생 릴레이션의 외래키가 됨.
  - 중간 다리인 학과를 외래키와 기본키 역할을 하는 릴레이션 2개로 분할하는 것이 제3정규형임.
  - 주 식별자에 이행 종속(Transitive Dependency)되는 속성을 제거함.
  
- 보이스 코드 정규형(BCNF : Noyce-Codd NF)
  - 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키이면 보이스 코드 정규형에 속함.
  - 제3정규형에서 후보키가 아닌 결정자를 제거한 것.
  - 하나의 릴레이션에 여러 개의 후보키가 존재할 수 있는데, 이 경우에는 제3정규형까지 모두 만족하더라도 이상 현상이 발생할 수 있음.
  - 강한 제 3 정규형(strong 3NF)이라고도 함. 제 3 정규형에 추가적인 제약조건이 있음.
  - 비결정자에 의한 함수 종속을 제거하여 모든 결정자가 후보키가 되도록 하는 데 있음.
  - {A, B} -> C 이면서 동시에 C -> B 인 경우 => A->C , C->B 2개의 릴레이션으로 분해. C는 후보키가 아닌 결정자가 됨.
  - 고객아이디 / 인터넷강좌 / 담당강사 3개의 속성으로 구성된 릴레이션에서 발생함. {고객아이디, 인터넷강좌} -> 담당강사 / 담당강사 -> 인터넷강좌
  - 비결정자에 의한 함수적 종속 제거 -> 기본키가 아닌 다른 속성에 의해  함수적 종속되는 것을 제거

- 제4정규형(4NF : Four Normal Form)
  - 1:1인 함수 종속 관계가 아닌 1:N 형태로 종속되는 관계를 다치 종속 관계라고 함.
  - A ->> B
  - 보이스/코드 정규형을 만족하면서, 함수 종속이 아닌 다치 종속을 제거해야 만족할 수 있음.
  - 만약 과목 10개, 교수10명, 출판사 10개를 하나의 릴레이션으로 표현하면 최대 1000개의 데이터 조합이 발생할 수 있음. 과목과 교수, 과목과 출판사로 릴레이션을 분해하면 각각 100개의 데이터씩 200개로 데이터 조합이 줄어듦. 데이터의 개수도 줄고 이상 현상도 발생하지 않게 됨.
- 제5정규형(5NF : Five Normal Form)
  - 제 4 정규형을 만족하면서, 후보키를 통하지 않는 조인 종속을 제거해야 만족할 수 있음.
  - 어떤 릴레이션 R에 존재하는 모든 조인 종속성이 릴레이션 R의 후보키를 통해서만 성립됨.
  - 정규화를 통해서 분해된 각 릴레이션들은 처음의 릴레이션으로 재구성될 수 있다면 조인 종속성을 만족시킴.
  - 복원 확인 : 릴레이션의 이상 현상을 제거하기 위해 여러 개의 릴레이션으로 분해했다면, 분해된 릴레이션들로 자연조인 했을 때, 원래의 릴레이션이 될 수 있는지 확인해야 함.
  - 원래의 릴레이션으로 복원될 수 있다면 제5정규형이 완료되는 것이고, 그렇지 않다면 새롭게 릴레이션을 추가해서라도 원래의 릴레이션으로 복원되도록 해야 함.
  - 자연조인할 때 존재하지 않는 튜플이 생성되는 것을 부당 튜플이라고 함.



### 논리 데이터 모델 품질 검증(하)



## 3. SQL

### SQL 명령어(상)

#### 데이터 정의어

- 개념
  - DDL : Data Definition Language
  - 데이터베이스를 정의하거나 그 정의를 수정할 목적으로 사용하는 언어.
  - 기본 테이블, 뷰 테이블, 또는 인덱스 등을 생성, 변경, 제거하는데 사용되는 명령어.

- DDL 명령어 종류
  - CREATE : 테이블 생성
  - ALTER : 테이블 변경
  - DROP : 테이블 삭제
  - TRUNCATE : 테이블 내용 삭제

- 삭제, 갱신의 제약조건 CONSTRAINT
  - 참조된 기본키의 값이 삭제 또는 수정될 경우
  - CASCADE : 참조한 테이블에 있는 외래키와 일치하는 모든 행 삭제, 갱신
  - RESTRICT : 참조한 테이블에 있는 외래키에 없는 것만 삭제, 갱신. 테이블을 삭제 갱신할 때 참조하는 테이블이 있다면 실행을 취소함.
  - NULLIFY : 참조한 테이블에 정의된 외래키와 일치하는 것을 NULL로 수정

- CHECK는 개발자가 정의하는 제약조건. 상황에 따라 다양한 조건 설정이 가능함.



#### CREATE 명령어

- CREATE TABLE 테이블명 ( 내용 );
- 내용
  - 필드명 데이터타입 [DEFAULT 값] [NOT NULL]
  - [PRIMARY KEY (필드 리스트)]
  - [FOREIGN KEY (필드 리스트) REFERENCES 테이블명 [(필드명)] [ON DELETE 옵션] [ON UPDATE 옵션]]
  - [CHECK (조건식) | UNIQUE(필드명)]



#### ALTER 명령어

- ALTER TABLE 테이블명 내용;
- 내용
  - ADD 필드명 데이터타입 [DEFAULT 값]
  - FIRST
  - AFTER 앞필드명
  - MODIFY 필드명 데이터타입 [DEFAULT 값]
  - DROP 필드명
  - ADD [CONSTRAINT 제약조건명] 제약조건(필드명)
  - DISABLE CONSTRAINT 제약조건명
  - ENABLE CONSTRAINT 제약조건명
- ALTER TABLE 이전테이블명 RENAME 새테이블명;
  - RENAME TABLE 이전테이블명 TO 새테이블명;



#### DROP 명령어

- DROP TABLE 테이블명 [CASCADE or RESTICT]



#### TRUNCATE 명령어

- TRUNCATE TABLE 테이블명;



#### 데이터 조작어

- DML : Data Manipulation Language
- 데이터 삽입(INSERT)
- 데이터 수정(UPDATE)
- 데이터 삭제(DELETE)
- 데이터 조회(SELECT)



#### SELECT 명령어

- SELECT 명령어 옵션
  - DISTINCT : 중복 튜플을 제거하여 조회.
  - \* : 모든 필드 조회
  - AS 별명 : 필드명이나 연산 결과를 별명으로 제목 부여
  - WHERE 조건 : 조건 만족하는 튜플들만 조회
  - GROUP BY 필드명 : 그룹별로 묶을 필드명을 지정함.
    - 그룹화하기 위해 집계함수 COUNT(), MAX(), MIN(), SUM(), AVG()와 함께 자주 사용됨.

  - HAVING 조건 : GROUP BY 절에 의해 생성된 결과 값 중 원하는 조건에 부합하는 데이터만 보고자 할 때 사용함.
  - ORDER BY : ASC(오름차순, 생략 가능) , DESC(내림차순)

- 집계 함수
  - COUNT(), SUM(), AVG(), MAX(), MIN()
  - STDDEV() : 표준편차
  - VARIAN() : 분산


- 조건 지정 검색 명령
  - 학점 IS NULL : 학점이 NULL.
  - 과제 IN(0, 1) : 과제가 0 또는 1
  - 이름 LIKE '김%' : 이름이 '김'으로 시작되는
  - 이름 LIKE '%김%' : 이름에 '김'이 표함된
  - 이름 LIKE '%김' : 이름이 '김'으로 끝나는
  - 시험점수 BETWEEN 60 AND 90 : 시험 점수가 60이상 90점 이하
- 부속, 복수 질의 명령
  - ANY : 부속 SELECT 앞에 ANY를 붙이면 결과들의 OR 연산 수행함. 합집합.
  - ALL : 부속 SELECT 앞에 ALL을 붙이면 결과들의 AND 연산 수행함. 교집합.
- 그룹 지정 명령
  - WHERE 구문은 GROUP BY보다 먼저 실행되고 WHERE 구문 안에 포함되지 않음.
  - GROUP BY ~ HAVING 조건
  - `SELECT 학번, COUNT(*) FROM 성적테이블 GROUP BY 학번;`
- 집합 명령
  - UNION : 중복 제거한 합집합
  - UNION ALL : 중복 제거 안 한 합집합
  - INTERSECT : 중복 제거한 교집합
  - EXCEPT : 차집합. 중복행이 제거됨.
- 테이블 생성
  - 새롭게 생성하고자 하는 테이블이 기존에 사용하고 있는 테이블과 동일한 구조를 갖고 있다면 기존에 존재하는 테이블 정보를 이용하여 새로운 테이블을 만들 수 있음.
  - CREATE TABLE 신규테이블 AS SELECT * FROM 기존테이블;



#### 데이터 제어어

- DCL : Data Control Language
- DCL 명령어 : 사용자 권한.
  - GRANT : 사용자 권한 부여
  - REVOKE : 사용자 권한 회수
- TCL 명령어 : 트랜잭션
  - COMMIT : 트랜잭션을 확정함.
  - ROLLBACK : 트랜잭션 취소
  - CHECKPOINT : 복귀지점 설정




#### 트랜잭션 제어어(TCL)

- TCL 명령어
  - COMMIT
    - 변경 사항이 물리적인 디스크에 저장됨.
    - COMMIT 명령 이후에는 COMMIT 이전 상태로 복구할 수 없음.
    - 모든 사용자가 변경된 결과를 볼 수 있음
  - ROLLBACK
    - 데이터베이스의 연산에 문제가 발생하면 이미 수행되었던 모든 작업을 취소하고 원래 상태로 복귀함.
    - ROLLBACK 명령 이후 메모리상의 버퍼(Buffer)에만 영향을 미치기 때문에 복구가 가능함.
  - SAVEPOINT
    - 특정 중간 시점을 SAVEPOINT로 지정하고, SAVEPOINT 이후에 오류가 발생하면, 처음부터 다시 시작하는 것이 아니라 SAVEPOINT부터 실행을 할 수 있음.



#### 트랜잭션

- 개념

  - 데이터베이스의 현재 상태를 하나의 일관된 상태에서 또 다른 일관된 상태로 변환시키는 논리적인 연산의 집합.
  - 트랜잭션은 일 처리 단위를 의미함.

- 특징

  - 트랜잭션은 논리적 연산 단위임.
  - 한 개 이상의 데이터베이스 조작임.
  - 하나 이상의 SQL 문장이 포함됨.
  - 트랜잭션은 거래임. 거래 결과가 모두 반영되거나 또는 모두 취소되어야 함.

- 특성 4가지

  - 원자성(Atomicity)
    - 트랜잭션의 연산은 모두 실행되거나 모두 실행되지 않아야 함.
    - 트랜잭션은 일부만 수행된 상태로 종료되어서는 안 됨.
    - 트랜잭션 A가 수행되는 동안 다른 트랜잭션 B는 트랜잭션 A가 지금까지 수행한 중간 결과를 참조할 수 없음.
  - 일관성(Consistency, 무결성)
    - 트랜잭션 실행 전과 후 동일하게 오류가 없어야 함.
    - 트랜잭션을 완전히 실행하면 데이터베이스를 하나의 일관된 상태에서 다른 일관된 상태로 바꿔야 함.

  - 고립성(Isolation, 독립성, 격리성)
    - 트랜잭션 실행 중 다른 트랜잭션에 영향을 받지 않아야 함.
    - 하나의 트랜잭션의 실행은 동시에 실행 중인 다른 트랜잭션의 간섭을 받아서는 안 됨.
  - 지속성(Durability, 계속성, 영속성, 장애 대응성)
    - 트랜잭션 결과는 항상 보존되어야 함.
    - 트랜잭션에 의해서 변화된 상태는 계속해서 유지될 수 있어야 함.
    - 완료한 트랜잭션에 의해 데이터베이스에 가해진 변경은 어떠한 고장에도 손실되지 않아야 함.

- 트랜잭션 상태 제어
  - 트랜잭션 상태를 제어한다는 것은 흐름의 구조를 바꾼다는 것이 아니라 트랜잭션의 결과를 수용하거나 취소하는 것을 의미함.
  - 활동(Active) : 트랜잭션 실행 중.
  - 부분 완료(Partially Committed) : 트랜잭션이 마지막 연산을 끝내고 데이터베이스에 실행 결과를 적용하기 직전의 상태.
  - 완료(Comitted) : 트랜잭션이 연산을 완료하고 연산의 결과를 데이터베이스에 적용한 상태(거래 확정)
  - 실패(Failed) : 트랜잭션이 실행 중 어떤 오류에 의해서 더 이상 진행될 수 없는 상태임.
  - 철회(Aborted) : 트랜잭션 실행이 실패하여 복귀되어 있는 상태. ROLLBACK 연산 수행한 상태.
  -  Redo(Re+Do, 다시 실행) : 갱신이 완료된 데이터를 로그 파일을 이용하여 복원함. 이미 진행 중이었던 작업을 다시 함.
  - Undo(Un+Do, 실행취소 = ROLLBACK) : 변경되었던 데이터를 취소하여 원래의 내용으로 복원함. 했던 작업을 다시 하지 않고 원상태로 되돌림.



#### CRUD

- C(Create), R(Read), U(Update), D(Delete)
- CRUD Matrix
- CRUD 분석



### 절차형 SQL(하)

#### 트리거

- Trigger



### 인덱스와 뷰(하)

#### 인덱스

- Index
- 개념
  - 데이터베이스 성능에 많은 영향을 주는 DBMS의 구성 요소로 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유함.
  - 문헌의 색인, 사전과 같이 데이터를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조.
  - 테이블에 붙여진 색인으로 데이터 검색 시 처리 속도 향상에 도움이 됨.
  - 인덱스는 기본 테이블의 특정 레코드 위치를 알려주는 용도로 사용함.
  - 인덱스는 자동 생성되지 않기 때문에 데이터베이스 사용자가 지정해주어야 함. 다만 데이터베이스 사용자가 특정 컬럼을 기본키(PK)로 지정할 경우에 인덱스는 자동 생성됨.
  - 인덱스는 조건절에 '='로 비교되는 컬럼을 대상으로 인덱스를 생성하면 검색 속도를 높일 수 있음.
- 생성 : `CREATE [UNIQUE] INDEX <인덱스명> ON <테이블명> (<필드명들>);`
- 삭제 : `ALTER TABLE <테이블명> DROP INDEX <인덱스명>`
  - 보통 인덱스를 테이블의 종속 구조로 생각하기 때문에 인덱스를 삭제하기 위해 테이블에 변경을 가하는 형식의 명령을 사용함.
- 조회 : `SHOW INDEX FROM <테이블명>`



#### 뷰

- View.

- 개념
  - 하나 이상의 뷰 테이블은 기본 테이블로부터 유도되어 정의되는 가상 테이블이며 뷰 테이블로 정의한 정보는 시스템 카탈로그에 저장됨.
  - 뷰 테이블은 물리적으로 존재하지 않고 또한 물리적으로 분리될 수도 없음.
  - 외부 스키마를 구성하는 데 쓰임.
  - 같은 데이터를 동시에 여러 사용자에게 상이한 방법으로 제공할 수 있음.
  - 제공되지 않은 데이터에 대해서는 자동적으로 보안을 유지할 수 있음.
  - 뷰 위에 또 다른 뷰를 정의할 수 있음.
  - 뷰 테이블을 변경하려면 뷰 테이블을 DROP으로 삭제하고 다시 생성해야 함.
- 뷰(View)의 장점
  - 논리적 독립성 제공 : 테이블의 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 됨.
  - 사용자 데이터 관리 용이 : 복수 테이블에 존재하는 여러 종류의 데이터에 대해 단순한 질의어 사용이 가능함.
  - 데이터 보안 용이 : 중요 보안 데이터를 저장 중인 테이블에는 접근 불허하며, 해당 테이블의 일부 정보만을 볼 수 있는 뷰에는 접근을 허용하는 방식.
- 뷰의 단점
  - 뷰 자체 인덱스 불가능
  - 뷰 정의 변경 불가능
  - 데이터 변경 제약 존재
- 뷰의 생성
  - `CREATE VIEW <뷰 이름>(컬럼 목록) AS <SELECT문> [옵션];`
- 뷰의 옵션
  - REPLACE / FORCE / NOFORCE / WITH CHECK OPTION / WITH READ ONLY
- 뷰의 삭제
  - `DROP VIEW <뷰 이름>;`
- 뷰의 조회
  - `SELECT * FROM <뷰 이름>;`



### SQL 지원 도구(하)



#### 시스템 카탈로그

- System Catalog. 데이터 사전. 시스템 데이터베이스
- 개념
  - 테이블 정보, 인덱스 정보, 뷰 정보 등을 저장하는 시스템 테이블임.
  - 사용자들이 검색은 가능하나 직접적인 변경은 불가능함.
  - 시스템이 필요로 하는 모든 객체에 대한 정보를 가지고 있는 시스템 데이터베이스로 사용자 데이터베이스와는 구별됨.
  - 시스템 데이터베이스에는 카탈로그와 디렉토리로 나누어 저장하는데 카탈로그에는 객체에 대한 정보를 저장하고 디렉토리에는 그 정보를 어떻게 액세스할 것인가하는 시스템만이 사용하는 정보를 저장하게 됨.
- 구성 요소
  - 시스템 카탈로그 : 생성된 테이블에 관련된 정보를 기록함.
  - 데이터 디렉토리 : 데이터 사전에 수록된 데이터를 실제로 접근하는 데 필요한 정보를 기록하며 시스템만이 접근할 수 있는 구역.
  - 메타 데이터 : 사용자의 데이터를 설명해 놓은 데이터 사전임.
  - 데이터 사전 : 사용자의 테이블과 속성의 관련 정보를 기록함.



### 병행 제어와 로킹(중)

#### 병행 제어

- 개념
  - Concurrency Control, 동시성 제어
  - 여러 사용자들이 데이터베이스의 공동 사용을 최대화함.
  - 사용자의 응답 시간을 최소화함.
  - 데이터베이스 시스템의 활용도를 최대화함.
  - 데이터베이스의 일관성을 유지함.
- 병행 처리의 문제점
  - 분실된 갱신 Lost update
  - 모순성 Inconsistency
  - 연쇄 복귀 Cascading Rollback
  - 비완료 의존성 Uncommitted Dependency



#### 로킹

- 개념
  - Locking
  - 병행 제어 기법 중 하나. 동시성 제어 기법 중 하나.
  - 데이터베이스에서 하나의 트랜잭션에 사용하는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는 행위.
- 로킹 단위
  - 로킹의 대상이 되는 객체의 크기. 한꺼번에 로킹할 수 있는 객체의 크기.
  - 로킹 단위가 작아짐 : 로크의 수 많음, 병행성 수준 높음, 오버헤드 증가, 복잡함
  - 로킹 단위가 커짐 : 로크의 수 적음, 병행성 수준 낮음, 오버헤드 감소, 단순함
  - 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음.
  - 오버헤드 : 로크의 단위가 작아지면 로크의 수는 많이 늘어날 것이고, 많은 로크를 관리하기 위한 간접 비용 부담인 오버헤드는 증가할 수밖에 없다.




#### 회복

- 개념
  - Recovery
  - 데이터베이스의 상태가 일관성 유지에 제약이 걸렸을 때 장애 이전의 일관된 상태가 되도록 복원하는 일.
- 장애의 유형
  - 실행 장애 : 사용자 실수
  - 트랜잭션 장애 : 트랜잭션 내의 논리적 오류
  - 시스템 장애 : hw 오작동으로 내용 유실, 교착상태
  - 미디어 장애 : 데이터 전송 중에 헤드 충격이나 고장으로 인하여 디스크 등이 작동하지 못하는 상태

- 회복에 따른 연산자
  - Redo : 갱신이 완료된 데이터를 로그를 이용해 데이터베이스에 적용하는 연산. 데이터베이스 내용 손상됐을 때 백업.
  - Undo : 변경된 데이터를 취소하여 원래의 내용으로 복원시키는 연산. 트랜잭션 실행 중 실패했을 경우.

- 회복 기법
  - 연기 갱신 (Differed Update) : 트랜잭션이 성공적으로 종료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기하고 그 동안 변경 내용은 로그에 보관하는 기법. 회복 작업 시 Redo 작업만 수행됨.
  - 즉각 갱신 (Immediate Update) : 트랜잭션이 데이터를 변경하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 데이터베이스에 반영하는 기법. 회복 작업 시 Redo, Undo 모두 수행.
  - 그림자 페이지 (Shadow Paging) : 갱신 이전의 데이터베이스를 일정 크기의 페이지 단위로 구성하여 각 페이지마다 복사본인 그림자 페이지로 별도 보관해 두고, 실제 페이지를 대상으로 트랜잭션에 대한 변경 작업을 수행하는 기법. 회복을 위해 로그 유지할 필요 없음. 회복 작업 시 Redo, Undo 수행 안함.
  - 검사점 (Check Point) : 장애 발생 시 로그 전체를 조사하지 않고 로그 내에서 가장 최근의 검사점으로부터 회복 작업을 수행하여 회복 시간을 단축함.
  - 미디어 회복 (Media Recovery) : 데이터베이스 내용을 주기적으로 안전한 저장 장치에 덤프함.



## 4. 물리 데이터베이스 설계

### 물리 데이터 모델 설계(하)

#### 파티션

- 종류
  - 범위 분할
  - 해시 분할
  - 조합 분할
- 장점



### 저장 레코드 형식 설계(하)



### 반정규화 수행(하)

#### 반정규화

- 개념
  - De-Normalization



#### 반정규화 유형

- 중복 테이블 추가
  - 중복 테이블 추가 용도
  - 집계(통계) 테이블을 추가하는 방법
  - 진행 테이블 추가 상황 확인
  - 진행 테이블 생성 시 유의 사항 확인
  - 특정 부분만 포함하는 테이블을 추가하는 방법
  - 테이블 추가 시 고려사항

- 테이블 조합
- 테이블 분할
  - 수평 분할 (Horizontal Partitioning)
  - 수직 분할 (Vertical Partitioning)



### 분산 데이터베이스 설계(중)

#### 분산 데이터베이스

- 개념
  - 하나의 논리적 데이터베이스가 물리적으로 네트워크에서 복수의 컴퓨터에 분산되어 있을 경우에도 사용자가 단일 데이터베이스와 같이 인식하는 것이 가능하도록 논리적으로 통합 및 공유되는 데이터베이스를 의미함.
- 구성 요소
  - 분산 처리기 : 물리적으로 분산되어 지역별로 필요한 데이터를 처리할 수 있는 지역 컴퓨터(Local Computer)를 분산 처리기(Distributed Processor)라고 함.
  - 분산 데이터베이스 : 지리적으로 분산된 데이터베이스
  - 통신 네트워크 : 분산 처리기들을 통신망으로 연결
- 장점
  - 데이터에 대한 지역적 분산 제어를 통해 원격 데이터에 대한 의존도를 감소시킬 수 있음.
  - 단일 서버에서 처리가 어렵거나, 불가능한 규모의 대용량 데이터 처리가 가능해짐.
  - 기존 시스템에 서버를 추가하는 방식을 통해 점진적 확장이 용이함.
  - 하나의 사이트에 문제가 생겨도 다른 사이트에서 사용할 수 있기 때문에 신뢰도와 가용성이 향상됨.
- 단점
  - 복잡도와 SW 개발 비용, 처리비용이 증가함.
  - 통제 기능이 상대적으로 취약함.
  - 오류 발생 가능성 증가함.
  - 응답 속도가 불규칙적으로 나타날 수 있으며 데이터의 무결성을 완전히 보장하기 어려움.



#### 분산 DBMS

- 투명성 (Transparency)
  - 복수의 분할된 물리적 데이터베이스를 논리적으로 단일화된 데이터베이스처럼 인식하려면 사용자들이 데이터의 물리적 배치와 특정 지역 사이트의 데이터에 대한 액세스 방법을 별도로 알 필요가 없어야 함.

- 분할 투명성 (Fragmentation Trasparency, 단편화 투명성)
  - 사용자에게 전역 스키마의 분할 상태를 알려주는 역할을 함.
  - 사용자가 입력한 전역 질의를 여러 개의 단편 질의로 변환해 주기 때문에 사용자는 전역 스키마가 어떻게 분할되어 있는지를 알 필요가 없게 됨.
- 위치 투명성 (Location Transparency)
  - 사용자나 애플리케이션에서 어떤 작업을 수행하기 위해 분산 데이터베이스상에 존재하는 어떠한 데이터의 물리적인 위치도 알 필요가 없어야 함.
  - 사용자는 분산 환경과는 무관하게 동일한 명령을 사용할 수 있어야 함.
- 중복 투명성 (Replication Transparency, 복제 투명성)
  - 중복된 데이터가 무엇인지와 저장 위치 등에 대한 정보를 사용자가 별도로 인지할 필요가 없어야 한다는 것임.
  - 사용하고 있는 데이터가 논리적으로 유일하다고 생각할 수 있는 환경을 제공해야 함.
- 장애 투명성 (Failure Transparency, 장애 고장 투명성)
  - 데이터베이스의 분산된 물리적 환경에서 특정 지역의 컴퓨터 시스템이나 네트워크에 장애가 발생해도 데이터 무결성이 보장된다는 것.
- 병행 투명성 (Concurrency Transparency)
  - 다수의 트랜잭션이 동시에 수행되는 경우에도 결과의 일관성이 유지되어야 한다는 것.



#### 데이터웨어하우스

- 개념
  - DataWarehouse
  - 기업의 정보 자산을 효율적으로 활용하기 위한 하나의 패러다임.
  - 기업의 전략적 관점에서 효율적인 의사 결정을 지원하기 위해 데이터의 시계열적 축적과 통합을 목표로 하는 기술의 구조적, 통합적 환경.
- 기존 데이터베이스와 차이점
  - 기능 : 의사결정 vs 업무데이터
  - 데이터 형태 : 주제별 요약 데이터 vs 기능별 상세 데이터
  - 연산 명령 : SELECT vs SELECT, INSERT, UPDATE, DELETE
  - 목표 : 다양한 분석 정보 제공 vs 신속한처리

- 데이터웨어하우스 활용
  - 데이터 마트(Data Mart) : 단일 주제, 예측 가능한 질의에 대해서 매우 빠르게 응답할 수 있도록 데이터를 제공하는 시스템
  - 온라인 분석 시스템 (OLAP) 온라인으로 다양한 분석 정보 제공하는 시스템
    - roll-up : 구체 -> 요약 접근
    - drill-down : 요약 -> 구체 접근
    - pivoting : 보고서 차원 변경해서 조회.
    - slicing : 다양한 형태로 조회, 비교
    - dicing : slicing보다 더 구체적으로 구분하여 조회하고 비교.

  - 데이터 마이닝(Data Mining) : 전략적 정보 발견, 정보 간의 새로운 패턴 찾아내는 지식 추출 기법. 일정한 패턴을 찾아내는 기법.




#### 하둡

- 개념
  - Hadoop

  - 빅데이터 저장과 분석을 위한 분산 컴퓨팅 솔루션.

  - 일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성함.

  - 아들이 소중히 여기던 코끼리 인형의 이름으로 이 기술을 명명함.

- 스쿱 (Sqoop)
  - 하둡과 관계형 데이터베이스 간 데이터를 전송할 수 있도록 설계된 도구.

- 타조 (Tajo)
  - 하둡 기반의 데이터웨어하우스.

- 맵리듀스 (MapReduce)
  - 대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델.
  - Google에 의해 고안된 기술. 대표적인 대용량 데이터 처리를 위한 병렬 처리 기법을 제공함.
  - 임의의 순서로 정렬된 데이터를 분산 처리하고 이를 다시 합치는 과정을 거침.
  - 맵(Map) : 데이터가 텍스트 형태로 입력되면 64KB로 분할함. 텍스트 안에 단어를 분류하여 카운트함.
  - 리듀스(Reduce) : 각 텍스트에서 정리된 맵들을 결합하여 동일한 단어를 카운트함.




## 5. 데이터 전환

### 데이터 전환(하)



### 데이터 정제(하)



# 4과목 프로그래밍 언어 활용

## 1. 프로그래밍 언어 기초

### 프로그램 언어와 번역(하)

#### 라이브러리

- Library
- 개념
  - 도서관처럼, 필요할 때 찾아서 쓸 수 있도록 모듈화되어 제공되는 부품화된 프로그램임.
  - 일반적으로 내장 함수, 지원 함수, 지원 프로그램 등을 말함.
- 구성
  - 도움말
  - 설치 파일
  - 샘플코드
- 표준 라이브러리
  - 프로그래밍 언어가 기본적으로 가지고 있는 라이브러리를 의미함.
  - 별도의 파일 설치 없이 사용할 수 있음.
- 외부 라이브러리
  - 별도의 파일을 설치해야 함.
  - 누구나 개발 설치 가능하고 인터넷 이용하여 공유할 수도 있음.
- C언어의 대표적인 라이브러리
  - stdio.h : 표준 입출력에 사용되는 함수, scanf, printf 등
  - string.h : 문자열 처리에 사용되는 함수, strlen, strcpy 등
  - math.h : 수학 함수, sqrt, abs 등
  - stdlib.h : 자료형 변환, 난수, 메모리 할당 함수, atoi, rand, malloc 등
  - time.h : 시간 처리 함수, time, clock 등



#### 스크립트 언어

- Script Language
- 원시 코드를 컴파일하지 않고도 실행할 수 있는 프로그래밍 언어.
- 스크립트 언어는 별도의 컴파일 없이 내장된 번역기(interpreter)에 의해 번역되므로 바로 실행할 수 있음.
- 스크립트 언어에는 Javascript, PHP, Basic, Python 등이 있음.



### 자료 객체(하)



## 2. 프로그래밍 언어 활용

### 알고리즘과 코딩(중)

#### 알고리즘 설계 기법

- 동적 계획법
- 탐욕적 알고리즘
- 재귀적 알고리즘
- 근사 알고리즘
- 배낭 알고리즘
- 분할 정복법
- 퇴각 검색법



#### 클린 코드 작성 원칙

- 가독성
- 단순성
- 의존성
- 중복성
- 추상화



#### 표준화된 코딩 형식

- 하나의 명령을 하나의 라인에 코딩함
- 명령어를 구분할 수 있는 줄 바꿈을 적절히 사용함
- 등등



#### C언어 변수명 작성 규칙

- 영문자, 숫자, 밑줄 문자(_)를 사용함.
- 첫 글자는 반드시 영문자로 시작해야 함. 밑줄 문자는 영문자로 취급되어 첫 글자로 사용할 수 있음.
- 영문자는 대소문자를 구분함.
- 공백을 포함하거나 다른 특수 문자를 포함해서는 안 됨.
- 예약어를 변수명으로 사용할 수 없음.



#### C언어의 문자열 함수

- strcpy() : 문자열을 복사함.
- strncpy() : 문자열에서 지정한 부분만큼 복사함.
- strcat() : 두 개의 문자열을 합침.
- strncat() : 두 개의 문자열을 지정한 부분만큼 합침.
- strlen() : 문자열의 길이를 셈.
- strcmp : 문자열 비교. 문자열이 같으면 0 다르면 -1, +1 반환.
- strrev() : 거꾸로 변환. 문자열을 뒤집음.
- strstr() : 문자열 탐색. 



### C언어와 연산자(하)



#### 연산자의 종류

- 단항 : ++, --, -, !, ~, sizeof, &, *
- 산술 : +, -, *, /, %
- 시프트 : <<, >>
- 관계 : <, >, <=, >=, ==, !=
- 비트 논리 : &, |, ^
- 논리 : &&, ||
- 조건 : ? :
- 할당 : =, +=, -=, *=, /=, %=, <<=, >>=



#### ++, -- 연산자

- 전위 연산자 : ++ 연산자가 변수 앞에 있음.
- 후위 연산자 : ++ 연산자가 변수 뒤에 있음.



#### &, * 연산자

- & 연산자는 변수의 절대 번지를 표현하는 번지 지정 연산자임.
- * 연산자는 포인터 변수를 선언하거나 포인터의 내용을 표현하는 간접 연산자임.



#### <<, >> 연산자 (시프트 연산자)

- 변수와 상수를 이진수로 풀어서 비트 하나하나를 대상으로 연산함.
- a << n : 변수 a를 n비트 만큼 좌 시프트함.



#### 관계 연산자

- 참이면 1(True), 거짓이면 0(False) 값을 가짐.



#### 비트 논리 연산자

- 변수와 상수를 이진수로 풀어서 비트 하나하나를 대상으로 연산함.
- a & b : 비트 AND, 대응되는 비트가 한쪽이라도 0이면 0임.
- a | b : 비트 OR, 대응되는 비트가 한쪽이라도 1이면, 1임.
- a ^ b : 비트 XOR, 대응되는 비트가 같으면 0, 다르면 1임.



#### 논리 연산자

- a && b : 한쪽이라도 거짓이면 거짓으로 0이 됨.
- a || b : 한쪽이라도 참이면 참으로 1이 됨.



#### 삼항 연산자

- 조건식 ? A : B
- 조건식이 참이면 A명령문, 거짓이면 B명령문을 수행함.



### C언어의 제어문(하)

#### for문

#### while문

#### do~while문



### C언어의 고급 기법(하)

#### 배열

#### 포인터

#### 구조체

- Structure
- C언어에서 제공되는 변수 구조가 아닌 자신만의 변수 구조를 만들 때 구조체를 사용함.
- 일반적으로 여러 개의 항목(Field)이 존재하는 레코드(Record)를 만들 때 사용함.
- C언어에서는 레코드를 구조체라고 함.

- `struct rec { 내용 }`
  - 구조체 예약어는 struct
  - rec는 구조체를 여러 개 사용할 때 각 구조체를 구분하기 위한 태그(tag)로 프로그래머가 임의로 지정하면 됨.
- `struct rec REC = {1. "김자바". 78};`
- `REC.bun, REC.name, REC.jum`



#### 지원 라이브러리 함수

- 문자열과 숫자 변환 함수
- 수학 함수



#### 메모리 할당 함수 malloc()

- malloc() 함수를 사용하는 동적 할당은 프로그램 실행 중에 힙(Heap) 메모리 공간에 필요한 메모리 크기와 유형(Type)을 지정하여 할당받아 사용하고, 실행 중에 반납(free()) 할 수 있음.



### 파이썬(Python)(하)

#### Python의 기초

- 특징
  - 인간 중심 언어 쉽고 빠르게 배울 수 있음
  - C, C++과 호환성이 좋음.
  - 웹 프로그램을 만들기에 매우 적합한 도구.
  - 데이터 분석에 강점.
  - 인터프리터 방식의 객체지향 언어.
  - 인터프리터가 없는 안드로이드나 iOS 환경에서는 동작하지 않음.
  - 대단히 빠른 속도를 요구하거나 하드웨어를 직접 접근해야 하는 프로그램에는 어울리지 않음.
- 변수 작성 규칙
  - 첫 글자 숫자 X
  - 영문 대소문자, 숫자, 밑줄 문자(_) 사용함.
  - 영문 대소문자를 구분함.
  - 변수 이름 중간에 공백 사용 못함.
  - 예약어 사용 불가.
  - 변수명의 길이에 제한이 없음.
  - 한글도 사용 가능하기는 함.



#### Sequence 데이터 타입

- 리스트(List)
  - 가장 많이 사용되는 연속형 데이터 타입.
  - 굉장히 유연한 구조를 가지고 있어 대부분의 데이터를 편하게 다룰 수 있음.
  - [1, 2, 3]
  - 리스트의 원소는 쉼표로 구분되며, 리스트의 원소는 아무 데이터 타입이나 가능함. 리스트조차 가능함.
  - 수정이 자유로움. 수정을 하면 안되는 경우에는 사용하면 안 됨.
- 튜플(Tuple)
  - 리스트와 2가지 제외 완전 똑같음.
  - 리스트는 []를 사용하고, 튜플은 ()를 사용함.
  - 리스트는 생성 후에 변경이 가능하고(mutable) 튜플은 생성 후에 변경이 불가능함(immutable)
- 문자열(String)



#### 집합 데이터 타입

- 세트 데이터 타입 Set
- 순서 없고 중복 불가능함. null값도 1개.

- 생성은 (), 내용은 {} 사용함.



#### 사전 데이터 타입

- 맵, Map

- key-value 방법을 통해 저장함.
- {}을 이용하여 표현.
- {key : value, key2 : value2, ...}
- key는 중복 불가. 사전에서 key가 될 수 있는 데이터 타입은 immutable이어야 함.



#### 문자열 슬라이싱(Slicing)

- s = "Hello World"
- print(s[1:5]) : ello, 1부터 5까지인데 5 위치는 포함 안됨
- print(s[:4]) : Hell, 문자열 처음부터 4까지인데 4 위치는 포함 안됨
- print(s[-1]) : d, 마지막 위치
- print(s[-3:-1]) : rl, 마지막 1번쨰는 포함 안됨.
- print(s[-3:]) : rld, 마지막에서 문자열의 끝까지



#### 숫자형 슬라이싱

- a=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
- print(a[7:]) : a[7]포함하여 이후 모두 출력. [7, 8, 9]
- print(a[:3]) : a[3] 제외하고 이전 모두 출력.
- print(a[:7:2]) : 2칸씩 띄고 출력. [0, 2, 4, 6]



#### for문

```python
for i in range(10):
    print("i = ", i)
```

- i를 0부터 9까지 1씩 증가하면서 10번 반복함. range(최종치)에서 최종치는 포함되지 않음.
- `for i in rage(1, 11, 3):` : i를 1부터 10까지 3씩 증가시킴. i=1, 4, 7, 10
- `for i in [리스트]` : 리스트 값을 하나씩 출력함.
- 파이썬은 print()하면 자동으로 개행됨.



#### while문

```python
sum = 0
i = 0
while i < 10:
    i = i + 1
    print("i = ", i)
    sum += i
    print("합 = ", sum)
```



#### 반복문의 흐름 제어

- pass : 실행할 코드가 없으므로 명령으로 이동함.
- continue : 반복문의 시작으로 이동함.
- break : 반복문을 멈추고 반복문을 벗어남.



#### Python 클래스와 인스턴스

```python
class Peo:
    def p_init(self):
        self.name = "None"
        self.age = -1
    def p_pro(self):
        self.name = "Java"
        self.age = 20
    def p_prt(self):
        print(self.name, self.age)
p1 = Peo()
p1.p_init()
p1.p_pro()
p1.p_prt()
```

- self는 클래스의 인스턴스를 가리키며 self를 통해 클래스의 메소드와 변수에 접근할 수 있음.
- self 변수명은 반드시 self명을 사용할 필요가 없으며, 다른 변수명을 사용해도 메소드의 첫 번째 위치한 매개 변수명은 자기 자신을 가리키는 self 변수의 의미로 사용됨.



#### Scrapy

- 파이썬 기반의 웹크롤러 프레임워크
- 가볍고 빠르고 확장성이 좋음.



## 3. 객체지향 기술

### 객체지향 기술의 개념(중)

#### 객체

- 객체(Object, 오브젝트)
  - 객체(Object) = 속성(Attribute) + 메소드(Method)
  - 속성과 메소드로 구성된 클래스의 인스턴스(객체 복사품)를 의미함.
- 속성(Attribute, 애트리뷰트)
  - 자료 구조, 변수, 데이터, 성질, 분류, 식별, 수량, 상태를 의미함.
- 메소드(Method)
  - 행위, 기능, 함수, 프로시저, 연산, 메소드는 동사형, 객체는 명사형임.



#### 객체의 구성 요소

- 클래스(Class)
  - 하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 데이터 추상화를 의미함.
  - 객체의 타입을 정의하고 객체를 생성하는 틀을 의미함.
- 객체(Object)
  - 개체(Entity), 속성(Attribute), 메소드(Method)로 구성된 클래스의 인스턴스를 의미함.
- 인스턴스(Instance)
  - 실행 중인 임의의 프로세스, 클래스의 현재 생성된 객체를 가리킴.
  - 클래스로 정의된 객체의 복사본이라고 할 수 있음.
- 메시지(Message)
  - 객체와 객체들 사이의 인터페이스 형식을 메시지라고 하며 메시지를 주고받음으로써 객체 간의 상호 작용을 함.
  - 메시지는 객체에 어떤 행위를 하도록 지시하는 명령임.



#### 캡슐화(Encapsulation)

- 구조적 설계에서 모듈화와 같은 의미.
- 객체를 정의할 때 연관된 속성(자료 구조, 데이터 등)과 방법(함수, 기능 연산 등)을 한 테두리로 묶는 것을 말함.
- 장점
  - 가독성이 좋아 유지보수가 용이함.
  - 재사용성 올라감.
  - 중복 최소화
  - 인터페이스 단순화
  - 정보 은폐로 내부 자료의 일관성이 유지됨
  - 변경이 발생할 때 오류의 파급 효과가 작음.



#### 정보 은폐

- Information Hiding, 정보 은닉
- 캡슐화된 객체 내부에 속성이나 메소드의 기능이 외부에 영향을 받거나 주지 않도록 설계하는 방법.
- 고려하지 않은 영향(Side Effect)들을 최소화하기 위하여 사용됨.
- 모듈이나 객체 사이의 독립성을 유지하는 데 도움이 됨.
- IP 주소와 같은 물리적 코드, 상세 데이터 구조 등 캡슐화된 항목을 다른 객체로부터 은폐해야 함.



#### 추상화

- Abstraction
- 불필요한 것은 제외하고 공통적으로 사용 가능한 큰 틀을 구상함.
- 공통 성질을 추출하여 슈퍼 클래스(부모 클래스)로 구성함.
- 현실 세계를 자연스럽게 표현함. 객체 중심의 안정된 모델을 구축할 수 있음.
- 추상화는 복잡한 문제의 본질을 이해하기 위해 세부 사항은 배제하고 중요한 부분을 중심으로 간략화하는 기법임.
- 객체가 될 수 있는 사람, 새, 말, 사자, 호랑이 등을 대표할 수 있는 객체는 존재하지 않지만 동물이라는 대표성을 가진 추상적인 데이터를 만들어 사용할 수 있음.
- 추상화 기법 종류
  - 제어 추상화
  - 기능 추상화 : 입력 자료를 출력 자료로 변환하는 과정을 추상화하는 방법.
  - 자료 추상화
  - 과정 추상화 : 자세한 수행 과정을 정의하지 않고 전반적인 흐름만 파악할 수 있게 설계하는 방법.
  - 데이터 추상화 : 데이터의 세부적인 용도를 정의하지 않고 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법




#### 다형성

- Polymorphism
- 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질을 다형성이라고 함.
- 동일한 이름의 메소드를 다른 사양으로 정의할 수 있음.
- 다형성은 한 메시지가 객체에 따라 다른 방법으로 응답할 수 있도록 설계해야 함(오버로딩)
- 상이한 클래스들이 동일한 메소드명을 이용하는 능력이 있어야 함(오버라이딩)



### 객체지향 개발 순서(상)

#### 객체지향 개발 순서

- 계획
- 분석(OOA) : 객체 모델링 -> 동적 모델링 -> 기능 모델링
- 설계(OOD) : 객체 설계 -> 시스템 설계
- 구현(OOP)
- 테스트 및 검증 : 단위 테스트 -> 통합 테스트 -> 검증과 시스템 테스트



#### 객체지향 분석

- OOA : Object Oriented Analysis
- 객체지향 분석의 특징
  - 소프트웨어를 개발하기 위한 비즈니스를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석해 내는 기법.
  - E-R 다이어그램은 객체지향 분석의 표기법으로 적합함.
- 객체지향 분석의 순서
  - 객체 모델링
    - Object Modeling, 객체 모형
    - 문제 영역에서 요구되는 객체를 찾아내고 객체의 속성, 연산을 식별하는 단계.
  - 동적 모델링
    - Dynamic Modeling, 동적 모형
    - 객체 모델링에서 생성된 객체 모형들의 행위, 상태, 조건을 파악하는 단계.
    - 사건(Event)과 상태(State)를 파악하여 상태도를 만듦.
    - 상태 다이어그램(State Diagram)이 활용됨. (UML 행위적 다이어그램 중 하나)
    - 객체가 할 수 있는 일과 없는 일 구분함.
  - 기능 모델링
    - Functional Modeling, 기능 모형
    - 입출력 결정
    - 자료 흐름도(DFD)
    - 기능의 내용을 상세히 기술
    - 제약사항을 결정하고 최소화



#### 객체지향 분석 방법론

- Rumbaugh 방법 (럼바우 방법)
  - 객체 모델링 기법이라고도 함. Object Modeling Technique
  - 가장 일반적으로 사용되는 방법
  - 분석 활동을 객체모델, 동적모델, 기능모델로 나누어 수행하는 방법
  - 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법
  
- Booch 방법 (부치 방법)
  - 미시적, 거시적 개발 프로세스를 모두 사용하는 분석 방법
  - 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의함.

- Jacobson 방법
  - Usecase 유스케이스를 사용하여 분석함.
  - 사용자가 제품 또는 시스템과 어떻게 상호 작용하는지를 서술한 시나리오로 접근

- Coad Yourdon 방법 (코드와 이든 방법)

  - 객체지향 분석 방법론 중 E-R 다이어그램을 사용하여 객체의 행위를 모델링함.

  - 객체 식별, 구조 식별, 주체 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성되는 방법임.

- Wirfs-Brock 방법
  - 분석과 설계간 구분 없음
  - 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행함.
  - 고객 명세의 평가로 시작하여 설계로 끝나는 연속적인 프로세스로 접근



#### 객체지향 설계

- OOD, Object Oriented Design
- 객체지향 설계의 원칙
  - 단일 책임의 원칙
    - SRP, Single Responsibility Principle
    - 객체는 하나의 책임만 맡아 처리할 수 있게 해야 함
    - 낮은 결합도, 높은 응집성을 유지할 수 있음.
  - 개방 폐쇄 원칙
    - OCP, Open-Closed Principle
    - 소프트웨어 개체는 확장에는 열고, 수정 시에는 닫혀있게 해야 함.
    - 개체는 객체, 모듈, 함수 등이 있음.
  - 리스코프 치환의 원칙
    - LSP, Liskov Substitution Principle
    - 서브 타입(상속받은 하위 클래스)은 어디에서나 자신의 기반 타입(상위 클래스)으로 교체할 수 있어야 함.
    - 자동 타입 변환
  - 인터페이스 분리의 원칙
    - ISP, Interface Segregation Principle
    - 한 개의 일반적인 인터페이스보다 구체적이고 안전한 여러 개의 인터페이스가 좋음.
    - 클라이언트는 자신이 사용하지 않는 메소드와 의존 관계를 맺으면 안 됨.
    - 클라이언트가 사용하지 않는 인터페이스 때문에 영향을 받아서는 안 됨.
  - 의존성 뒤집기의 원칙
    - DIP, Dependency Inversion Principle
    - 추상화 클래스에 의존하게 되므로, 구체적인 클래스에 의존하지 않도록 해야 함.



### 자바(Java)(하)

#### 접근 지정자 (접근 제어자)

|   접근 영역   | private | default | protected | public |
| :-----------: | :-----: | :-----: | :-------: | :----: |
| 자신의 클래스 |    O    |    O    |     O     |   O    |
|  같은 패키지  |    X    |    O    |     O     |   O    |
|  하위 클래스  |    X    |    X    |     O     |   O    |
|  다른 패키지  |    X    |    X    |     X     |   O    |



#### 오버로딩과 오버라이딩

- 오버로딩(Overloading)
  - 하나의 클래스 안에서 동일한 이름을 가진 메소드를 사용하는 기술.
  - 메소드 이름 같고, 메소드의 인수 개수, 유형이 다르면 오버로딩이 가능함.
- 오버라이딩(Overriding)
  - 추상 클래스에서 동일한 메소드명과 인수를 정의해주면, 메소드 안의 프로그램은 상속받은 클래스에서 다양하고 독립적으로 프로그래밍을 할 수 있도록 한다는 개념.



#### 자바스크립트 프로토타입

- 자바스크립트에는  클래스라는 개념이 없음.
- 기존의 객체를 복사하여(cloning) 새로운 객체를 생성하는 프로토타입 기반의 언어임.
- 객체 원형인 프로토타입을 이용하여 새로운 객체를 만들고 이렇게 생성된 객체 역시 또다른 객체의 원형이 될 수 있음.



### UML 다이어그램(중)

#### UML

- Unified Modeling Language. 객체지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어.
- UML의 특징
  - 가시성
  - 명세화
  - 문서화
- UML 구성 요소
  - 사물 (Things) : 구조사물 / 행위사물 / 그룹사물 / 주석사물
  - 관계 (Relationships)
  - 다이어그램 (Diagrams)



#### 구조 다이어그램

- Structure Diagram, 정적 다이어그램

- 클래스 다이어그램(Class Diagram)
- 객체 다이어그램(Object Diagram)
- 패키지 다이어그램(Package Diagram)
- 컴포넌트 다이어그램(Component Diagram) : 
- 복합 구조 다이어그램(Composite structure Diagram) : 컴포넌트나 클래스의 내부 연결 형태를 표현함.
- 배치 다이어그램(Deployment Diagram) : H/W 자원의 연결 표현, 설계 마지막 단계



#### 행위 다이어그램

- Behavior Diagram, 동적 다이어그램

- 유스케이스 다이어그램(Usecase Diagram)
- 상태 다이어그램(State Machine Diagram)
- 활동 다이어그램(Activity Diagram)
- 시퀀스 다이어그램(Sequence Diagram, 순차 다이어그램)
- 통신 다이어그램(Communication Diagram, Collaboration Diagram, 커뮤니케이션 다이어그램, 협력 다이어그램)
- 상호 작용 다이어그램(Interaction Overview Diagram)
- 타이밍 다이어그램(Timing Diagram)

- UML의 관계
  - 연관 관계(Association)
  - 집합 관계(Aggregation)
  - 포함 관계(Composition)
  - 일반화 관계(Generalization)
  - 의존 관계(Dependency)
  - 실체화 관계(Realization)
- UML 확장 모델의 스테레오 타입
  - 기본적 요소 이외에 새로운 요소를 만들어내기 위한 확장 메커니즘
  - '<<>>'(Guillemet, 길러멧) 기호를 사용하여 표현함.



#### 클래스 다이어그램

- Class Diagram
- 클래스와 클래스, 클래스의 속성 사이의 관계를 표현함
- 객체를 생성하기 위한 도구, 틀임.
- 접근 제어 지정자의 기호
  - \+ : public
  - \- : private
  - \# : protected
  - \~ : package



#### 유스케이스 다이어그램

- 사용자 시각에서 소프트웨어 범위와 기능을 설명하는 설계 표기법
- 구조적 분석 방법론에서는 자료 흐름도(DFD), 객체지향 분석 방법론에서는 유스케이스 다이어그램을 사용함.
- 유스케이스는 사용자 시각으로 본 시스템의 행위를 말함.

- 구성요소
  - Actor : 사람모양. 사용자를 나타냄.
  - Usecase : 타원, 시스템의 행동을 나타냄.
  - Relationship : 액터와 유스케이스 연결
- 관계 표현
  - 연관 관계 : 실선
  - 포함 관계 : <\<include>>
  - 확장 관계 : <\<extends>>
  - 일반화



#### 시퀀스 다이어그램

- Sequence Diagram, 순차 다이어그램
- 액터 간의 상호 작용을 시간 순서에 따른 메시지 전달로 표현함.
- 객체 간에 주고받는 메시지의 순서를 시간의 흐름에 따라 보여줌.
- 구조적 설계 방법론에서는 구조도(Structured Chart), 객체지향 설계 방법론에서는 시퀀스 다이어그램을 사용함.
- 구성 요소
  - 객체 : 액터 + 유스케이스
  - 생명선 : 세로 점선
  - 실행 : 세로 사각형
  - 메시지 : 화살표 위에 메시지, 동기식과 비동기식이 있음.
    - 동기식 (synchronous) : 검은 삼각형 화살표. 상호작용을 계속하기 전에 응답을 필요로 함.
    - 비동기식 (asynchronous) : -> 열린 화살표. 응답 필요없음.
    - Reply or Return Message : 열린 화살표 점선.
  - 시간 : 세로 사각형의 길이가 실행 시간임.



#### UML 다이어그램의 관계 표현

- 연관 관계 (Assiciation)
  - 단방향 연관 관계 : 화살표로 표시
  - 양방향 연관 관계 : 실선으로 표시
  - 다중성 표기 1..* : 1 또는 여러 개
- 일반 관계 (Generalization)
  - 상속 관계에 있을 때 빈 삼각형 화살표로 표시함.
  - 한 클래스가 다른 클래스를 포함하는 상하 관계일 때, 일반화 관계가 존재함.
  - 일반화 관계를 "is kind of" 관계라고 함.
- 집합 관계
  - 집약 관계 (Aggregation) : 빈 마름모. 다른 전체 객체와 공유 가능.
  - 합성 관계 (Composition) : 채워진 마름모. 다른 전체 객체와 공유 불가
- 의존 관계 (Dependency)
  - 연관 관계 : 화살표로 표시. 계속적으로 관계 유지할 경우.
  - 의존 관계 : 점선 화살표로 표시. 일시적으로 관계 유지할 경우.
- 실체 관계 (Realization)
  - 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계
  - 인터페이스 관계에 있을 때 표시함
  - 빈 삼각형 점선 화살표로 표시함.
  - "can do this" 관계라고 함.



### 디자인 패턴(Design Pattern)(중)

#### 디자인 패턴

- 장점
  - 개발자들 간의 원활한 의사소통이 가능함.
  - 소프트웨어의 아키텍처(구조)를 파악하기 용이함.
  - 재사용성과 확장성이 좋아 개발 시간을 단축시킬 수 있음.
  - 설계 변경에 따른 유연성, 이식성이 좋아짐.
- 단점
  - 객체지향 개발 위주로만 사용할 수 있음
  - 초기 비용이 많이 듦.



#### GoF 디자인 패턴

- 개념
  - 디자인 패턴을 목적으로 분류할 때 생성, 구조, 행위로 분류할 수 있음.
  - 행위 패턴은 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의함.

- 생성패턴(Creational Pattern)
  - 추상 팩토리(Abstact Factory)
  - 빌더(Builder)
  - 팩토리 메소드(Factory Method)
  - 프로토타입(Prototype)
  - 싱글톤(Singleton)
- 구조패턴(Structural Pattern)
  - 어댑터(Adapter)
  - 브릿지(Bridge)
  - 컴포지트(Composite)
  - 데코레이터(Decorator)
  - 파싸드(Facade)
  - 플라이웨이트(Flyweight)
  - 프록시(Proxy)
- 행위패턴(Behavioral Pattern)
  - 책임연쇄(Chain of Responsibility)
  - 커맨드(Command)
  - 인터프리터(Interpreter)
  - 반복자(Iterator)
  - 중재자(Mediator)
  - 메멘토(Memento)
  - 옵저버(Observer)
  - 상태(State)
  - 전략(Strategy)
  - 템플릿 메소드(Template Method)
  - 방문자(Visitor)



## 4. 프로그램 개발 환경 구축

### 프로그램 개발 환경(하)

### 배치 프로그램(하)

#### 배치 프로그램

- 개념
  - 사용자와의 상호 작용 없이 특정 작업을 작업 단위로 묶어 주기적으로 반복 수행해보거나 정해진 규칙에 따라 일괄 처리하는 것.
  - 대용량의 데이터를 처리함 / 특정 시간에 실행됨 / 일괄적으로 처리함.

- 필수 요소
  - 대용량 데이터
  - 자동화
  - 견고함
  - 안정성
  - 성능



## 5. 명령어와 주소 지정

### 명령어 수행 순서(하)



### 명령어 형식과 주소 지정(하)



## 6. 운영체제

### 운영체제의 개념(상)

#### UNIX

- 개념
  - 상당 부분 C언어 사용. 이식성이 우수함.
  - Linux는 UNIX의 호환 커널임.
  - 사용자는 하나 이상의 작업을 백그라운드에서 수행할 수 있어 여러 개의 작업을 병행 처리할 수 있음.
  - 두 사람 이상의 사용자가 동시에 시스템을 사용할 수 있어 정보와 유틸리티들을 공유하는 편리한 작업 환경을 제공함.
  - 소스를 누구나 볼 수 있도록 설계된 개방형 시스템임.
  - 트리 구조의 파일 시스템을 갖음
  - 이식성이 높으며 장치 간의 호환성이 높음
  - Multi-User, Multi-Tasking 지원.
- UNIX의 기본 구성
  - 커널(Kernel) : 유닉스 시스템이 부팅될 때 가장 먼저 읽혀지는 운영체제의 핵심 부분. 메모리 관리, 입출력 장치 관리 등 하드웨어와 관련된 작업을 수행하는 것으로 사용자들은 커널에 직접 접근할 수 없음.
  - 쉘(Shell) : 사용자 명령의 입력을 받아 시스템 기능을 수행하는 명령 해석기. 사용자와 시스템 간의 인터페이스를 담당함. 사용자와 커널 사이의 중계자 역할.
  - 유틸리티(Utility) : 문서 편집기, 데이터베이스 관리, 컴파일러, 네트워크 기능 등을 제공함.



#### UNIX 명령어

- fork : 프로세스 생성, 복제
- exit : 프로세스 끝마침.
- ls : 파일 목록 보여줌
- cat : 파일 내용을 화면에 출력함.
- cp : 파일 복사
- chmod : 파일 속성 및 Protection 변경
- mkdir(md) : 디렉토리를 생성함.
- pwd : 현재 디렉토리를 출력함.
- chdir(cd) : 현재 디렉토리를 변경함.
- rmdir : 디렉토리 제거
- umask : 파일이나 디렉토리 생성 시 부여되는 기본 허가권을 지정하는 명령. 666



### 프로세스 관리(중)

#### 프로세스

- 개념
  - Process, Job, Task
  - 실행중인 프로그램.
  - 비동기적 행위를 일으키는 주체
  - 운영체제가 관리하는 실행의 단위
  - PCB를 가진 프로그램
- 용어 정리
  - PCB : 운영체제 내에서 한 프로세스의 존재를 정의함.
  - 디스패치 : 준비 상태에서 대기하고 있는 프로세스 중 하나가 CPU를 할당받아 실행 상태로 변하는 시점.
- 프로세스 상태의 종류
  - 제출(Submit)
  - 접수(Hold)
  - 준비(Ready)
  - 실행(Run)
  - 대기(Wait)
  - 블록(Block)
  - 종료(Terminated)



#### PCB

- Process Control Block
- 운영체제 내에서 한 프로세스의 존재를 정의하는 것.
- 여러 개의 프로세스를 수행하는 다중 프로그래밍 환경하에서 각 프로세스를 구분하기 위한 프로세스 제어 블록.
- PCB 테이블은 프로세스들의 현재 상태를 기록한 정보 테이블이며 각 프로세스의 주기억 장치에 적재된 기억 장치 위치 혹은 포인터와 식별자 등이 PCB 항목으로 기록됨.



#### 문맥 교환

- Context Switching
- 다중 프로그래밍 시스템에서 운영체제에 의하여 CPU가 할당되는 프로세스를 변경하기 위하여 현재 CPU를 사용하여 실행되고 있는 프로세스의 상태 정보를 저장하고, 앞으로 실행될 프로세스의 상태 정보를 설정한 다음에 CPU를 할당하여 실행되도록 하는 작업.



#### 프로세스 스케줄링

- 개념
  - 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에 할당하는 작업을 말함.
  - 비선점
    - 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법.
    - 프로세스 응답시간 예측이 용이함. 일괄 처리 방식에 적합함.
    - 중요하지 않은 작업 때문에 중요한 작업이 기다리는 경우가 발생할 수 있음.
    - FCFS, SJF, HRM 등
  - 선점
    - 하나의 프로세스가 CPU 할당받아 사용하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법.
    - 우선순위가 높은 프로세스를 빠르게 처리 가능함
    - 빠른 응답시간을 요구하는 대화식 시분할 시스템에서 사용함
    - 많은 오버헤드를 초래함
    - 선점이 가능하도록 인터럽트용 타이머 클록이 필요함
    - RR, SRT, MLQ, MLFQ 등
- FIFO
  - FCFS, First Come First Service
  - 준비상태 큐에 도착한 순서에 따라 차례로 CPU 할당함
  - 공평성은 유지되지만 중요한 작업이 중요하지 않은 작업을 기다리게 되는 경우 발생함.
- SJF
  - Shortest Job First
  - 실행시간이 짧은 프로세스에 먼저 CPU 할당
  - 가장 적은 평균 대기시간을 제공함.
- HRN
  - Highest Response-ratio Next
  - 실행시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 기법
  - 대기시간과 실행시간을 이용함
  - 우선순위 계산 결과값이 높은 것부터 우선순위를 부여, 대기시간이 긴 프로세스일 경우 계산 결과값이 높게 나옴.
  - 공식 : (대기시간+서비스시간)/서비스시간
- RR
  - Round Robin
    - FIFO를 선점 형태로 변형한 기법
    - 동일한 시간 할당량을 사용하는 시분할 처리 시스템을 위해 고안됨
    - 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당받는 것은 FIFO와 동일함
    - 각 프로세스는 할당된 시간 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에 CPU를 넘겨주고 큐의 가장 뒤로 배치됨
    - 할당되는 시간이 클 경우 FIFO와 같아지고 작을 경우 문맥교환 및 오버헤드가 자주 발생하게 됨

- SRT
  - Shortest Remaining Time
  - SJF 알고리즘을 선점 형태로 변형한 기법
  - 현재 실행중인 프로세스의 남은 시간과 준비상태 큐에 새로 도착한 프로세스의 실행 시간을 비교
  - 가장 짧은 실행 시간을 요구하는 프로세스에 CPU를 할당함.
- MLQ
  - Multi Level Queue, 다단계큐
  - 혼합형. 우선순위가 가장 높은 큐에서는 비선점형, 우선순위가 낮은 큐에서는 선점형으로 사용됨.
  - 프로세스를 특정 그룹으로 분류할 수 있을 경우 그룹에 따라 각기 다른 준비상태 큐를 사용함.
- MLFQ
  - Multi Level Feedback Queue, 다단계 피드백큐
  - 특정 그룹의 준비상태 큐에 들어간 프로세스가 다른 준비상태 큐로 이동할 수 없는 다단계큐 기법을 이동할 수 있도록 개선한 기법



#### 임계구역

- 개념
  - Critical Section, 위험지구
  - 다중 프로그래밍 기법에서 두 개 이상의 프로세스가 운영될 때 서로 공유하게 되는 자원을 말함.



#### 상호배제

- 개념
  - Mutual Exclusion
  - 임계구역을 어느 시점에서 단지 한 개의 프로세스만이 사용할 수 있도록 함.
  - 다른 프로세스가 현재 사용 중인 임계구역에 대하여 접근하려고 할 때 이를 금지하는 행위.
- 상호배제 알고리즘
  - 데커 알고리즘 Dekker's Algorithm
    - 2개의 프로세스를 위한 최초의 정확한 상호배제 해결법.
    - flag, turn 변수 사용
  - 램퍼드 알고리즘
    - 프로세스 n개의 상호 배제 문제를 해결한 알고리즘.
  - 피터슨 알고리즘 Peterson Algorithm
    - 모든 상호 배제를 위한 추가 조건을 만족하고 데커 알고리즘보다 단순함.



#### 세마포어

- 개념
  - Semaphore
  - 상호배제 원리를 보장하는 알고리즘.
  - 잠자기와 꺠우기의 연산을 이용하여 공유자원의 수를 나타내는 변수를 세마포어 변수 S라고 함.
  - P연산과 V연산을 사용함.



#### 교착상태

- 개념
  - DeadLock
  - 복수의 프로세스가 가능하지 못한 상태를 무한정 기다리고 있는 상태를 말함.
- 교착상태 발생 필요 충분 조건 4가지
  - 상호배제(Mutual Exclusion)
    - 프로세스들은 필요로 하는 자원에 대해 배타적인 통제권을 갖음.
    - 임계구역을 두 개 이상의 프로세스가 동시에 접근하지 못하도록 하는 과정에서 발생할 수밖에 없음.
  - 비선점(Non Preemption)
    - 하나의 프로세스가 공유 자원을 사용하는 중에 중단되었을 때, 중단된 프로세스를 선점할 수 없기 때문에 발생할 수밖에 없음.
  - 환형 대기(Circular Wait, 순환 대기)
    - 서로 물고 물리는 상황.
  - 점유와 대기(Hold and Wait)
    - 점유한 프로세스, 대기하는 프로세스가 존재하는 한 교착상태 발생.
- 교착상태 해결 방안
  - 필요악. 제한된 자원에서 여러 개의 프로세스가 운영되는 상황에서는 당장 사용하지 않는 자원을 다른 프로세스가 사용하도록 해야 컴퓨터 시스템을 효율적으로 사용할 수 있음.
  - 교착상태 예방 Prevention
    - 상호배제 부정
    - 비선점 부정 : 가장 현실적이고 실현 가능.
    - 점유와 대기 부정
    - 환형 대기 부정
  - 교착상태 회피 Avoidance
    - 프로세스가 자원을 요구할 때 시스템이 안전 상태를 유지할 수 있는 프로세스의 자원 요구만을 할당하여 주는 방안.
    - 자원 분배를 교착상태가 발생하지 않는 범위 내에서 하는 방안.
    - 은행원 알고리즘이 가장 대표적임.
  - 교착상태 발견 Detection
    - 컴퓨터 중단 원인이 교착상태인지 아니면 다른 이유인지를 파악하는 방안.
    - 자원들과 프로세스들을 인접 행렬로 표현하여 파악함.
  - 교착상태 회복 Recovery
    - 교착상태가 발생한 프로세스 중에 희생양을 정하는 일. 희생양이 정해지면 그 프로세스를 잠시 중단시키고 점유하고 있던 자원을 빼앗음.



#### 은행원 알고리즘



### 기억 장치 관리(중)

#### 고정 분할 할당 기법 (정적 분할)

#### 가상 기억 장치

- 사용하지 않는 프로그램을 외부기억 장치로 옮김으로써 주기억 장치의 실제 크기보다 큰 프로그램을 실행할 수 있게 하는 기억 장치.
- 프로그램을 분할하여 당장 필요한 것만 주기억 장치에 적재하거나 교체하면서 실행할 수 있음.
- 가상 기억 장치 기술의 등장으로 사용자 프로그램의 크기에 제한이 없어짐.
- 프로그램을 작은 크기로 분할할 때, 분할 크기가 모두 똑같다면 페이지(Page), 서로 다르면 세그먼트(Segment)라고 함.
- 



#### 페이징 기법 (Paging)

- 개념
  - 주기억 장치는 4개의 페이지를 적재할 수 있는 공간(페이지 프레임)만 있음.
  - 가상 기억 장치에 있는 프로그램 파일은 50K로 총 13개의 페이지로 분할되었음.
  - 하나의 페이지 크기가 4K이므로 50K/4K=12개, 나머지 2K의 자투리 페이지가 1개 있으므로 총 13개임.
  - 교체되는 페이지 정보는 페이지 사상표에서 갱신됨. (페이지 사상 테이블)
- 관련 용어
  - 스와핑 (Swapping)
  - 페이지 부재 (Page Fault) : 프로그램에서 접근하려고 하는 페이지가 주기억 장치에 없을 때 발생하는 현상. 없으면 디스크 드라이브에게 페이지를 가져오게 하고 페이지 사상표를 갱신하는 작업을 수행함. 이는 오류가 아니라 의도적으로 발생시키는 정상적인 행위임.
  - 스레싱 (Thrashing) : 하나의 프로세스가 작업 수행 과정 중 지나치게 페이지 부재가 발생함으로 인하여 전체 시스템의 성능이 저하되는 현상. 잦은 스와핑으로 프로그램 성능 저하되는 것.
  - 구역성 (Locality) : 어느 한순간에 특정 부문을 집중적으로 참조하는 프로그램의 순차적인 성질. 한 번 호출된 자료나 명령이 곧바로 다시 사용될 가능성을 말함. 페이지를 주기억 장치에 적재할 때 구역성을 고려하면 페이지 부재를 최소화할 수 있음.
  - 작업 집합 (Working Set) : 실행 중인 프로세스가 일정 시간 동안 참조하는 페이지들의 집합임. 자주 참조되는 페이지의 집합으로 주기억 장치에 고정 배치하여 교체 대상에서 제외함으로 교체 성능을 높이는 방법.



#### 반입 전략 (Fetch)

- 프로그램/데이터를 주기억 장치로 가져오는 시기(When) 결정 전략.
- 요구 반입 (Demand Fetch) : 새로 반입된 데이터나 프로그램 언제 주기억 장치로 가져올 것인가 결정하는 방법.
- 예상 반입 (Anticipatory Fetch) : 앞으로 요구될 가능성이 큰 데이터 또는 프로그램을 예상하여 주기억 장치로 미리 옮기는 방법.



#### 배치 전략 (Placement)

- 프로그램/데이터를 주기억 장치 내의 어디로 위치(Where) 시킬 것인가를 결정하는 전략.
- 최초 적합(First Fit)
  - 입력된 작업을 주기억 장치 내에서 그 작업을 수용할 수 있는 첫 번째 공백에 배치.
  - 초기 결정력이 가장 빠름.
  - 운영체제 다음부터가 시작점임.
  - 처음부터 순차적으로 검색하여 적재될 수 있는 공백이면 배치함.
- 최적 적합(Best Fit)
  - 입력된 작업을 주기억 장치 내의 공백 중에서 그 작업에 가장 잘 맞는 공백에 배치함.
  - 내부 단편화가 가장 작거나 없는 공백에 배치함.
  - 가장 잘 맞는 공백을 찾아야 하므로 결정력이 느림.
- 최악 적합(Worst Fit)
  - 입력된 작업을 주기억 장치 내에서 가장 잘 맞지 않는 공백, 즉 가장 큰 공백에 배치함.
  - 내부 단편화가 가장 큰 공백에 배치함.
  - 가장 잘 맞지 않는 공백을 찾아야 하므로 결정력이 느림.
- 최초 적합과 최적 적합 모두 시간 효율성과 공간 효율성 측면에서 최악 적합보다 좋다는 것이 입증되어 있으며, 최악 적합은 잘 사용되지 않음
- scaning time의 유무에 의해 일반적으로 최초 적합이 최적 적합보다 뛰어난 성능을 보여줌.
- 내부단편화 : 남은 공간이 작업보다 커서 프로그램의 사용 공간을 할당 후 사용되지 않고 남게 되는 작은 부분.
- 외부단편화 : 작업보다 많은 공간이 남아 있더라도 실제로 그 작업을 받아 들이지 못하는 경우.



#### 교체 전략 (Replacement, 페이지 교체 알고리즘)

- 개념

  - 주기억 장치에 적재된 페이지들을 대상으로 새롭게 적재될 페이지와 교체할 페이지를 선택하는 전략.

- 적재 예시

  - 처음 페이지가 적재될 때는 페이지 부재가 발생함.

- 종류

  - OPT
    - OPTimal replacement, 최적화 교체 전략
    - 앞으로 가장 오랫동안 사용되지 않을 페이지와 교체함.
    - 페이지 부재 횟수가 가장 적으므로 페이지 적중률이 가장 높음.
    - 실제 알고리즘에서는 미리 확인이 어려움. 이상적이지만 실현 가능성이 희박함

  - FIFO
    - First In First Out 교체 전략
    - 가장 오래 있던 페이지와 교체함
    - 가장 간단한 알고리즘.
    - 페이지 부재 가장 많이 발생함.

  - LRU
    - Least Recently Used 교체 전략
    - 계수기(시간 기억 영역)을 두어 가장 오랫동안 사용하지 않은 페이지를 교체할 페이지로 선택하는 방법.
    - 사용한 지 가장 오래된 페이지를 대상으로 교체함.

  - LFU
    - Least Frequently Used 교체 전략
    - 사용한 횟수가 가장 적은 페이지와 교체함

  - NUR
    - Not Used Recently 교체 전략
    - 최근에 호출하지도 사용하지도 않은 페이지를 제거함.
    - 두 개의 하드웨어 비트인 참조 비트(Referenced Bit)와 변형 비트(Modified Bit)를 사용함

  - Second Chance
    - 이차 기회
    - 가장 오래된 페이지가 최근에 사용할 가능성이 클 것이라는 가정하에 가장 오래된 페이지는 교체 대상에서 제외하고 사용한 것으로 취급함.
    - FIFO의 2차 기회 부여 방법. 2번째로 오래 된 페이지 교체.


  - PFF
    - Page Fault Frequency
    - 워킹 셋에 존재하는 페이지들을 관찰하여 최근에 자주 사용되고 있지 않은 페이지와 워킹 셋에 속하지 않은 페이지 중에 최근에 자주 사용하는 페이지와 교체함.



### 디스크 관리(하)

#### SSTF

#### FCB

#### FAT

- 호환성 우수
- 단순성
- 저용량 볼륨 최적화
- 보안 취약
- 대용량 볼륨 비효율적



#### NTFS

- 대용량 볼륨 지원
- 효율적 사용
- 강력한 보안
- 자동 압축 및 안전성
- 향상된 파일이름 저장 및 파일길이 지원
- 암호화기능 지원
- 윈도우 NT계열 운영체제 외에는 호환 불가
- 저용량 볼륨에서 FAT보다 속도 저하



### 분산 운영체제(하)

#### 스레드 (Thread)

- 프로세스 내에서의 작업 단위 / 경량 프로세스 / 독립적인 스케줄링의 최소 단위 / 실행될 명령어들의 연속.
- 다중 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당 받지만 다중 스레드는 하나의 스레드 내에서 각각 Stack만 따로 할당받고, Code, Data, heap 영역은 공유함.
- 사용자 수준의 스레드
  - 커널 개입이 작음
  - 런타임 시스템이 필요함
  - 속도가 빠름
  - 문맥 교환이 적음
  - 독자적 알고리즘이 필요함
  - 대형 시스템에 적당함
  - 구현이 어려움
  - 커널을 스스로 호출하지 못함
  - CPU 사용을 해제하지 못하면 시스템이 중단됨.
- 커널 수준의 스레드
  - 커널 개입이 큼
  - 런타임 시스템이 필요 없고 커널이 직접함
  - 속도가 느림
  - 문맥 교환이 많음
  - 독자적 알고리즘이 필요 없음
  - 대형 시스템에 부적합함
  - 구현이 쉬움
  - 커널을 스스로 호출함
  - 사용을 해제하지 못하면 운영체제가 지원함.



# 5과목 정보 시스템 구축 관리

IP 프로토콜 필드와 해당 필드에 대한 설명

RIP 라우팅 프로토콜에 대한 설명

UDP 프로토콜

IP 프로토콜의 주요 특징

## 1. 정보 통신의 기초

### 정보 통신(하)

### 데이터 전송의 기초(하)

#### 네트워크 연결 형태 (네트워크 토폴로지)

- 점대점형(Point-to-Point Type)
  - 두 개의 컴퓨터가 하나의 회선을 통해 직접 연결 방식.
- 멀티포인트형(Multi-point Type, Star형)
  - 하나의 컴퓨터가 여러 개의 회선을 통해 단말기에 직접적으로 연결된 방식.
  - 중앙에 호스트 컴퓨터가 있고 이를 중심으로 단말기들이 연결되는 중앙 집중식의 네트워크 구성 형태
  - 허브 연결 형태
- 멀티드롭형(Multi-drop Type, Bus형)
  - 하나의 고속 회선을 통하여 여러 개의 컴퓨터가 연결되어 있는 방식
  - 백본(Backbone)이라는 공유회선에 모든 단말기가 연결되어 있는 구조.
  - 터미네이터가 필요한 버스형 토폴로지는 전송 회선이 단절되면 전체 네트워크가 중단됨
  - 구조가 간단, 설치 용이, 비용 적게 듦
  - 컴퓨터 추가 삭제 쉬움
  - 컴퓨터 무분별하게 추가할 경우 통신 성능 저하
  - 통신 회선의 특정 부분이 고장나면 전체 네트워크에 영향 미침
- 루프형(Loop Type, Ring형)
  - 단말 노드가 양쪽의 컴퓨터와 점대점으로 연결되어 고리처럼 순환형으로 구성된 형태
  - LAN의 기본형에서 가장 많이 사용되는 방법.
  - 한 컴퓨터 절단되어도 우회로를 구성하여 통신 가능한 형태.
  - FDDI가 Ring형을 사용함.
- 망형(Mesh Type, 그물형)
  - 모든 노드가 연결되어 있는 방식
  - 회선 수가 가장 많음
  - 일반적으로 교환기끼리의 연결 구조임
- 트리형(Tree Type)
  - 하나의 부모 컴퓨터와 여러 개의 자식 컴퓨터를 연결한 형태
  - 여러 개의 허브 장비를 이용하여 연결함
- 교환형(Switch Type)
  - 모든 컴퓨터는 하나의 교환기에 접속하여 데이터들을 교환하는 방식.
  - 교환기가 처리할 수 있도록 데이터 수신 컴퓨터의 주소와 데이터 형식, 즉 프레임화해야 함.



## 2. 데이터 전송 제어

### 데이터 전송 제어(하)

#### ARQ

- Stop and Wait ARQ (정지-대기)
  - 한 번에 한 개의 프레임을 전송함
  - 한 개의 프레임을 전송한 후 수신측의 ACK나 NAK를 기다림.
  - ACK가 수신되면 다음 프레임을 전송하고, NAK이면 이전에 보냈던 프레임을 다시 보냄.
  - ACK를 사용하는 방식은 Stop and Wait ARQ뿐이고 나머지 ARQ 방식에서는 NAK만 사용함.
  - 재전송이 있을 수 있으므로 송신측에 버퍼 한 개 필요
  - 수신 확인 후 프레임을 전송하므로 효율이 떨어짐.
- Go-Back-N ARQ
  - 여러 개의 프레임을 전송함. 연속적 ARQ
  - 오류가 발생한 프레임 이후의 모든 프레임을 다시 재전송하는 방식.
  - 수신측의 NAK 신호가 도착하지 않으면 계속적으로 전송함.
  - 수신측 응답이 없으면 긍정적인 응답으로 간주함.
  - 중복 전송 문제 발생
- Selective-Repeat ARQ
  - 여러 개의 프레임을 전송함. 연속적 ARQ
  - 오류가 발생한 프레임만 다시 재전송하는 방식
  - Go-Back-N ARQ 방식의 중복 전송 문제를 보완한 방식.
  - 일부분을 재전송하면 수신측에서는 재결합을 해야 하므로 많은 버퍼가 필요하고 기술적으로 복잡하여 사용 빈도가 낮음.
- Adaptive ARQ (Dynamically ARQ)
  - 동적으로 프레임의 개수를 전송함.
  - 수신측에서는 오류 발생 확률을 송신측에 전송함.
  - 송신측은 적절한 프레임의 개수를 수신측에 동적으로 전송함.
  - NAK 신호가 많으면 프레임의 수를 줄이고, 적으면 프레임의 수를 늘림
  - 전송 효율 높일 수 있지만 기술이 복잡하고 비용이 많이 듦.



#### 정보 통신 기기, 데이터 통신 기기

- 단말 장치
  - DTE, Data Terminal Equipment
  - 통신 시스템과 사용자의 접점에 위치하여 데이터를 입력하거나 처리된 결과를 출력하는 기능을 하는 장치
  - 전화기, FAX, 휴대폰, 리모콘, 컴퓨터 등 다양함.
- 통신 제어 장치
  - CCU, Communication Control Unit
  - 데이터 전송 회선과 컴퓨터를 연결하는 장치
  - 데이터 전송에 관한 전반적인 제어 기능을 수행함.
- 신호 변환 장치
  - DCE, Data Circuit Equipment
  - 단말 장치와 통신 제어 장치를 통신 회선에 접속하는 장치
  - 컴퓨터나 단말 장치의 데이터를 통신 회선에 적합한 신호로 변경하거나 그 반대 기능을 수행
  - 전화기, 모뎀, 코덱, DSU 등
- 전처리기
  - FEP, Front End Processor
  - 호스트 컴퓨터와 단말기 사이에 고속 통신 회선으로 설치함.
  - 통신 회선 및 단말기 제어, 메시지 조랍과 분해, 전송 메시지 검사 등을 수행함.
  - 입력되는 데이터를 컴퓨터의 프로세서가 처리하기 전에 미리 처리하여 프로세서가 처리하는 시간을 줄여주는 프로그램이나 하드웨어를 말함.
- 통신 제어 처리 장치
  - CCP, Communication Control Processor
  - CCU와 마찬가지로 통신 제어 기능을 수행하는데 컴퓨터가 처리하는 메시지 단위의 제어까지 담당하여 컴퓨터 CPU의 부담을 줄여줌.



### 회선 공유 기술(하)

#### 다중화기(Multiplexer)

- 개념
  - 각 단말기에서 요구한 자원을 하나의 고속 통신 회선을 통하여 일정한 시간이나 주파수를 규칙적으로 나누어 사용하는 것.
  - 각 단말기 입장에서는 컴퓨터의 자원을 혼자 사용하는 느낌을 갖게 됨.
  - 공유되는 통신 회선의 채널을 정적으로 배분하여 사용함.
  - 입출력 대역폭이 모두 같음.
  - 집중화기와의 비교
    - 기술 단순함
    - 비용 적게 듦
    - 구성 회로가 간단함
  - 버퍼 필요 없음
  - 다중화기는 동기식 전송임
  - 다중화기는 Hub(분배기)의 원리임.
  - 종류는 FDM, TDM, CDM, WDM 등이 있음.
- FDM
  - Frequency Division Multiplexing, 주파수 분할 다중화기
  - 전송 매체의 대역폭이 클 때 사용하는 다중화기.
  - 단순, 비용 적음
  - 상호 변조 잡음 존재
  - 모뎀 역할을 할 수 있음
  - 공중파, TV, 라디오에서 사용하는 방식.
- TDM
  - Time Division Multiplexing, 시간 분할 다중화기
  - 전송 매체의 유효 전송률이 높을 때 사용하는 다중화기.
  - 기술 복잡, 비용 높음
  - 구성 회로가 복잡함
  - 상호 변조 잡음 존재하지 않음
  - 모뎀 역할 할 수 없음
  - 데이터 통신에서 사용하는 방식임.
- CDM
  - Code Division Multiplexing, 코드 분할 다중화기, 확산 대역 방식
  - FDM, TDM 혼합하여 사용하는 다중화기
  - 이동 통신에서 사용하는 방식.
  - 기존 방식에 비해 10~20배 전송 용량 증가
  - 전송 품질 뛰어남, 보안성 좋음, 전송지연이 감소됨
- WDM
  - Wavelength Division Multiplexing
  - 광섬유를 이용한 다중화 방식.
  - 파장이 서로 다른 복수의 광신호를 동시에 이용함.
  - 빛의 파장 축과 파장이 다른 광선은 서로 간섭을 일으키지 않는 성질을 이용함.



#### 집중화기 (Concentrator)

- 개념
  - 각 단말기에서 요구한 자원을 하나의 고속 통신 회선을 통하여 하나의 단말기만 사용할 수 있도록 제한함
  - 하의 단말기가 고속 통신 회선을 사용하고 있는 동안 다른 단말기에서 요청한 자원은 버퍼에서 대기해야 함.
  - 공유되는 통신 회선의 채널을 동적으로 배분하여 사용함.
  - 집중화기는 비동기식 전송임.
  - 스위치가 사용하는 방식. MAC의 원리.
  - 예약 방식 (Reservation) : 길고 연속적인 데이터 전송에 적당한 방식
  - 경쟁 방식 (Contention) : 점유 신호를 먼저 요구한 한쪽이 송신권을 갖는 방식. 점유 신호가 동시에 발생하면 충돌 발생함. 충돌 발생하면 일정 시간을 기다렸다가 다시 점유 신호를 보냄.
- ALOHA : 하와이 주변 섬들의 관리를 무선을 이용하여 통제한 시스템. 점유 신호가 충돌되는 최초의 시스템
- Slot-ALOHA : 보완 방법. 공유 회선의 채널 수를 컴퓨터의 수에 비례하여 늘리는 시스템
- CSMA : 단말끼리 경쟁하여 접근하는 방식으로 전파 지연 시간을 조절함.
- CSMA/CD : 경쟁 방식의 핵심 기술로 전송량이 적다면 컴퓨터의 개수보다 채널의 수가 적어도 다중화기 수준까지 접근할 수 있는 기술. 이더넷 모델의 MAC 기술. IEEE802.3
- CSMA/CA : 충돌형. 무선 경쟁 방식. IEEE802.11



#### IEEE802

- IEEE 802.3 : CSMA/CD
- IEEE 802.4 : Token BUS
- IEEE 802.5 : Token RING
- IEEE 802.8 : Fiber optic LANs
- IEEE 802.9 : 음성/데이터 통합 LAN
- IEEE 802.11 : 무선 LAN(CSMA/CA)



#### IEEE 802.11

- 802.11e : QoS 강화를 위해 MAC 지원 기능을 채택.
- 802.11f : AP간의 로밍 기능 향상시킨 표준
- 802.11i : 무선랜의 보안 기능 향상
- 802.11h : 전파 간섭 방지 기능 지원
- 802.11ac : 속도
- 802.11ad : 동영상 스트리밍



### 통신망 기술(하)

#### 라우팅 (Routing, 경로 선택)

- 개념
  - 데이터 패킷을 출발지에서 목적지까지 이용 가능한 전송로를 찾아본 후에 가장 효율적인 전송로를 선택하는 기술.
  - 라우터 Router 경로 선택기는 OSI 계층 모델의 네트워크 계층에서 동작하는 장비임.
- 정적 라우팅(Static Routing)
  - 사람이 직접 경로 입력 수동식
- 동적 라우팅(Dynamic Routing)
  - 라우터 장비가 자동으로 라우팅 테이블을 갱신하여 경로 결정
  - 경로 문제 발생 시 우회해서 라우팅할 수 있음.
- IGP(Interior Gateway Protocol, 내부 라우팅 프로토콜)
  - 하나의 게이트웨이에 묶여 있는 네트워크인 AS 내에서 라우팅을 담당하는 프로토콜
- EGP(Exterior Gateway protocol, 외부 라우팅 프로토콜)
  - 서로 다른 AS 사이에 라우팅을 담당하는 프로토콜
- Distance Vector (거리 벡터 라우팅 프로토콜)
  - 라우팅 테이블에 목적지까지 진행하는 경로를 필요한 거리와 방향만을 기록하는 방식.
  - 주변 라우터의 정보만 교환함. 루프 현상 발생. 소문에 의한 라우팅. 전체 네트워크 구성 알지 못함.
- Link State
  - 모든 라우팅 테이블에 목적지까지 진행하는 경로를 SPF 알고리즘으로 기록하는 방식.
  - 모든 정보를 알려줌.
  - 라우팅 테이블이 복잡함.
- RIP
  - Routing Information Protocol
  - 동적 라우팅 - IGP - Distance Vector
  - 매트릭을 이용하여 홉카운트를 계산. 최대 홉카운트 15이하로 제한. 브로드캐스트 방식. 30초마다 라우팅 정보 전달. 180초 갱신 안되면 테이블 삭제.
  - 소규모 네트워크 환경에 적합함
  - Bellman-Ford 알고리즘 사용
- IGRP
  - Internet Gateway Routing Protocol
  - 동적라우팅 - IGP - Distance Vector
  - 필요 정보만 전송하여 회선 부하 감소
  - 중 소규모 네트워크에 적합함
  - 루프 방지하기 위해 일정한 시간 경과하기 전에 새로운 정보 들어올 경우는 무시함
- EIGRP
  - Enhanced IGRP
  - 동적라우팅 - IGP - Link State
- OSPF
  - Open Shortest Path First
  - 동적라우팅 - IGP - Link State
  - RIP 단점 개선
  - 홉카운트 제한 없어 대규모 네트워크에 적합.
  - 대부분 ISP 사용.
  - 라우터 알고리즘 복잡함
  - 가장 많이 사용되는 IGP 라우팅 프로토콜임.
- BGP
  - Border Gateway Protocol
  - 동적라우팅 - EGP
  - AS와 AS 간에 사용되는 프로토콜.
  - 179번 포트를 이용한 TCP 서비스 사용함.



## 3. 통신 프로토콜

### 통신 프로토콜(Protocol)(하)

#### OSI 7계층

- 상위 계층 : 응용 표현 세션
- 하위 계층 : 전송 네트워크 데이터링크 물리

- 물리 계층(Physical Layer)
  - 기계적, 전기적, 기능적, 절차적 기능
  - 통신 케이블, 전송 신호 방식, 물리적 장비
  - 허브, 리피터
- 데이터 링크 계층(Data Link Layer)
  - 오류 제어(검출, 회복), 흐름 제어
  - 프레임 동기(BSC 동기, HDLC 동기, SDLC 동기)
  - 신뢰성 있고 효율적인 프레임 데이터 전송
  - 링크의 효율성 향상(CSMA/CD, Token-Bus, Token-Ring)
  - 전송 제어 기능, 매체 액세스 기능, 브리지, 스위치
  - IEEE 802, Ethernet, HDLC, PPP, LLC

- 네트워크 계층(Network Layer, 망 계층)
  - 패킷 정보 전송, 정보 교환 및 중계 기능, 경로 선택 기능
  - 트래픽 제어 기능, 네트워크 연결 관리, 체증 제어, 라우터
  - IP, ICMP, IGMP, ARP
    - ICMP : IP와 조합하여 통신 중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지를 관리하는 역할을 하는 프로토콜. IP의 동작 과정에서의 전송 오류가 발생하는 경우에 대비해 오류 정보를 전송하는 목적으로 사용함.
  
- 전송 계층(Transport Layer)
  - 전송 연결 설정, 다중화, 집중화, 주소 지정
  - 두 종단(End-to-End)간에 일관성 있는 데이터 전송, 신뢰성 있는 데이터 전송
  - 투명한 데이터 전송, TCP, UDP

- 세션, 표현
- 응용 계층(Application Layer)
  - 사용자
  - E-메일 / HTTP / FTP / SMTP / POP3 / DNS / TELNET




### 인터넷 프로토콜(TCP/IP)(상)

#### TCP/IP 프로토콜

- 응요 계층 / 트랜스포트 계층 / 인터넷 계층 / 링크 계층
- TCP 헤더 : 송수신자의 포트 번호, 순서 번호, 응답 번호 등 전달되는 정보를 파악함.
- IP 헤더 : IP 버전과 송신측 IP, 수신측 IP, 프로토콜의 종류, 서비스 타입 등의 정보가 기억됨. IPv4와 IPv6의 전환 기술 정보가 기억됨.
- MAC 주소 : 네트워크 세그먼트의 데이터 링크 계층에서 통신을 위한 네트워크 인터페이스에 할당된 고유 식별자.



#### TCP

- Transmission Control Protocol, OSI 7계층의 전송 계층. 트랜스포트 계층. TCP 계층
- FTP, Telnet, HTTP, SMTP, POP, IMAP 등
- 통신 수립 : 3단계 핸드셰이킹 (3 way handshaking) : 플래그 비트 SYN, ACK
- 신뢰성 있지만 지연 시간 생김.
- TCP Wrapper
  - 리눅스 또는 BSD 같은 운영체제의 인터넷 프로토콜 서버에서 네트워크 접근을 필터링하기 위해 사용됨.



#### UDP

- User Datagram Protocol
- 개념
  - 신뢰성을 보장하지 않는 비접속형 통신을 제공함.
  - 흐름 제어나 순서 제어가 없어 전송 속도가 빠르지만 신뢰성 있는 데이터 전송에는 부적합함.
  - 하나의 송신 정보를 다수의 인원이 수신해야 할 경우 UDP 사용함.
  - SNMP, DNS, 인터넷 게임, 방송, 증권 등
  - UDP 헤더는 송수신측 포트 주소와 패킷의 길이, 체크섬만 존재함.



#### ARP

- Address Resolution Protocol

- 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적인 주소 (LAN Card 주소)로 번역해주는 프로토콜.
- 반대 (MAC -> IP) RARP



#### IPv4

- 총 32비트, 8비트씩 4부분, 12자리, 약 43억 개. 각 자리 0~255숫자
- NAT(Network Address Translator) : IPv4와 IPv6 변환 담당.
- 호스트 주소를 자동으로 설명하며 유니캐스트, 멀티캐스트, 브로드캐스트를 지원함.
- 클래스별로 네트워크와 호스트 주소의 길이가 다름.
- 클래스
  - A
    - 상위비트 0
    - 네트워크 주소 8바이트
    - ~127.255.255.255
  - B
    - 상위비트 10
    - 네트워크 주소 16바이트
    - ~128.0.0.0 ~ 191.255.255.255
    - 
  - C
    - 상위비트 110
    - 네트워크 주소 24바이트
    - 192.0.0.0 ~ 223.255.255.255

#### IPv6

- 개념
  - 현재 사용되는 IPv4의 주소 부족 문제를 해결하기 위해 개발됨
  - 128비트, 16비트씩 8부분, 16진수로 표기됨,
  - 전송 속도가 IPv4보다 빠름.
  - 등급별, 서비스별로 패킷을 구분할 수 있어 품질 보증이 용이함.
  - 확장 기능을 통해 보안 기능을 기본으로 제공함.
  - 옵션 사용하면 패킷 크기 제한 없음.
  - 주소 자동설정(Auto Configuration) 기능을 통해 손쉽게 이용자의 단말을 네트워크에 접속시킬 수 있음.
- 3가지 유형
  - 유니캐스트 : 1:1 통신을 위한 주소. 하나의 패킷이 하나의 목적지에 전송됨. 인터넷 상의 모든 단말기는 최소한 하나의 유니캐스트 주소를 가져야 함.
  - 애니캐스트 : 단일 송신자와 그룹 내의 단말기 중 가장 가깝거나 가장 접근이 쉬운 단말기에게 정확히 전달되어야 함. 라우터 주소로 사용됨.
  - 멀티캐스트 : 1:N 통신을 위한 주소. 패킷이 단일 발신지로부터 다수의 목적지에 보낼 때, 멀티 캐스트 통신이 이루어짐.
- IPv4와의 차이점
  - 주소 개수 : 43억^4 개 (43억개)
  - 주소 할당 : 네트워크 규모 및 단말기 수에 따른 순차적 할당 (클래스 단위 비순차적 할당)
  - 품질 제어 : 등급별, 서비스별로 패킷을 구분할 수 있어 품질 보장이 용이함(지원 수단 없음)
  - 보안 기능 : 확장 기능에서 기본으로 제공 (IPSec 프로토콜 별도 설치해야 함)
  - 모바일 IP : 용이함 (상당히 곤란함)
  - TCP 헤더 크기 : 40바이트 고정 (20~60 바이트 가변)



#### CIDR

- Classless Inter-Domain Routing, Superneting & Subneting

- 개념
  - IPv4 주소 부족하여 등장한 기술.
  - Classless 클래스 분할 개념 제거함.
  - A, B, C 클래스의 IP 주소 범위와 상관없이 "IP 주소 / 네트워크 비트수"로 지정하며 네트워크 비트수도 늘렸다 줄였다 사용할 수 있음.
  - 예시
    - 54.0.0.0 / 8
    - 193.56.0.0 / 16
    - 211.168.83.0 / 24



### 신기술 동향(중)

#### VoIP

- Voice over internet Protocol
- 컴퓨터 네트워크상에서 음성 데이터를 IP 데이터 패킷으로 변환하여 전화 통화와 같이 음성 통화를 가능케 해 주는 기술.
- 스카이프 같은 인터넷 전화. 디스코드, 페이스타임, 행아웃 등
- mVoIP : 스마트폰에 탑재된 VoIP 기술. 스카이프, 카카오톡, 텔레그램 등



#### 미러 사이트

- Mirror Site
- 접속량이 많은 사이트의 속도 떨어지는 것을 방지하기 위해 세계 도처의 다른 사이트에 자신이 보유하고 있는 것과 동일한 정보를 복사하여 저장시켜 놓는 사이트.



#### 디지털 트윈

- Digital Twin
- 물리적인 사물과 컴퓨터에 동일하게 표현되는 가상 모델
- 물리적인 자산 대신 소프트웨어로 가상화함으로써 실제 자신의 특성에 대한 정확한 정보를 얻을 수 있음.



#### Mesh Network

- Meshnet

- 기존 무선 랜의 한계 극복을 위해 등장함.
- 대규모 디바이스의 네트워크 생성에 최적화되어 차세대 이동 통신, 홈네트워킹, 공공 안전 등의 특수 목적을 위한 새로운 방식의 네트워크 기술임.
- 네트워크를 구성하는 각 노드들이 다른 노드의 작동 가능/ 작동 불가능에 상관없이 항상 네트워크를 가동하는 형태의 구조임.
- 어떤 노드든지, 다른 노드가 작동하는 것과 상관없이 자기 자신은 항상 켜져 있기 때문에 서버 역할을 직접 수행할 수 있음.
- 중앙 서버의 필요성이 매우 낮음.
- 모든 노드가 논리적으로 다른 모든 노드에 곧바로 연결될 수 있음. 또한 바로 이웃이 될 수 있음
- 다른 국을 향하는 호출이 중계에 의하지 않고 직접 접속되는 그물 모양의 네트워크
- 통신량이 많은 비교적 소수의 국 사이에 구성될 경우 경제적이며 간편하지만, 다수의 국 사이에는 회선이 세분화되어 비경제적일 수도 있음.
- 해당 형태의 무선 네트워크의 경우 대용량을 빠르고 안전하게 전달할 수 있어 행사장이나 군 등에서 많이 활용됨.



#### VPN

- Virtual Private Network
- 공용 네트워크를 사설 네트워크처럼 사용할 수 있도록 제공하는 인증 및 암호화 기법



#### Mashup

- 웹에서 제공하는 정보 및 서비스를 이용하여 새로운 소프트웨어나 서비스, 데이터베이스 등을 만드는 기술.
- 원래 있는 정보 활용하기 때문에 투자 비용이 적음.
- 각종 API들을 조합하여 새로운 서비스 제공.
- 기존 서비스에 오류가 발생할 경우 함께 영향을 받는다는 문제점이 존재함.



#### MQTT

- Message Queuing Telemetry Transport
- 사물 인터넷과 같은 대역폭이 제한된 통신 환경에 최적화하여 개발된 푸시 기술 기반의 경량 메시지 전송 프로토콜.
- 메시지 매개자(Broker)를 통해 송신자가 측정 메시지를 발행하고 수신자가 메시지를 구독하는 방식임.
- 현관문 센서, 실내 온도 등의 변화가 생기면 스마트폰으로 그 정보를 알려주는 서비스에 해당됨.



#### Zigbee (직비)

- 소형, 저전력 디지털 라디오를 이용해 개인 통신망을 구성하여 통신하기 위한 표준 기술. IEEE 802.15 표준을 기반으로 만들어짐.
- 메시지 네트워크 방식 이용, 애드혹 네트워크적인 특성 가짐
- 저전력임에도 불구하고 넓은 범위의 통신이 가능함.
- 낮은 수준의 전송 속도만 필요로 하면서 긴 배터리 수명과 보안성을 요구하는 분야에서 사용됨
- 무선 조명 스위치, 가내 전력량계, 교통 관리 시스템 등
- 블루투스나 와이파이 같은 다른 WPAN 기술에 비해 상대적으로 더 단순하고 저렴한 기술을 목표로 만들어짐.



#### Evil Twin Attack

- 특정 AP와 동일한 이름을 가진 가짜 AP를 구축하여 가짜 AP에 접속한 사용자를 대상으로 악성 행위를 수행하는 공격.
- SNS에서 악의적인 사용자가 지인 또는 특정 유명인으로 가장하여 활동하는 공격 기법.



#### N-Screen

- 여러 개의 화면을 통해 콘텐츠를 제공하는 서비스.
- TV, PC, 모바일에서 동일한 콘텐츠를 자유롭게 이용하는 서비스.



#### 스마트 그리드

- 전기 및 정보 통신 기술을 활용하여 전력망을 지능화, 고도화함으로써 고품질의 전력 서비스를 제공하고 에너지 이용 효율을 극대화하는 전력망.



#### Metaverse 메타버스

- 웹과 인터넷 등의 가상 세계가 현실 세계에 흡수된 형태.
- 가상 현실 구현 기술.



#### VLAN

- Virtual LAN, 가상 LAN, Virtual Local Area Network
- LAN을 구성하고 있는 컴퓨터들을 물리적 위치에 관계없이 공통의 요구사항을 갖춘 컴퓨터들을 논리적으로 분할하여 구축하는 네트워크.
- 하나의 물리적인 교환기를 여러 개의 교환기가 있는 것처럼 논리적으로 분할하는 기술
- 브로드캐스트 전파를 제어함으로써 스위치 네트워크의 성능 향상됨. 허브는 안되고 스위치는 됨.



#### PICONET

- 블루투스 기술을 사용하여 연결된 장치 네트워크.
- 네트워크가 설정되면 한 장치가 마스터 역할, 나머지 슬레이브 역할을 함.
- 총 8개까지 연결 가능.



#### SDDC

- Software Defined Data Center
- 모든 인프라가 가상화되는 데이터센터.
- 네트워크 가상화 / 스토리지 가상화 / 서버 가상화



#### TensorFlow

- 텐서플로우
- 인공 지능 응용 프로그램 개발용 오픈소스 프레임워크
- 머신 러닝이나 딥 러닝에 관련한 라이브러리를 지원하여 인공 지능 개발을 쉽게 할 수 있음.
- Python 최적화.



#### SDN

- Software Defined Networking
- 네트워크를 컴퓨터처럼 모델링하여 여러 사용자가 각각의 소프트웨어들로 네트워킹을 가상화하여 제어하고 관리하는 네트워크
- 네트워크 제어부, 데이터 전달부로 분리하여 네트워크 관리자가 보다 효율적으로 네트워크를 제어, 관리할 수 있는 기술
- 기존의 라우터, 스위치 등과 같이 하드웨어에 의존하는 네트워크 체계에서 안정성, 속도, 보안 등을 소프트웨어로 제어, 관리하기 위해 개발됨
- 네트워크 장비의 펌웨어 업그레이드를 통해 사용자의 직접적인 데이터 전송 경로 관리가 가능하고, 기존 네트워크에는 영향을 주지 않으면서 특정 서비스의 전송 경로 수정을 통하여 인터넷상에서 발생하는 문제를 처리할 수 있음.



#### NFS

- Network File System
- 네트워크상에서 공유되는 파일시스템
- 다른 원격 호스트의 파일 시스템을 로컬 디스크에 접근하듯 간단하게 접근하여 자신의 디렉토리처럼 사용할 수 있음.



#### 고가용성

- HA: High Availability
- 긴 시간동안 안정적인 서비스 운영을 위해 장애 발생시 즉시 다른 시스템으로 대체 가능한 환경을 구축하는 매커니즘.
- 가용성 99.9999% 상태.
- 클러스터링과 이중화로 고가용성 달성할 수 있음.
- 설계 방법
  - 고가용성 솔루션(HACMP: High Availability Clustering Multiprocessing)
    - 각 시스템 간에 공유 디스크를 중심으로 클러스터링으로 엮여 다수의 시스템을 동시에 연결할 수 있음.
    - 조직, 기업의 기간 업무 서버 등의 안정성을 높이기 위해 사용될 수 있음.
    - 여러 가지 방식으로 구현되며 2개의 서버를 연결하는 것으로 2개의 시스템이 각각 업무를 수행하도록 구현하는 방식이 널리 사용됨.



#### Honeypot

- 1990년대 David Clock이 처음 제안함.
- 비정상적인 접근의 탐지를 위해 의도적으로 설치해 둔 시스템.
- 침입자를 속여 실제 공격당하는 것처럼 보여줌으로써 크래커를 추적 및 공격 기법의 정보를 수집하는 역할을 함.
- 쉽게 공격자에게 노출되어야 하며 쉽게 공격이 가능한 것처럼 취약해 보여아 함.



#### Li-fi

- 스펙트럼의 빛을 이용한 5세대 이동 통신 기술



## 4. 시스템 보안 구축

### 정보보호(하)

#### 정보보호 3요소 (CIA)

- 기밀성(Confidentiality)
  - 인가된 사용자만이 데이터에 접근할 수 있도록 제한.
  - 방화벽, 패스워드 등
- 무결성(Integrity)
  - 결함(에러, 변조)이 없도록 하는 성질.
  - 인가된 사용자만 수정할 수 있음.
- 가용성(Availability)
  - 인가된 사용자가 원하는 시간이나 장소에서 필요 정보에 접근할 수 있고 사용할 수 있도록 보장하는 성질.
- 추가
  - 부인방지 : 송수신자 간에 전송된 메시지에 대해 송신자는 메시지 송신 사실을, 수신자는 수신 사실을 부인하지 못하도록 함.



#### 소프트웨어 개발 보안

- 개념
  - 정보보안 3요소 지키는 것.
  - 취약점 사전 방지하여 외부 위협과 내부 위협으로부터 위험 최소화



#### 사용자 인증 유형

- 지식 : 본인이 알고 있는 것(패스워드, PIN 등)
- 소유 : 본인이 가지고 있는 것(토큰, 스마트카드 등)
- 존재 : 본인을 나타내는 것(홍채, 지문 등)
- 행위 : 본인이 하는 것(서명, 움직임, 음성 등)



### 시스템 보안(하)

#### 패스워드 솔트

- Salt
- 패스워드를 암호화할 때는 패스워드가 주어지면 랜덤으로 생성되는 솔트(Salt, 소금, 간) 값이 추가되어 해시값을 형성하는 방식.
- 여러 사용자에 의해 중복으로 사용된 동일한 패스워드가 서로 다르게 저장되도록 함.
- 해시 연산 비용이 증가하여 오프라인 사전적 공격(Dictionary Attack)을 어렵게 함.



### 시스템 보안 설계와 구현(하)

#### SSO 인증

- Single Sign On
- 시스템이 몇 대가 되어도 하나의 시스템에서 인증에 성공하면 다른 시스템에 대한 접근 권한도 모두 얻는 방식.



#### 접근 통제 정책

- DAC 정책
  - Discretionary Access Control, 임의 접근 통제
  - 가장 널리 사용되는 모델, 오늘날 대부분 운영체제에서 채택하여 사용하고 있음.
  - 사용자의 신원 정보를 통해 권한의 부여 및 회수에 대한 메커니즘을 기반으로 함.
  - 어떤 사용자가 정보에 접근할 수 있고 어떠한 권한을 가질 수 있는지를 정보의 소유자가 직접 결정할 수 있어 유연성ㅇ ㅣ뛰어남.
- MAC 정책
  - Mandatory Access Control, 강제적 접근 통제
  - 시스템의 사용자들은 자신의 정보에 대한 어떠한 접근 권한도 설정할 수 없음.
  - 중앙에서 정보를 수집하고 분류하여, 각각의 보안 등급을 붙이고 이에 대해 정책적으로 접근 제어를 설정하는 모델.
  - 정보 시스템 내에서 어떤 주체가 특정 객체에 접근하려 할 때 양쪽의 보안 등급에 기초하여 높은 보안 수준을 요구하는 정보가 낮은 보안 수준의 주체에게 노출되지 않도록 접근을 제한하는 통제 방법.
  - top secret의 권한을 가졌다 하더라도 보안 취급 등급이 다르면 해당 정보에 접근할 수 없음.
  - 정부, 군대 시스템에 주로 사용됨.
- RBAC 정책
  - Role-Based Access Control
  - 특정 역할들을 정의하고 각 역할에 따라 접근 권한을 지정하고 제어하는 방식.
  - 조직의 사용자가 수행해야 하는 직무와 직무 권한 등급을 기준으로 객체에 대한 접근을 제어함.



#### Bell-LaPadula(BLP) Model

- 군대의 보안 레벨처럼 정보의 기밀성을 강조하는 최초의 수학적 모델로서 널리 알려진 모델이지만 무결성과 가용성은 대처하지 않음.
- 시스템 보안을 위한 규칙 준수 규정과 주체의 객체 접근 허용 범위를 규정하고 있음.



## 5. 보안 공격 및 예방

### 위험 관리(하)

### 악성 프로그램(상)



#### Smurf Attack

- Smurfing
- DoS의 일종으로 TCP/IP 의 ICMP 의 취약점을 이용하여 공격하는 방법.
- 공격 대상의 컴퓨터가 Ping의 수신측이 되게 하여 대량의 Ping 패킷이 수신되도록 함.
- 다른 네트워크로부터 들어오는 IP Broadcast 패킷을 허용하지 않으면 자신의 네트워크가 Smurf 공격의 중간 매개지로 쓰이는 것을 막을 수 있음.



#### Ping of Death

- 죽음의 핑
- 규정 크기 이상의 ICMP 패킷으로 시스템을 마비시키는 공격.
- ICMP 패킷을 정상 크기보다 훨씬 크게 만들어 공격 대상에게 보내는 공격.
- 정상 크기보다 큰 ICMP 패킷을 작은 조각(Fragment)으로 쪼개어 공격 대상이 조각화 된 패킷을 처리하게 만드는 공격 방법.
- 대응방안으로는 ICMP 패킷을 막는 방법이 있음.



#### Session Hijacking

- 세션 가로채기
- 컴퓨터 시스템의 정보나 서비스에 무단으로 접근하기 위해 유효한 컴퓨터 세션(세션 키라고도 함)을 이용하는 것.
- 일반적인 예로 두 컴퓨터 간에 활성화된 상태(즉, 로그인된 상태)에서 공격자가 피공격자의 로그인 정보를 활용하여 자신에게 필요한 행위를 하는 것을 뜻함.



#### Piggyback Attack

- 회선 간 공격, 간선 공격, 피그백 공격
- 공격자가 다른 사용자의 연결에서 계정을 사용하지 않는 비활성 기간(비활성 간격)을 이용하여 시스템에 액세스함.
- 시스템에 대한 합법적인 권한을 가진 사용자가 시스템에 접근할 때, 활성화된 기간에는 접근 권한이 없는 공격자가 비활성화된 기간에 마치 사용자와 관련있는 사람인 듯이 태그를 붙여 몰래 뒤따라 들어가는 것.



#### 버퍼 오버플로우 공격

- 컴퓨터 프로그램의 입력값 크기를 제한하지 않았거나 입력값의 크기를 확인하는 과정을 설정하지 않았을 때 발생하는 취약점을 이용하는 공격.
- 버퍼에 할당된 메모리의 경계를 침범해서 데이터 에러가 발생하게 되는 상황.



#### 스택 가드

- SG : Stack Guard
- 버퍼 오버플로우 공격 차단 방법으로 메모리상에서 프로그램의 복귀 주소와 변수 사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술.
- 카나리(Canary)라고 불리는 무결성 체크용 값을 복귀 주소와 변수 사이에 삽입하여 스택에 복구 주소가 변경되었는지 확인함.



#### Key Logger Attack

- 컴퓨터 사용자의 키보드 움직임을 탐지해 ID, 패스워드 등 개인의 중요한 정보를 몰래 빼가는 해킹 공격.



#### XSS(Cross-Site Scripting)

- 웹 페이지에 악의적인 스크립트를 포함시켜 사용자 측에서 실행되게 유도함으로써, 정보 유출 등의 공격을 유발할 수 있는 취약점
- 사용자의 세션을 가로채거나, 웹사이트를 변조하거나, 악의적 콘텐츠 삽입하거나, 피싱 공격을 진행할 수 있음.
- 공격 대상 : 스크립트 언어와 취약한 코드



#### Ransomware

- 인터넷 사용자의 컴퓨터에 침입해 내부 문서 파일 등을 암호화해 사용자가 열지 못하게 하는 공격으로 암호 해독용 프로그램의 전달을 조건으로 사용자에게 돈을 요구하는 악성 프로그램



#### Pharming

- 사용자가 자신의 웹 브라우저에서 정확한 웹 페이지 주소를 입력해도 가짜 웹 페이지에 접속하게 하여 개인정보를 훔치는 것을 말함.
- 악성 코드에 감염된 pc를 조작해 이용자가 인터넷 즐겨찾기 또는 포털사이트를 통해 금융회사 홈페이지에 접속하여도 피싱 사이트로 유도됨.



#### Phishing

- 특정 웹 사이트를 가짜로 개설하여 기존 이용자들에게 접근하도록 한 후 정보를 빼내는 악의적인 기술
-  **피싱**(phishing)은 전자우편 또는 메신저를 사용해서 신뢰할 수 있는 사람 또는 기업이 보낸 메시지인 것처럼 가장함으로써, 비밀번호, 신용카드 정보와 같이 기밀을 요하는 정보를 부정하게 얻으려는 소셜 엔지니어링(social engineering)의 한 종류.
  - spear phishing : 스피어 피싱, 특정 개인이나 회사 대상으로 시도하는 피싱.
  - clone phishing : 클론 피싱, 링크나 첨부파일이 포함된, 과거에 전달된 적법한 이메일에 거의 동등하거나 복제된 이메일을 만드는데 사용되는 수신자 주소와 내용이 포함되어 있는 경우.
  - whaling : 웨일링, 여러 피싱 공격이 고위 경영 간부와 비즈니스 내 기타 고위직을 대상으로 이루어졌으며 이러한 종류의 공격을 뜻함.
  - Smishing : 스미싱, SMS와 피싱의 혼합어, 오해의 소지가 있는 문자 메시지로 피해자를 속이고 정보를 빼오는 사이버 공격.
  - Qshing : QR 코드를 통해 악성 사이트로 이동하게 하거나 악성 앱을 다운로드하도록 유도하는 공격



#### TFN 공격

- Tribe Flood Network 공격
- UDP/TCP SYN Flooding을 이용
- Trinoo와 거의 유사한 분산 도구로 많은 소스에서 하나 혹은 여러 개의 목표 시스템에 대해 서비스 거부 공격을 수행함.



#### TearDrop

- 네트워크 프로토콜 스택의 취약점을 이용한 공격 방법으로 시스템에서 패킷을 재조립할 때, 비정상 패킷이 정상 패킷의 재조립을 방해함으로써 네트워크를 마비시키는 공격.



#### Worm

- 웜, 다른 프로그램에 감염되어 전파되는 컴퓨터 바이러스와는 달리 자체적으로 실행되면서 다른 컴퓨터에 전파가 가능한 프로그램.
- 스턱스넷(Sutxnet) : 2010년 6월에 발견된 웜 바이러스, 윈도우를 통해 감염, 지맨스산업의 SW 및 장비를 공격.



#### Rogue Ware

- Rogue security software, 가짜 백신 소프트웨어
- 사용자가 컴퓨터에 바이러스가 있다고 잘못 믿게 하고 컴퓨터에 실제로 악성 프로그램을 설치토록 하거나, 가짜 악성 프로그램 제거 도구에 대한 비용을 지불하도록 설득함.
- 공포심을 통해 사용자를 조종함.



#### Adware

- 특정 소프트웨어를 실행할 때 또는 자동으로 활성화되는 광고프로그램으로 이 자체는 악성 코드로 보기는 힘들지만, 무분별한 광고 팝업을 뜨게 하는 등의 악용 위험성으로 악성 코드로 분류되기도 함.



#### Reflection Attack

- 반사공격
- 송신자가 생성한 메시지를 가로챈 공격자가 그 메시지를 다시 송신자에게 재전송하여 접근 권한을 얻는 형태의 공격 방법.



#### FTP Flooding

- TCP의 3 way handshake 취약점을 이용한 DoS 공격으로 다량의 SYN 패킷을 보내 백로그큐를 가득 채우는 공격.
- 통상적으로 위의 공격법을 TCP SYN Flooding 이라고 칭하는 경우가 많음.
- FTP 프로토콜을 사용한 서버에 다량의 SYN 패킷을 보내 마비시키는 것을 FTP Flooding 이라고 볼 수 있음.
- SYN Flooding은 존재하지 않는 클라이언트가 서버별로 한정된 접속 가능 공간에 접속한 것처럼 속여 다른 사용자가 서비스를 이용하지 못하게 하는 것.



#### Bluetooth Attack

- 블루버그 BlueBug : 블루투스 장비사이의 취약한 연결 관리를 악용한 공격
- 블루스나프 BlueSnarf : 블루투스의 취약점을 활용하여 장비의 파일에 접근하는 공격으로 OPP를 사용하여 정보를 열람.
  - OPP(Obex Push Protocol) : 블루투스 장치끼리 인증 없이 정보를 간편하게 교환하기 위하여 개발됨.
- 블루재킹 BlueJacking : 블루투스를 이용해 스팸처럼 명함을 익명으로 퍼뜨리는 것.
- 블루프린트 BluePrinting : 블루투스 공격 장치의 검색 활동을 의미.



#### Land

-  Land 공격은 패킷 전송 시 출발지 IP주소와 목적지 IP주소 값을 똑같이 만들어서 공격 대상에게 보내는 공격 방법.



### 정보보호 대책(하)

#### Secure OS

- 개념
  - 컴퓨터 운영체제의 커널에 보안 기능을 추가한 것
  - 운영체제의 보안상 결함으로 인하여 발생 가능한 각종 해킹으로부터 시스템을 보호하기 위하여 사용됨.
- 기능
  - 식별 및 인증
  - 임의적 접근 통제(DAC) / 강제적 접근 통제(MAC)
  - 객체 재사용 보호
  - 완전성 조정
  - 신뢰 경로
  - 감사 및 감사 기록 축소

#### 스크린 서브넷 게이트웨이 구조

- Screen-Subnet Gateway
- 베스천 호스트 양쪽에 패킷 필터링 라우터를 설치한 후 외부 쪽에 LAN 카드를 설치함.
- 다단계 보안 제공. DMZ라는 완충 지역 개념 이용.
- 방화벽에 의해 보호받지 않는 영역을 DMZ라고 하며 특별히 외부로 노출되어야 할 서버들은 DMZ에 위치함.
- 스크린 라우터 2개, 네트워크 카드 1개 사용함.
- 이중 홈 게이트웨이 : 네트워크카드2개
- 스크린 호스트 게이트웨이 : 패킷 필터링 라우터 추가



#### IDS

- Intrusion Detection System, 침입 탐지 시스템
- 네트워크에서 허가되지 않은 비정상적인 행동을 탐지하고, 불법적인 행위와 침입 여부를 확인한 후, 이에 대응할 수 있는 기능을 가진 보안 시스템.



#### 백도어 탐지 기법

- 백도어는 시스템 접근에 대한 사용자 인증을 거치지 않고, 응용 프로그램 또는 시스템에 접근할 수 있도록 하는 조치를 말함. 백도어는 시스템 관리자가 패스워드를 잃어버리게 된느 경우처럼 만약을 대비하여 언제든 시스템에 접근할 수 있도록 조치를 취하는 것.
- 동작 중인 프로세스와 열린 포트 확인
- SetUID 파일 검사 : 일반 사용자에게 특정 파일을 잠시 동안 루트 권한으로 사용할 수있도록 하는 명령.
- 백도어 탐지 도구 사용 : COPS
- 무결성 검사
- 로그 분석



#### 스캐너 도구

- SAINT
- SATAN
- PortSentry
- NMAP
- Nessus
- CGI scanner



#### SSH

- Secure Shell
- TCP 프로토콜에 보안 채널(터널링)을 구축하여 여러 응용 프로토콜이 보안 채널을 통해 안전하게 데이터를 교환하기 위한 보안 프로토콜.



#### 무결성 검사 도구

- Tripwire
- TAMU
- trojan.pl
- Hobgoblin
- fcheck



## 6. 암호 기술

### 암호 기술(하)

#### 암호 관련 용어

- 평문(Plaintext) : 송수신측 사이에서 주고받고자 하는 일반적인 문장으로 누구나 알아볼 수 있는 문장을 말함. 암호화의 대상이 되는 문장.
- 암호문(Ciphertext) : 송수신측 사이에서 평문의 내용을 허가받지 않은 제3자가 이해할 수 없도록 변형한 형태.
- 암호화(Encryption) : 평문을 암호문으로 만드는 과정. 암호화는 송신측에서 수행함.
- 복호화(Decryption) : 암호문 -> 평문. 복호화는 수신측에서 수행함.
- 키(Key) : 암호화, 복호화 과정에서 사용하는 파라미터. 암호화 키, 복호화 키
- 알고리즘 : 암호화/복호화 과정에서 사용하는 수학적인 기능이나 규칙을 알고리즘이라고 함.
- 인증(Authentication) : 수신측에서 받은 정보가 원래의 송신측에서 전달된 것임을 확인하는 과정으로 공격자가 송신측으로 가장할 수 없도록 하는 과정. 정보의 기밀성, 무결성, 부인방지를 보장함. 자신의 신원(Identity)을 시스템에 증명하는 과정. 아이디와 패스워드를 입력하는 과정이 가장 일반적인 예시라고 볼 수 있다.
- 인가(Authorization) : 사용자의 권한 부여 방법으로 특정 시스템의 사용 권한을 부여하는 것.
- 암호화 프로토콜(Encryption Protocol) : 믿을 수 없는 두 개체 간에 정보를 확인하고 안전하게 전달하기 위한 통신 규약.



#### 대칭 암호

- 단일 키 사용함. 대칭키 사용.
- 비대칭 암호에 비해 키 길이가 짧음.
- 훨씬 빠르며 적은 연산 능력을 필요로 함.
- 키 배포가 주된 약점. 악의적 행위자가 키를 가로채면 암호화된 정보에 접근할 수 있음.
- 대표적인 예 : SEED, DES, DES3, AES, IDEA



#### 공개키 기반 구조

- PKI : Public Key Infrastructure. 비대칭 암호 기법
- 네트워크 환경에서 보안 요구사항을 만족시키기 위해 공개키 암호화 인증서 사용을 가능하게 해 주는 기반 구조.
- 공개키 암호화 방식을 바탕으로 한 인증서를 활용하는 소프트웨어, 하드웨어, 정책 및 규칙 등을 총칭하여 일컫는 말.
- 키 분배가 용이하고, 관리해야 할 키 개수가 적음.
- RSA 알고리즘 주로 공개키 암호화 방식에서 키 생성을 위해 사용함.
- 공개키 암호 방식을 이용한 전자서명 순서
  - A와 B는 개인키와 공개키의 쌍을 각각 생성함.
  - A는 A의 개인키를 사용하여 암호화된 메시지를 B에게 전송함
  - B는 A의 공개키를 사용하여 수신된 메시지를 해독함.



#### 하드 코드된 암호화 키

- 암호화 키가 프로그래 소스에 상숫값으로 존재하여 암호화에 사용이 되는 경우.
- 소스 파일이나 실행 파일이 유출되었을 경우 암호화 키도 같이 유출되어 공격의 대상이 될 수 있음.
- 암호화 키는 별도로 암호화하여 저장하거나 매번 키로 입력하여 사용함.



####  해시 함수

- 일정치 않은 길이의 평문이나 메시지 문자열을 고정된 길이의 문자열(평문 다이제스트)로 만들어주는 함수를 말함.
- 디지털 서명 알고리즘의 서명 단위가 제한되어 있어 대응하기 위해 사용함.
- 해시 함수는 일방향 함수(One-way Function)임.
- 대표적인 해시 알고리즘으로 HAVAL, SHA-1 등이 있음.



### 블록 암호와 스트림 암호(하)

#### 블록 암호

- 평문을 일정한 단위인 블록으로 나누어서 단위마다 암호화 과정을 수행하여 암호문을 얻는 방법.
- 고정된 길이의 입력 블록을 고정된 출력 블록으로 암호화하는 방식.
- 블록 길이 정해져 있어 기호의 삽입, 삭제가 불가능함.



#### Feistel 암호 구조

- 개념
  - 평문을 2개의 블록으로 나누어 암호화.
  - 암호화 과정과 복호화 과정 동일함.
  - 입력을 좌우 블록으로 분할하여 한 블록을 라운드 함수에 적용시킨 후에 출력값을 다른 블록에 적용하는 과정을 반복적으로 시행하는 것.

- 종류
  - DES : 평문을 64비트로 블록화하여 초기 치환함.
  - SEED : 우리나라 개발. 128비트 고정키, 128비트 블록 암호화.
  - IDEA : 국제 데이터 암호화 알고리즘.  64비트 블록에 고정된 128비트 키 이용. 8라운드 구성.
  - CAST-128
  - BLOWFISH




#### SPN 암호 구조

- 대입과 치환을 이용한 망 구조.
- 암호화 과정과 복호화 과정이 다름.
- 암호를 풀기 위해서는 별도의 복호화 키 필요함.



#### 스트림 암호

- 키 스트림의 한 비트와 평문의 한 비트가 XOR하여 암호화를 수행함.
- 작고 알고리즘 구현 속도가 빨라 실용적임. 휴대폰이나 컴퓨터 능력이 적게 사용되는 환경에 적합함.
- 스트림 암호의 키는 공개될 수 없고 한 번 사용된 알고리즘은 다시 사용할 수 없는 일회용으로 사용됨.



### 전자서명(하)

#### RSA 디지털 서명

- 공개키 암호 알고리즘을 이용한 디지털 서명 기법.
- 적절한 시간 내에 인수가 큰 정수의 소인수 분해 문제를 이용한 공개키 암호화 기법에 널리 사용되는 암호 알고리즘 기법임.



#### HSM

- Hardware Security Module
- 보안 토큰.
- 암호화, 복호화, 전자서명 등을 빠르게 수행, 생성, 보관할 수 있는 하드웨어 장치.
- 내장된 장치를 통해 암호화 키 생성 및 검증이 가능.
- 공인인증서의 발급 없이 로그인 과정이 보안 토큰 내에서 이루어짐.
- 비밀번호 설정 및 입력 오류 횟수를 제한
- 무결성을 스스로 확인
- 클라우드 HSM : HSM + 클라우드 서비스 배포 관련 이점 제공됨. HSM as a Service



### 네트워크 보안 기술(하)

#### SSL

- Secure Socket Layer
- 웹 서버와 웹 브라우저에서 전달되는 데이터를 안전하게 송수신할 수 있도록 개발된 프로토콜.
- 서버와 클라이언트 간에 키 교환 방법을 제공함.
- 세션 계층에서 동작함.
- 기밀성 / 무결성 / 인증 지원하지만 부인방지 제공 안됨



#### IPSec

- IP Security
- IP 패킷의 보안 프로토콜로 패킷을 제거하거나 삽입을 불가능하게 하는 보안 기술.
- 스푸핑, 스니핑 등에 대한 취약점 때문에 개발됨.
- 네트워크 계층에서 동작함



#### S-HTTP

- Secure-HyperText Trasfer Protocol
- HTTP에 보안 기능을 부가하기 위한 통신 규약으로 WWW를 이용할 때 웹 페이지의 데이터를 안전하게 주고받을 수 있게 만든 프로토콜.
- SSL은 TCP를 이용하는 응용 프로토콜도 사용 가능하지만 S-HTTP는 HTTP를 사용한 애플리케이션에 대해서만 보호가 가능함.



#### Network Mapper

- 네트워크 보안을 위한 유틸리티.
- 네트워크의 보안을 위해 물리적 연결과 어떤 서버와 운영 체제가 작동 중인지 따위를 조사하는 응용 프로그램



### 인터페이스 보안(하)



### 정보 추적 기술(중)

#### DRM

- 개념
  - 디지털 저작권 관리. Digital Right Management
  - 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술을 말함.
  - 디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 하드웨어 제조업자, 저작권자, 출판업자 등이 사용할 수 있는 접근 제어 기술을 의미함.
  - 디지털 미디어의 생명 주기 동안 발생하는 사용 권한 관리, 과금, 유통 단계를 관리하는 기술.
- 구성 요소
  - 클리어링 하우스(Clearing House) : 저작권에 대한 사용 권한, 라이선스 발급, 사용량에 따른 관리 등을 수행하는 곳
  - 콘텐츠 제공자(Content Provider) : 콘텐츠를 제공하는 저작권자 ex)작곡가
  - 패키저(Packager) : 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
  - 콘텐츠 분배자(Content Distributor) : 암호화된 콘텐츠를 유통하는 곳이나 사람 ex)멜론
  - 콘텐츠 소비자(Customer) : 콘텐츠 사용 주체 ex) 멜론 이용자
  - DRM 컨트롤러(DRM Controller) : 배포된 콘텐츠의 이용 권한을 통제하는 프로그램 ex) 멜론 이어
  - 보안 컨테이너(Security Container) : 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치
- DRM의 기술 요소
  - 암호화 기술
  - 암호화 파일 생성
  - 키 관리
  - 식별 기술
  - 저작권 표현
  - 정책 관리
  - 크랙 방지
  - 인증
  - 인터페이스
  - 이벤트 보고
  - 사용 권한
