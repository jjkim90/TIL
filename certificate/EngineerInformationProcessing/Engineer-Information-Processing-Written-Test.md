1-18



# 1과목 소프트웨어 설계

## 1. 소프트웨어의 종류 및 개발 방법론

### 소프트웨어 분류 및 특성(중)

#### 시스템 소프트웨어

- 시스템의 기본 요소



#### 플랫폼

- 플랫폼의 성능 특성 분석 항목 : 가용성, 응답 시간 등등등



#### 프레임워크

- 프레임워크 적용할 경우 기대 효과



#### 컴포넌트

- CBD



#### 소프트웨어 공학



### 소프트웨어 개발 방법론(상)



#### 미들웨어

- 개념
  - 미들과 소프트웨어의 합성어
  - 운영체제와 해당 운영체제에서 실행되는 응용 프로그램 사이에서 운영체제가 제공하는 서비스 이외에 추가적인 서비스를 제공하는 소프트웨어
  - 클라이언트와 서버 간의 통신을 담당하는 소프트웨어
  - 시스템 간의 데이터 교환에 일관성을 보장함
  - 여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어
  - 소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공함
  - 여러 컴포넌트를 1대1, 1대다, 다대다 등 여러 가지 형태로 연결이 가능함.
  - 이기종 하드웨어, 소프트웨어, 네트워크, 프로토콜, PC 환경, 운영체제 환경 등에서 시스템 간의 표준화된 연결을 도와주는 소프트웨어임.
- **미들웨어의 종류**
  - DBMS(Database Management System, 데이터베이스)
    - 데이터베이스 벤더에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어
    - DB를 사용해 시스템을 구축하는 경우 보통 2-Tier 아키텍처라고 함
    - 마이크로소프트 ODBC, 볼랜드의 IDAPI, 오라클의 Glue
  - RPC(Remote Procedure Call, 원격 프로시저 호출)
    - 응용 프로그램의 프로시저를 사용해 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어.
    - 이큐브 시스템즈의 Entera, OSF의 ONC/RPC
  - MOM(Message Oriented Middleware, 메시지 지향 미들웨어)
    - 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어
    - 온라인 업무보다 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용됨.
    - IBM의 MQ, 오라클의 Message Q, JPC의 JMS
  - TP-Monitor(Transaction Processing Monitor, TP모니터)
    - 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션을 처리 및 감시하는 미들웨어
    - 사용자 수가 증가하더라도 빠른 응답속도를 유지해야 할 경우 주로 사용됨.
    - 오라클의 tuxedo, 티맥스소프트의 tmax
  - ORB(Object Request Broker, 객체 요청 브로커)
    - 객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현한 미들웨어
    - TP-Monitor의 장점인 트랜잭션 처리와 모니터링을 추가한 제품도 나오고 있음.
  - WAS(Web Application Server, 웹 어플리케이션 서버, 와스)
    - 정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위한 미들웨어
    - 클라이언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어임
    - HTTP 세션 처리를 위한 웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현이 가능함.
    - 오라클의 WebLogic, IBM의 WebSphere



#### DBMS



#### WAS

- 종류



#### 소프트웨어 개발 방법론

- 구조적 방법론
  - 프로세스 중심의 하향식 방법론
  - 복잡한 문제를 다루기 위해 분할과 정복(Divide and Conquer) 원리를 적용함.
  - 구조적 프로그래밍 표현을 위해 나씨-슈나이더만 차트를 사용한다.
- 정보공학 방법론
  - 정보 시스템 개발에 필요한 절차와 작업 기법을 체계화한 방법론
  - 개발주기를 이용해 대형 프로젝트를 수행하는 체계적인 방법론
  - 정보공학 방법론에서 데이터베이스 설계의 표현으로 사용하는 모델링 언어는 E-R 다이어그램
- 객체지향 방법론
  - 객체라는 기본 단위로 시스템을 분석 및 설계하는 방법론
- 컴포넌트 기반 방법론(CBD, Component Based Development)
  - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
  - 개발 기간 단축으로 인한 생산성 향상
  - 새로운 기능 추가가 쉬운 확장성
  - 소프트웨어 재사용이 가능
- 애자일 방법론
  - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론
- 제품 계열 방법론(Product Line Development)
  - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
- 나씨-슈나이더만(Nassi-Shneiderman) 차트
  - 논리의 기술에 중점을 둔 도형식 표현 방법
  - 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현함
  - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합함.



#### 객체지향

- 개념
  - 현실 세계의 개체(Entity)를 기계 부품처럼 하나의 객체(Object)로 만들어, 기계적인 부품들을 조립해 제품을 만들듯이 소프트웨어를 개발할 때에도 객체들을 조립해서 작성할 수 있는 기법
  - 소프트웨어의 재사용 및 확장 용이, 유지 보수 쉬움
  - 복잡한 구조를 단계적 계층적으로 표현
- 객체(Object)
  - 데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 소프트웨어 모듈
  - 데이터 = 속성, 상태, 변수, 상수, 자료구조
  - 함수 = 메소드, 서비스, 동작, 행위
  - 독립적으로 식별 가능한 이름을 가짐
  - 객체가 가질 수 있는 조건 = 상태(State)
- 클래스(Class)
  - 공통된 속성과 연산을 갖는 객체의 집합, 객체의 일반적인 타입을 의미
  - 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
  - 클래스에 속한 각각의 객체 = 인스턴스(Instance)
  - 동일한 클래스에 속한 각각의 개체들은 공통된 속성과 행위를 갖음
- 캡슐화(Encapsulation)
  - 데이터와 데이터를 처리하는 함수를 하나로 묶은 것을 의미
  - 불필요한 기능 최소화
  - 소프트웨어 개발 비용 절감
  - 개발 속도 향상
- 상속(Inheritance)
  - 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려 받는 것
  - 하위 클래스는 상위 클래스로부터 받은 속성과 연산 외에도 새로운 것을 첨가할 수 있음.
  - 소프트웨어의 재사용을 높이는 중요한 개념임
  - 다중 상속 : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속 받는 것
- 다형성(Polymorphism)
  - 하나의 메시지에 대해 여러 가지 형태의 응답이 있는 것.
  - 하나의 메시지에 대해 각 객체가 갖고 있는 고유한 방법대로 응답하는 것을 의미함
  - 하나의 클래스나 메소드가 다양한 방식으로 동작이 가능한 것을 의미함.
  - 오버로딩과 오버라이딩이 존재함.
    - 다형성의 오버라이딩 : 상속 관계에서 상위 클래스 메소드를 하위 클래스에서 재정의하는 것
    - 다형성의 오버로딩 : 하나의 클래스 내에서 같은 이름으로 여러 개 메소드 정의

- 정보은닉(Information Hiding)
  - 캡슐화에서 가장 중요한 개념으로 다른 객체에 자신의 정보를 숨기는 것을 말함.

  - 연산만을 통해 접근을 허용함

  - 각 객체의 수정이 다른 객체에 주는 Side Effect를 최소화하는 기술임

- 추상화(Abstraction)
  - 불필요한 부분을 생략, 객체 속성 중 가장 유용한 것에 중점을 두어 모델화하는 것을 말함.

  - 완전한 시스템 구축 전, 그 시스템과 유사한 모델을 만들어 여러 요인들을 테스트할 수 있음.




#### 애자일

- 개념

  - 애자일 방법론은 소프트웨어 개발방법론의 하나로 개발과 함께 즉시 피드백을 받아서 유동적으로 개발하는 방법

- 특징

  - 프로젝트의 요구사항은 기능 중심으로 정의
  - 절차와 도구보다 개인과 소통을 중요하게 생각
  - 작업 계획을 짧게 세워 요구 변화에 유연하고 신속하게 대응
  - 소프트웨어가 잘 실행되는 데 가치를 둠
  - 고객과의 피드백을 중요하게 생각

- 애자일 선언문

  - 공정과 도구보다 개인과 상호작용
  - 계획을 따르기보다 변화에 대응하기
  - 포괄적인 문서보다 동작하는 소프트웨어
  - 계약 협상보다 고객과의 협력

- 애자일 방법론 유형

  - 익스트림 프로그래밍
    - XP(eXtreme Programming) 기법
    - 애자일 방법 중 제일 많이 알려진 기법
    - 소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법
    - 익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것.
    - 5가지 핵심가치 (피존의용단)
      - 용기
      - 단순성
      - 의사소통
      - 피드백
      - 존중
    - XP 개발 프로세스
      - 사용자 스토리
      - 릴리즈 계획 수립
      - 스파이크 : 간단한 프로그램. 처리할 문제 외의 다른 조건 모두 무시
      - 주기(Iteration) : 1~3주 정도의 기간으로 진행.
      - 승인 검사(인수 테스트) : 고객이 직접 수행. 오류 발견시 다음 이터레이션에 포함
      - 소규모 릴리즈
    - XP의 주요 실천 방법
      - Pair Programming(짝 프로그래밍) : 책임 분산
      - Test-Driven Development(테스트 주도 개발)
      - Whole Team(전체 팀)
      - Continuous Integration(계속적인 통합) : 모듈 하나 마무리될 때마다 지속적 통합
      - Design Improvement(Refactoring, 리팩토링) : 기능 변경 없이 재구성
      - Small Release(소규모 릴리즈)
      - 40-Hour Work
      - On Site Customer(고객 상주)
      - Collective Ownership(공통 코드 소유)
  - 스크럼(SCRUM)
    - 팀이 중심이 되어 개발의 효율성을 높인다
    - 제품 책임자(PO, Product Owner) : 개발 의뢰자, 백로그 작성
    - 스크럼 마스터(SM, Scrum Master) : 조언. 진행 사항 점검. 장애 요소 공론화
    - 개발팀(DT, Development Team) : PO, SM 제외한 모든 팀원, 백로그 우선순위x
    - 스크럼 개발 프로세스
      - 제품 백로그(Product Backlog)
      - 스프린트 계획회의(Sprint Planning Meeting)
      - 스프린트(Sprint)
      - 일일 스크럼 회의(Daily Scrum Meeting)
      - 스프린트 검토 회의(Sprint Review)
      - 스프린트 회고(Sprint Retrospective)

  - 린(LEAN)
    - 도요타의 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론
    - 린의 7가지 원칙(낭품지 확인사전)
      - 낭비제거
      - 품질 내재화
      - 지식 창출
      - 늦은 확정
      - 빠른 인도
      - 사람 존중
      - 전체 최적화



#### 테일러링

- 필요성 내부기준 외부기준



#### 보안 개발 방법론

- MS-SDL, Seven Touchpoints 등



### 프로젝트 관리 및 생명주기 모형(상)

#### 인적 자원

- 개발자팀 구성 / 책임 프로그래머팀의 구성원 / 책임 프로그래머팀과 민주주의식팀의 비교



#### 위험 분석

- 개념
  - Risk Analysis
  - 프로젝트 추진 과정에서 예상되는 각종 돌발 상황을 예상하고 이에 대한 적절한 대책을 수립하는 일련의 활동.
- 위험 분석 절차
  - 위험 식별(Identification) : 위험 요소가 될 사항들을 파악함.
  - 위험 분석 및 평가 : 위험의 비중과 영향력을 파악함.
  - 위험 관리 계획 : 문서화.
  - 위험 감시 및 조치 : 위험을 항상 관찰하고, 발생 시 조치함.
- 위험 감시
  - Risk Monitoring
  - 위험 요소 징후들을 계속적으로 인지하는 것.
- 위험 회피
  - Risk Avoidance
  - 예상할 수 있는 위험을 회피하는 것. 상책.



#### CPM

- Critical Path Method

#### 비용 측정

- 간접 측정 평가 공식 : 생산성 / 개발기간 / 개발비용



#### 비용 측정 방법론의 분류



#### LOC 측정



#### COCOMO 모형



#### Putnam 모형



#### 형상 관리



#### 소프트웨어 생명주기

- Software Life Cycle
- 폭포수 모형(Waterfall)
  - 이전 단계를 확실히 마무리하고 다음 단계로 진행
  - 가장 오래됐고 폭넓게 사용
  - 선형 순차적 모델
  - 매뉴얼 작성 필수
  - 결과물 명확
- 프로토타입 모형(Prototype, 원형 모형)
  - 시제품을 만들어 최종 결과물 예측
  - 사용자와 시스템 사이 인터페이스에 중점
- 나선형 모형(Spiral)
  - 폭포수모형+프로토타입모형+위험분석 기능
  - 나선을 따라 돌듯이 여러 번의 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어 개발
  - 위험 관리 및 최소화가 목적
  - 누락되거나 추가된 요구사항을 첨가할 수 있음
  - 정밀하고 유지보수 과정이 필요 없음
- 애자일 모형(Agile)
  - 고객 요구사항 변화에 빠르고 유연하게 대응
  - 일정한 주기를 반복하며 진행
  - 고객과의 소통에 초점을 맞춘 모든 방법론을 통칭
  - 스프린트 또는 이터레이션이라 불리는 짧은 개발 주기 반복
  - 반복되는 주기마다 결과물에 대한 평과와 요구 수용

#### 테일러링을 위한 품질 관리

- ISO 12207 표준
- ISO/IEC
- CMM
- SPICE 모델



## 2. 요구사항 확인

### 현행 시스템 파악(하)

#### 현행 시스템 파악 개념

#### 저장 장치

- DAS
- NAS
- SAN
- SDS

#### 모듈화

- 79p



### 요구사항 정의(상)

#### 요구사항 정의

- 개념
  - 어떠한 문제를 해결하기 위해 필요한 조건이나 제약사항을 요구하는 것.
- 요구사항의 유형
  - 기능적 요구사항(Functional)
    - 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항
    - 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지, 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사항
    - 시스템이 반드시 수행해야 하는 기능
    - 사용자가 시스템을 통해 제공받기를 원하는 기능
  - 비기능적 요구사항(Non-functional)
    - 시스템 장비 구성 요구사항
    - 성능 요구사항
    - 인터페이스 요구사항
    - 데이터 요구사항
    - 테스트 요구사항
    - 보안 요구사항
    - 품질 요구사항
    - 제약 사항
    - 프로젝트 관리 요구사항
    - 프로젝트 지원 요구사항


#### 요구사항 개발 프로세스

- 도출(Elicitation) -> 분석(Analysis) -> 명세(Specification) -> 확인(Validation)
- 요구사항 도출(Elicitation, 수집)
  - 시스템, 사용자, 그리고 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항이 어디에 있는지, 어떻게 수집할 것인지를 식별하고 이해하는 과정
  - 요구사항 도출 단계에서 개발자와 고객 사이의 관계가 만들어지고 이해관계자가 식별됨.
  - 주요 기법
    - 인터뷰
    - 설문
    - 브레인스토밍
    - 프로토타이핑
    - 유스케이스 : 사용자의 요구 사항을 기능 단위로 표현하는 것
- 요구사항 분석(Analysis)
  - 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정
- 요구사항 명세(Specification, 문서화)
  - 요구사항 분석 후 승인될 수 있도록 문서화하는 것
- 요구사항 확인(Validation, 검증)
  - 개발 자원을 요구사항에 할당하기 전에 요구사항 명세서가 정확하고 완전하게 작성되었는지 검토하는 활동
  - 요구사항 문서는 이해관계자들이 검토해야 함

#### 자료 흐름도(DFD)

#### 자료 사전(DD)

#### UML

- Unified Modeling Language. 객체지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어.
- UML의 특징 (가구명문)
  - 가시화 언어
  - 구축 언어
  - 명세화 언어
  - 문서화 언어
- UML 구성 요소
  - 사물 (Things)
  - 관계 (Relationships)
  - 다이어그램 (Diagrams)
- **UML 다이어그램 유형**
  - 구조적 다이어그램 (정적)
    - 클래스(Class)
      - 구성요소 : 클래스 이름 / 속성 / 연산 / 접근 제어자
      - 접근 제어자 : private / public / protected / default
    - 객체(Object)
    - 컴포넌트(Component)
    - 배치(Deployment, 배포)
    - 복합체 구조(Composite structure)
    - 패키지(Package)
  - 행위적 다이어그램 (동적)
    - 유스케이스(Use case, 사용 사례)
      - 구성요소 : 유스케이스 / 액터 / 시스템
      - 관계 : 포함 / 확장 / 일반화
    - 시퀀스(Sequence, 순차)
      - 구성요소 : 객체 / 생명선 / 실행 / 메시지
    - 커뮤니케이션(Communication)
    - 상태(State Machine, State Transition)
    - 활동(Activity)
    - 상호작용 개요(Interaction overview)
    - 타이밍(Timing)
- UML의 관계
  - 연관 관계(Association)
  - 집합 관계(Aggregation)
  - 포함 관계(Composition)
  - 일반화 관계(Generalization)
  - 의존 관계(Dependency)
  - 실체화 관계(Realization)
- UML 확장 모델의 스테레오 타입
  - 기본적 요소 이외에 새로운 요소를 만들어내기 위한 확장 메커니즘
  - '<<>>'(Guillemet, 길러멧) 기호를 사용하여 표현함.

#### 요구사항 검증

- 개념
- 절차

#### 요구사항 검토

- Peer Review
  - 동료 검토
  - 2~3명 정도의 검토 담당자가 수행하는 검토.
  - 다수의 이해관계자에게 요구사항 명세서 작성자가 명세서를 설명하면 이해관계자들이 설명을 들으면서 결함을 발견하는 형태로 진행됨.

- Walk Through
  - 소프트웨어 개발 단계마다 실시하는 비정형 검토회의
  - 오류 조기 검출이 목적
  - 검토 자료를 회의 전에 배포하고 사전 검토한 후 짧은 시간 동안 회의를 진행함
  - 사용사례를 확장하여 명세하거나 설계 다이어그램, 원시코드, 테스트 케이스 등에 적용할 수 있음.
  - 복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용함.
  - 단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해 보는 것임.

- Inspection
  - 소프트웨어 개발에 참여하지 않은 다른 전문가에 의해 오류를 찾아내는 공식적 검토 방법임.
  - 순서는 계획 - 사전교육 - 준비 - 인스펙션 회의 - 수정 - 후속조치
- Prototype
  - 프로토타입.
  - 검증하려는 주요 기능이나 일부분을 임시적으로 개발하여 이해관계자나 고객을 대상으로 시연하면서 요구사항을 검증함.
- Re-Factoring
  - 리펙토링.
  - 오류를 제거하고 새로운 기능을 추가하는 것이 아니라 결과의 변경 없이 프로그램 소스의 구조를 재조정하는 것.
  - 리펙토링은 가독성을 높이고 유지보수를 편하게 함



#### CASE

- 개념
- 특징
- 종류 : SADT BS PSL/PSA SREM



## 3. 화면 설계

### UI 요구사항 확인(하)

#### 사용자 인터페이스(UI)

- 3가지 분야
  - 물리적 제어
  - 기능적 제어
  - 전체 구성 제어
- UI의 특징
  - SW 영역 중 변경이 가장 많이 발생
  - 사용자의 만족도에 가장 큰 영향을 미침
  - 수행 결과의 오류를 줄임
  - 작업 시간 단축, 업무에 대한 이해도 높임
  - 편리성과 가독성 높임
  - 사용자 인터페이스 설계를 위해선 소프트웨어 아키텍처를 반드시 숙지해야 함
- UI의 종류
  - CLI(Command Line Interface) : 명령과 출력이 텍스트 형태
  - GUI(Graphic User Interface) : 아이콘이나 마우스 사용하는 그래픽 형태
  - NUL(Natural User Interface) : 사용자의 말이나 행동으로 기기 조작 형태
  - OUI(Organic User Interface) : 평면 아닌 화면 조작 형태
- UI의 설계 지침
  - 사용자 중심 / 일관성 / 단순성 / 결과 예측 가능 / 가시성 / 표준화 / 접그성 / 명확성 / 오류 발생 해결 등
- UI 요소
  - Text box
  - Password box
  - Radio button
  - Checkbox button
  - Select box
  - Textarea box
  - submit button
  - reset button
  - Toggle button



### UI 설계(하)

#### UI 설계

- UI 설계 원칙
  - 직관성 : 누구나 쉽게 이해, 사용
  - 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 함
  - 학습성 : 누구나 쉽게 배워야
  - 유연성 : 사용자 요구사항 최대한 수용하고 실수 최소화
- UI 개발 필수 기능
  - 사용자 명령을 받아들일 프롬프트 기능
  - 사용자 명령 입력의 검증 기능
  - 에러 처리와 에러 메시지 처리 기능
  - 도움말 지원 기능



## 4. 애플리케이션 설계

### 공통 모듈(중)

#### 모듈

- 개념
  - SW구조를 이루며, 다른 것들과 구별할 수 있는 독립적인 기능을 갖는 단위
  - 서로 모여 하나의 완전한 프로그램으로 만들어질 수 있음.
  - 추상화되어 재사용 및 공유 가능한 수준으로 만들어진 기능 단위를 모듈로 규정함.
- 모듈의 기본 요소
  - 입력 요소, 파라미터
  - 출력 요소 RETURN
  - 기능 요소
  - 기관 요소 : 모듈 내부의 알고리즘을 의미
  - 내부 자료 요소 : 모듈 내부의 기억 장소를 의미

- 모듈의 공유도(Fan-in)와 제어도(Fan-out)
  - 공유도는 얼마나 많은 모듈이 주어진 모듈을 호출하는가를 나타내는 척도. 상위 모듈의 수. 공통 모듈화 측면에서 잘 설계되어 있으나, 단일 실패점이 발생할 수 있으므로 중점 관리 및 더 많은 테스트를 통한 검증이 필요함.
  - 제어도는 주어진 모듈이 호출하는 모듈의 개수, 하위 모듈의 수. 불필요한 기능을 호출하고 있지 않은지 추가 검토를 진행하고 업무 로직을 단순화시킬 수 있는지에 대해서도 검토.

- 모듈의 개수 및 비용 간 상관도
  - x축은 모듈 개수, y축은 노력 비용
  - 모듈 별 개발 비용 : 모듈의 개수가 많을수록 노력 비용 감소(반비례)
  - 모듈 통합 비용 : 모듈의 개수가 많을수록 모듈 통합 비용 증가(비례)
  - 전체 SW 개발 비용 : 모듈 통합 비용과 모듈 개발 비용이 교차되는 부분의 영역이 최소 노력 비용이 됨(두 그래프가 교차되는 지점)



#### 공통 모듈

- 원칙

- 공통 모듈의 재사용 범위 따른 분류



#### 재공학

- 소프트웨어 재사용의 2가지 기본 기술 : 생성 중심, 합성 중심 120p

- 소프트웨어 재사용의 이점



### 모듈의 평가(상)

#### 모듈의 평가 기준

- 결합도
- 응집도



#### 모듈 결합도

- 자료 결합도
- 스탬프 결합도
- 제어 결합도
- 외부 결합도
- 공통 결합도
- 내용 결합도



#### 모듈 응집도

- 우연적 응집도
- 논리적 응집도
- 시간적 응집도
- 절차적 응집도
- 통신적 응집도
- 순차적 응집도
- 기능적 응집도



### 설계 모델링(하)

#### N-S 도표

#### HIPO 도표



### 소프트웨어 아키텍처(하)

#### 시스템 아키텍처

#### 소프트웨어 아키텍처

#### 아키텍처 계층

- 표현계층-UI계층 등등등 137p

#### 마스터/슬레이브 패턴

#### 파이프-필터 패턴



### 코드 설계(하)

#### 코드의 기능

- 3대 기능, 추가 기능

#### 순차 코드

#### 표의 숫자 코드

#### 코드 오류의 종류

- 사본오류 전위오류 이중오류 등등



### 파일 설계(하)



#### 디자인 패턴

- 세부적 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
- 디자인 패턴 특징
  - 재사용 가능한 기본형 코드들이 포함되어 있음
  - 개발 과정 중 문제가 발생하면 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적
  - 한 패턴에 변형을 가하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화
  - 1995년 GoF가 처음으로 구체화 및 체계화
  - GoF의 디자인 패턴은 가장 일반적인 사례에 적용될 수 있는 패턴들을 분류하여 정리함. 가장 많이 사용되는 디자인 패턴
- 생성패턴(Creational Pattern)
  - 추상 팩토리(Abstact Factory)
  - 빌더(Builder)
  - 팩토리 메소드(Factory Method)
  - 프로토타입(Prototype)
  - 싱글톤(Singleton)
- 구조패턴(Structural Pattern)
  - 어댑터(Adapter)
  - 브릿지(Bridge)
  - 컴포지트(Composite)
  - 데코레이터(Decorator)
  - 파싸드(Facade)
  - 플라이웨이트(Flyweight)
  - 프록시(Proxy)
- 행위패턴(Behavioral Pattern)
  - 책임연쇄(Chain of Responsibility)
  - 커맨드(Command)
  - 인터프리터(Interpreter)
  - 반복자(Iterator)
  - 중재자(Mediator)
  - 메멘토(Memento)
  - 옵저버(Observer)
  - 상태(State)
  - 전략(Strategy)
  - 템플릿 메소드(Template Method)
  - 방문자(Visitor)



## 5. 인터페이스 설계

### 인터페이스 요구사항(하)

#### 인터페이스 송신 시스템



### 인터페이스 설계(하)



# 2과목 소프트웨어 개발

## 1. 데이터 입출력 구현

### 자료 표현 단위와 진법(하)

### 고정 소수점과 부동 소수점(하)

### 자료 구조(중)

#### 자료 구조 분류

- 단순 구조(Simple)
  - 프로그래밍 언어에서 제공하는 기본 데이터 타입
  - int, float, double, char 등

- 선형 구조(Linear)
  - 데이터들 사이의 선후 관계가 일대일인 구조.
  - 선형 구조는 크게 순차 구조와 연결 구조로 나눌 수 있음
  - 순차 구조는 삽입과 제거가 자주 일어날 때 처리 시간이 가장 많이 소요되는 자료 구조이며, 연결 구조인 연결 리스트는 데이터의 삽입, 삭제가 가장 용이한 방법임.
  - 스택, 큐, 데크, 선형 리스트, 연결 리스트가 있음.

- 비선형 구조(Non-Linear)
  - 데이터들 사이의 선후 관계가 계층 또는 그물 형태를 가지는 구조.
  - 데이터를 저장시키는 데 있어 데이터와 대응되는 다른 데이터가 여러 개 존재하는 경우의 관계성을 1:N, N:M 구조로 저장시키는 형태 구조를 비선형 구조라고 함.
  - 트리 구조, 그래프 구조가 있음.

- 파일 구조(File)
  - 보조 기억 장치에 데이터값이 실제로 기록되는 자료 구조임.
  - 순차 파일, 색인 파일 등이 있음.




#### 스택

- Stack
- 스택의 구조
  - 데이터를 저장하는 기억 장치가 한쪽으로만 입구와 출구가 있음.
  - 데이터가 저장될 때 입력된 데이터의 위치를 스택 포인터(TOP)가 가리키고 있음.
  - 스택 포인터는 데이터가 입력(PUSH)될 때마다 1씩 증가하며 스택 크기보다 큰 값을 갖게 되면 데이터를 더 이상 기억할 수 없는 오버플로우(Overflow) 상태가 됨.
  - 스택에 데이터가 출력(POP)될 때에는 1씩 감소하며 저장된 데이터가 없을 경우에는 스택 포인터는 0값을 기억하게 됨.

- 스택의 특징
  - 데이터의 삽입과 삭제가 같은 쪽에서 이루어지는 구조임.
  - 스택의 자료 삽입 : TOP 포인트가 스택의 크기(N) 이상이면 오버플로우, 아니면 TOP포인트 1 증가하고 스택에 TOP 포인트가 가리키는 곳에 자료 삽입함.
  - 스택의 자료 삭제 : TOP 포인트가 비어 있으면 언더플로우, 아니면 스택에 TOP 포인트가 가리키는 곳에 자료 삭제하고 TOP 포인트 1 감소.
  - 나중에 입력된 데이터가 먼저 출력하는 메모리 사용 방법.
  - 후입선출(LIFO) 구조.
  - 데이터와 데이터 사이는 1:1 관계임.
  - 함수 호출하여 복귀할 때 / 깊이 우선 탐색 / 재귀적 함수를 호출 사용할 때 / 인터럽트 수행 시 현재 수행 중인 프로세스의 복귀 주소를 저장할 때 / 수식을 우선적으로 연산하기 위한 방법으로 / 0-주소 명령어 방법에서 사용됨.




#### 큐

- Queue
- 큐의 구조
  - 한쪽 방향으로 데이터가 삽입되고 반대 방향으로 데이터가 삭제되는 데이터 구조임.
  - 큐는 가장 먼저 삽입된 데이터가 가장 먼저 삭제되므로 선입선출(FIFO) 구조라고도 함.
  - 데이터를 저장하는 기억 장치가 양쪽으로 있으며 한쪽으로는 입구, 다른 한쪽으로는 출구가 있음.
  - 데이터가 저장될 때 입력된 데이터의 위치를 삽입 포인터(Rear)가 가리키고 있고, 출력된 데이터는 삭제 포인터(Front)가 가리키고 있음.
  - 삽입(Rear), 삭제(Front)

- 큐의 구조
  - 프린터 스풀(Spool) / 입출력 버퍼(Buffer) / 은행 번호표 서비스 / 각종 스케줄링 / 동영상 버퍼 / 인터넷에서 동영상을 실시간으로 받아보는 스트리밍 서비스
  - 키보드를 입력하면 바로 CPU로 전달되지 않고 큐 구조의 버퍼에 대기했다가 CPU에 전달됨.




#### 트리

- Tree

- 트리의 구조
  - 그래프의 특수한 형태로 노드(Node)와 선분(Branch)으로 되어 있고, 정점 사이에 사이클(Cycle)이 형성되어 있지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조임.
  - 트리 구조는 나무를 뒤집은 모습으로 계층 구조를 표현하기에 적합함.
  - 트리는 프로그램의 에러를 찾아내는 구문 분석에서 필요한 기본 이론을 제공함.

- 트리의 용어
  - 노드(Node) : 원
  - 간선(Edge), 링크(Link) : 노드와 연결된 선
  - 루트(Root) 노드 : 뿌리가 되는 노드
  - 단노드 단말노드(Terminal) : 자식이 없는 노드
  - 간노드(Nonterminal) : 자식이 있는 노드
  - 노드의 차수(Degree) : 자식 노드의 개수
  - 노드의 레벨(Level) : 특정 깊이를 가지는 노드 집합. 루트 노드는 1레벨.
  - 노드의 크기(Size) : 자신을 포함한 자식 노드의 수. 차수+1.
  - 노드의 깊이(Depth) : 루트에서 거쳐 간 간선의 수. 레벨-1.
  - 노드의 높이(Height) : 루트에서 가장 깊은 노드. 레벨.
  - 부노드 부모노드(Parent) : 부모 노드
  - 자노드 자식노드(Children) : 자식 노드
  - 제노드(Sibling) : 형제 노드
  - 숲(Forest) : 루트를 제외한 나머지 부분
  - 서브 트리(Sub Tree) : 부분 집합 트리




#### 이진 트리 순회

- 중위 순회 방법(In-order) : 좌근우
- 전위 순회 방법(Pre-order) : 근좌우
- 후위 순회 방법(Post-order) : 좌우근
- 순회 방법 3가지



#### 폴리쉬 표기법

- 중위식(Infix) : 수학식처럼 연산자가 중간에 있는 것.
- 전위식(Prefix) : 연산자가 앞에 있는 것.
- 후위식(Postfix) : 연산자가 뒤에 있는 것.
- 전위식은 CPU 명령어 형식, 후위식은 프로그램의 문법 에러를 확인하는데 주로 사용됨.



### 검색(하)

#### 검색의 시간 복잡도

- 일반적인 알고리즘에서 시간 복잡도는 O(log_2n)이 가장 빠르고 O(n!)이 가장 느림.
- 입력 자료의 개수가 무한히 크다고 가정하는 경우
  - O(long_2n) : 로그형. 이진 검색, 이진 트리 검색에 해당함
  - O(n) : 선형. 수열이나 순차 검색에 해당함
  - O(nlog_2n) : 로그 선형. 퀵 정렬, 힙 정렬, 합병 정렬 시 비교 횟수에 해당함.
  - O(n^2) : 2차형. 선택 정렬, 버블 정렬 시 자료 비교 횟수에 해당함.
  - O(n^3) : 3차형. 행렬 곱셈 알고리즘에 해당함.



#### 이진 검색

- 이분 검색. Binary Search.
- 이진 검색을 하려면 검색 대상의 전체 자료의 수를 알고 있어야 하고, 검색 대상의 자료들이 정렬되어 있어야 함.
- 시간 복잡도는 O(log_2n) 로그형.



#### 이진 트리 검색

- Binary Tree Search
- 검색 대상의 자료를 이진 트리로 변형한 뒤 검색하는 방법.
- 처음 자료는 근노드가 되고 두 번째 자료는 근노드와 비교해서 작으면 왼쪽으로 크면 오른쪽에 연결함.
- 시간 복잡도는 O(log_2n) 로그형.



#### AVL 트리 검색

- Adelson, Velskii, Landis. 균형 이진 트리
- 이진 트리 검색의 효율을 높이기 위해 구성함.
- 트리의 좌우 균형이 맞지 않으면 균형이 맞도록 균형 인수를 +-1이나 0으로 맞추는 트리.
- 노드가 삽입되거나 삭제될 때 트리의 모양이 변함.
- 균형을 측정할 때는 절대적 개수가 아니라 레벨을 비교함.



#### 해싱 검색

- 자료를 찾는 특별한 규칙으로 검색 대상의 자료를 저장하여 자료를 찾음.
- 특별한 규칙이란 해싱 함수를 말하며 해싱 함수의 결과로 자료들의 저장 위치(주소)가 결정됨.
- 해싱 함수로 계산된 저장 위치가 중복될 때에는 충돌이라고 하며 충돌에 대비한 조치가 필요함.
- 서로 다른 탐색키가 해싱 함수를 통해 동일한 해시 주소로 사상될 수 있음.
- 충돌이 발생하지 않는 해싱 함수를 사용한다면 시간 복잡도는 O(1)임.
- 해싱 함수 종류
  - 제산법(Division) : 레코드 키 값을 소수나 전체 자료수로 나누어 그 나머지 값으로 저장할 위치를 정하는 방법.
  - 폴딩법(Folding) : 레코드 키 값을 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방법.
  - 제곱법(Square) : 레코드 키 값을 제곱한 결과 값의 일부를 선택하여 저장할 위치를 정하는 방법.
  - 중간 제곱법(Mid-Square) : 레코드 키 값을 제곱하고, 이 값의 중간 부분을 취하여 홈 주소로 취하는 해싱 방법.
  - 숫자 분석법(Digit Analysis) : 레코드 키 값을 이루는 숫자들의 분포를 파악해서 분포가 고른 부분을 선택해 저장할 위치를 정하는 방법.
  - 기수 변환법(Radix Transformation) : 레코드 키 값을 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수는 절단하고, 이를 다시 버킷의 개수 범위에 맞게 조정하는 방법.
  - 의사 무작위법(Pseudo-random) : 난수를 발생시킨 후 그 난수를 이용하여 저장할 홈 주소의 위치를 정하는 방법.
- 해싱 함수
  - 홈 주소 : 해싱 함수에 의해서 결정됨. 해싱 주소라고도 함.
  - 버킷 : 자료가 저장될 공간.
  - 슬롯 : 하나의 버킷은 여러 개의 슬롯을 가질 수 있음. 충돌 대비
    - 동거자(Synonym, 동의어) : 서로 다른 키 값이지만 해싱 함수에 의해 같은 버킷에 저장되는 키 값들.
  - 충돌 : 해싱 함수에 의해 서로 다른 키가 같은 홈 주소를 갖게 되는 현상.
  - 오버플로우 : 버킷에 할당된 슬롯 수보다 많이 발생하게 되면 버킷에 더 이상 항목을 저장할 수 없는 경우에 발생함.
  - 프로빙(Probing, 조사법) : 충돌이 발생하여 더 이상 같은 홈 주소를 갖는 버킷을 사용할 수 없을 때 사용하지 않는 다른 버킷을 찾아 저장하는 방법으로 1차 조사법, 2차 조사법 등이 있음.
  - 체인법(Chaining) : 해싱에서 오버플로우 발생 시 이를 해결하기 위한 방법으로 연결 리스트를 사용하며 버킷의 크기에 제한을 두지 않는 기법.

#### 그래프 탐색

- 그래프의 모든 정점을 방문하는 것을 그래프 탐색이라고 함.
- 깊이 우선 탐색(DFS : Depth First Search)
  - 스택(Stack) 구조를 이용하여 운용함.
  - 시작 노드(A)에서 인접한 노드 중 하나를 알파벳순으로 스택에 삽입함.
- 너비 우선 탐색(BFS : Breadth First Search)
  - 큐(Queue) 구조를 이용하여 운용함.
  - 시작 노드(A)에서 인접한 노드를 모두 알파벳순으로 큐에 삽입함.



### 정렬(하)

#### 정렬의 시간 복잡도

|      정렬의 분류       |    평균    |    최상    |    최하    |
| :--------------------: | :--------: | :--------: | :--------: |
|    삽입(Insertion)     |   O(n^2)   |    O(n)    |   O(n^2)   |
|      버블(Bubble)      |   O(n^2)   |   O(n^2)   |   O(n^2)   |
|    선택(Selection)     |   O(n^2)   |   O(n^2)   |   O(n^2)   |
|       쉘(Shell)        |  O(n^1.5)  |    O(n)    |  O(n^1.5)  |
|       퀵(Quick)        | O(nlog_2n) | O(nlog_2n) |   O(n^2)   |
|        힙(Heap)        | O(nlog_2n) | O(nlog_2n) | O(nlog_2n) |
| 이진 병합(2-Way Merge) | O(nlog_2n) | O(nlog_2n) | O(nlog_2n) |
|      버킷(Bucket)      |   O(dn)    |   O(dn)    |   O(dn)    |



#### 선택 정렬

- 첫 번째 위치에 가장 작은 값을 위치시킴.

- Pass 2에서는 첫 번째 위치를 제외한 자리 중 첫 번째 위치에 가장 작은 값을 위치시킴.

  

#### 버블 정렬

- Pass 1 : 1,2 비교 2,3 비교 3,4비교 끝까지
- Pass 2 : 제일 뒤를 제외하고 다시 처음부터 Pass 1 진행함.



#### 삽입 정렬

- Pass 1 : 2를 키값으로 설정하여 1,2 비교
- Pass 2 : 3을 키값으로 설정하여 1,2,3 비교
- 정렬할 자료 일부가 정렬되어 있는 경우에 유리한 방법.



#### 힙 정렬

- 임의의 자료에서 최솟값 또는 최댓값을 구할 경우 가장 적합한 정렬 방법
- 자료를 순서적으로 완전 이진 트리 형태로 만들어 정렬하는 방법.
- 공식을 통해 시작하는 하위 노드 그룹을 결정하고 오름차순 정렬인 경우 자노드가 부노드보다 크면 자료를 교환함. 공식은 k = n/2



#### 퀵 정렬

- 레코드의 키를 기준으로 작은 값은 왼쪽에 큰 값은 오른쪽 서브 파일로 분해하여 정렬하는 방식.
- 정렬 방식 중에서는 가장 빠른 방식이며, 프로그램에서 재귀적 함수를 이용하기 때문에 스택을 필요로 함.



### 모듈 구현(하)



## 2. 통합 구현

### 통합 구현 도구(하)

#### 형상 관리 도구

- 개념
  - Software Configuration Management. 소프트웨어 구성 관리.
  - 소프트웨어의 변경 사항을 체계적으로 추적하고 통제하는 것.
  - 형상 관리는 일반적인 단순 버전 관리 기반의 소프트웨어 운용을 좀 더 포괄적인 학술 분야의 형태로 넓히는 근간을 의미함.
  - 프로그램 소스 코드나 문서의 버전 관리, 이력 관리, 추적, 변경 사항을 체계적으로 관리할 수 있는 기능을 제공하는 프로그램.
  - 동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구.
- 형상 관리 도구 기능
  - check-out : 저장소에서 개발자 PC로 가져오는 기능. PULL. 최신 버전 아닌 원하는 버전으로 체크아웃하는 것도 가능함.
  - check-in : 개발자가 수정한 소스를 저장소로 업로드하는 기능. PUSH.
  - commit : 개발자가 소스를 형상 관리 도구 저장소에 업로드한 후 최종적으로 업데이트가 되었을 때 형상 관리 서버에 반영되도록 하는 기능. COMMIT.
  - update : 변경 사항이 있는 경우 서버 형상을 로컬 형상으로 가져오는 기능. FETCH.
  - import : 아무것도 들어있지 않은 저장소에 맨 처음 소스를 넣는 기능.
  - export : 버전 관리 파일을 뺀 순수한 소스 파일을 받아올 수 있음. 오픈소스 프로젝트의 경우 소스를 압축하여 릴리즈할 때 사용함.
- 형상 관리 도구 종류
  - RCS (Revision Control System)
    - 파일, 잠금 방식으로 소스 파일 수정은 한 명으로 제한하여 버전 관리.
    - 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식.
  - CVS (Concurrent Versions System)
    - 가장 오랫동안 사용한 형상 관리 도구임.
    - 중앙 집중형 서버 저장소에 클라이언트가 접속해서 버전 관리를 실행함.
    - Diff를 통해 이전 버전과 현재 버전을 비교함.
    - 파일 단위로 변경 사항을 관리함.
    - 직관적이고 비교적 단순한 명령 구조.
    - Commit 실패 시 Rollback하지 못함.
  - SVN(Subversion)
    - CVS의 단점을 보완한 방식이며 CVS 사용자도 쉽게 도입하여 사용 가능.
    - Auto Commit을 사용하기 때문에 실패 시 Rollback할 수 있음.
  - Git
    - 공개 소프트웨어 커뮤니티 중심으로 사용하는 개발자가 많이 확대되고 있는 도구.
    - 분산형 저장소 사용함.
    - 중앙 집중 방식으로도 사용할 수 있는 융통성이 있음.
    - Commit은 로컬 저장소에 이루어지고, PUSH 동작에 원격 저장소에 반영됨.
  - Perforce(P4D)
    - 2014 출시. Merge 속도가 빠름.
    - 여러 가지 편리함.
    - CLI가 상대적으로 약함.



### 연계 통합 구현(하)



### 연계 메커니즘(하)



### 연계 장애 및 오류 처리 구현(하)



### 연계 모듈 구현 환경 구성 및 개발(하)



## 3. 제품 소프트웨어 패키징

### 제품 소프트웨어 패키징(하)

#### 제품 소프트웨어 패키징

- 특징

#### 제품 소프트웨어 패키징 도구

- 개념
  - 제품 소프트웨어의 배포를 위한 패키징 시 디지털 콘텐츠의 지적 재산권을 보호하고 관리하는 기능을 제공함
  - 안전한 유통과 배포를 보장하는 도구이자 솔루션임.
  - 불법 복제로부터 디지털 콘텐츠의 지적 재산권을 보호해 주는 사용 권한 제어 기술, 패키징 기술, 라이선스 관리, 권한 통제 기술 등을 포함함.

- 패키징 도구 활용시 고려사항
  - 반드시 암호화 및 보안 기능을 고려한다
  - 다양한 다른 기종 연동을 고려한다
  - 사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려한다
  - 제품 소프트웨어의 종류에 적합한 암호화 알고리즘을 적용한다
  - 지속적인 배포를 고려한다



#### DRM

- 개념
  - 디지털 저작권 관리. Digital Right Management
  - 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술을 말함.
  - 디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 하드웨어 제조업자, 저작권자, 출판업자 등이 사용할 수 있는 접근 제어 기술을 의미함.
  - 디지털 미디어의 생명 주기 동안 발생하는 사용 권한 관리, 과금, 유통 단계를 관리하는 기술.
- 구성 요소
  - 클리어링 하우스(Clearing House) : 저작권에 대한 사용 권한, 라이선스 발급, 사용량에 따른 관리 등을 수행하는 곳
  - 콘텐츠 제공자(Content Provider) : 콘텐츠를 제공하는 저작권자 ex)작곡가
  - 패키저(Packager) : 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
  - 콘텐츠 분배자(Content Distributor) : 암호화된 콘텐츠를 유통하는 곳이나 사람 ex)멜론
  - 콘텐츠 소비자(Customer) : 콘텐츠 사용 주체 ex) 멜론 이용자
  - DRM 컨트롤러(DRM Controller) : 배포된 콘텐츠의 이용 권한을 통제하는 프로그램 ex) 멜론 플레이어
  - 보안 컨테이너(Security Container) : 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치
- 패키징 도구 구성 요소
  - 암호화
  - 키 관리
  - 암호화 파일 생성
  - 식별 기술
  - 저작권 표현
  - 정책 관리
  - 크랙 방지
  - 인증



### 제품 소프트웨어 매뉴얼(하)

#### 제품 소프트웨어 설치 매뉴얼

- 기본 사항

#### 제품 소프트웨어 사용자 매뉴얼

- 준비절차 / 작성절차



### 제품 소프트웨어 버전 관리(하)

#### 제품 소프트웨어 버전 관리

- 버전 관리 항목 : 가져오기 , 체크아웃, 체크인, 커밋, 리파지토리 등

#### 제품 소프트웨어 버전 관리 도구

- 도구 유형 : 공유폴더방식 클라서버방식 분산저장소방식 등

#### 빌드 자동화 도구

- 개념, 종류



## 4. 애플리케이션 테스트 관리

### 애플리케이션 테스트(하)

#### 테스트 관련 용어

- 디버그 / 디버거 / 워크스루 / 정형 기술 검토

#### 테스트의 원칙



### 단위 테스트(중)

#### 단위 테스트

- 개념
  - 원시 프로그램의 모듈이나(함수, 프로시저, 독립적인 루틴 등) 컴포넌트 대상으로 화이트박스 테스트를 실시하는 방법.
  - 모듈의 기능 수행 여부를 판정하고 내부에 존재하는 논리적인 오류를 검출함.
  - 개별 모듈을 시험하는 것으로 예정된 기능이 제대로 수행하는지를 점검하는 검사임.
  - 구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트한다.
  - 모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다.
  - 테스트할 모듈을 호출하는 모듈도 있고, 테스트할 모듈이 호출하는 모듈도 있다.


- 종류
  - 정적 테스트
    - 애플리케이션 실행하지 않고, 명세서나 소스코드 대상으로 분석하는 테스트
    - 코드 워크쓰루
    - 인스펙션
  - 동적 테스트
    - 애플리케이션을 직접 실행해 오류를 찾음, 소프트웨어 모든 단계에서 테스트
      - 블랙박스 테스트(기능 테스트)
      - 화이트박스 테스트



#### 화이트박스 테스트

- 개념
  - 단위 테스트의 가장 기본적인 방법.
  - 소스 코드의 모든 문장을 한 번 이상 수행함으로써 진행됨.
  - 소스 코드를 보면서 테스트 케이스를 다양화하게 만들어 테스트함.
  - 모듈의 내부 구현을 자세히 테스트함.
- 화이트박스 테스트의 종류
  - 기초 경로 테스트(Base Path Testing, Structure Testing, 구조 테스트)
  - 루프 테스트(Loop Testing)
  - 데이터 흐름 테스트(Data Flow Testing, 논리흐름도)
  - 조건 커버리지(Condition Coverage, 검증 기준)
- 화이트박스 테스트를 통해 찾을 수 있는 오류
  - 세부적 오류
  - 논리 구조상의 오류
  - 반복문 오류
  - 수행 경로 오류
  - 알고리즘 오류에 따른 원치 않는 결과
  - 무한 루프
  - 틀린 계산 수식에 의한 잘못된 결과



#### 블랙박스 테스트

- 개념
  - 프로그램의 외부 사용자 요구사항 명세를 보면서 테스트함.
  - 프로그램의 동작만으로 오류를 찾아 내는 방법.
  - 주로 구현된 기능을 테스트함.
  - 모듈의 내부 구현보다는 입력과 출력에 의해 기능을 테스트함.
  - 프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정함.
- 블랙박스 테스트의 종류
  - 동등(균등, 동치) 분할(Equivalence Partitioning)
  - 경계값 분석(Boundary Value Analysis)
  - 오류 예측(Error Forecast)
  - 원인 결과 그래프(Cause and Effect Graphing)
  - 비교 테스트(Compare Testing)
- 블랙박스 테스트를 통해 찾을 수 있는 오류
  - 인터페이스 오류
  - 자료 구조상의 오류
  - 성능 오류
  - 시작과 종결상의 오류
  - 부정확하거나 빠진 오류
  - 비정상적인 자료를 입력해도 오류 처리를 수행하지 않는 경우
  - 정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우
  - 경계값을 입력할 경우 요구된 출력 결과가 나오지 않는 경우



#### 기초 경로 테스트

- Basic Path Testing, Structure Testing(구조 테스트)이라고 함.
- 흐름 도표 작성 -> 복잡도 계산 -> 복잡도 1당 테스트 1번 시행 -> 복잡도 판정
- 복잡도 계산 방법 : 받는 화살표의 수 + 1
- 복잡도 판정 : 5이하 단순, 6~10 구조적&안정적, 20이상 매우 복잡, 50이상 비구조적&불안정 -> 다시 작성
- 모든 프로그램의 복잡도를 6~10 이하로 만들기 위해서는 모듈화가 필수적임.



#### 경계값 테스트

- 개념
  - 범위의 한계 부분을 집중적으로 검사.
  - 해당 경계값 주변에 값들을 입력하여 정상적으로 출력되는지 확인하여 오류가 발생하면 소스 코드를 수정함.



#### 단위 테스트 도구

- 단위 디버깅의 자동화 도구임.

- JUnit : 자바 프로그래밍 언어용.
- CppUnit : C++ 프로그래밍 언어용.
- HttpUnit : 웹 브라우저 없이 웹 사이트 테스트를 수행하는 데 사용되는 오픈 소스 소프트웨어 테스트 프레임워크.
- Unitest : Python 기반의 단위 모듈 테스트, 디버깅 도구.
- NUnit : .NET 플랫폼 기반의 단위 테스트 프레임워크.



### 통합 테스트(하)

#### 통합 테스트

- 개념
  - 통합 테스트는 소프트웨어 각 모듈 간의 인터페이스 관련 오류 및 결함을 찾아내기 위한 체계적인 테스트 기법을 말함.
  - 단위 테스트가 끝난 모듈 또는 컴포넌트 단위의 프로그램이 설계 단계에서 제시한 동일한 구조와 기능으로 구현된 것인지를 확인하는 것.
  - 설계 명세서와 통합된 프로그램과의 차이를 확인하는 것.
- 수행 방법
  - 점증적인 방식 : 드라이버나 스터브를 사용하여 테스트함. 일부 먼저 테스트
    - 상향식 통합 테스트
    - 하향식 통합 테스트
  - 빅뱅 방식(비 점증적) : 한꺼번에. 드라이버나 스터브 없이 실제 모듈로. 단시간 테스트에 적당하고 작은 시스템에 유리함. 장애 위치 파악 어려우며 모든 모듈이 개발되어야 테스트가 가능함.



#### 하향식 통합 테스트

- 메인 제어 모듈로부터 아래 방향으로 제어의 경로를 따라 이동하면서 하향식으로 통합하면서 테스트함.
- 하위 모듈과 최하위 모듈은 깊이우선 또는 너비우선 방식으로 통합됨.(선택 가능)
- 아직 작성되지 않은 하위 제어 모듈 및 모든 하위 컴포넌트를 대신하여 더미 모듈인 스터브(Stub)를 개발함. 테스트 완료되면 스터브는 실제 모듈 또는 컴포넌트로 대치함.



#### 상향식 통합 테스트

- 최하위 레벨의 모듈 또는 컴포넌트로부터 위쪽 방향으로 제어의 경로를 따라 이동하면서 테스트함.
- 최하위 레벨의 모듈 또는 컴포넌트들이 하위 모듈의 기능을 수행하는 클러스터(Cluster)로 결합함.
- 상위 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈은 드라이버(Driver)를 작성함.
- 필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 드라이버(Driver)라고 함.
- 통합된 클러스터 단위를 테스트함.
- 테스트할 때 프로그램 전체를 실행할 수 없음 (하향식은 가능)
- 테스트할 때 독립적인 구조를 갖지 못함 (클러스터로 묶어야 함. 하향식은 독립적인 구조 가능)
- Stub 필요없음. Driver 필요함
- 하위 모듈 그룹(클러스터) 형성이 필요함
- 중요 모듈을 우선 테스트할 때 적당함



### 시스템 테스트(중)

#### V-모델

- 확인
- 검증
- 부하 테스트

#### 인수 테스트

- 수행 방법 : 알파 / 베타

#### 테스트 자동화 도구

- 정적 분석 도구
- 성능 테스트 도구

#### 테스트 장치 구성

- 드라이버 / 스터브 / 수트 등

#### 테스트 케이스

- 개념
  - 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서를 의미함.
  - 테스트 케이스의 가장 핵심적인 사항은 테스트 항목의 도출임.
  - 프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는 것이 중요함.
- 테스트 케이스 작성 순서
  1. 테스트 계획 검토 및 자료 확보
  2. 위험 평가 및 우선순위 결정
  3. 테스트 요구사항 정의
  4. 테스트 구조 설계 및 테스트 방법 결정
  5. 테스트 케이스 정의
  6. 테스트 케이스 타당성 확인 및 유지 보수



#### 테스트 오라클

- 개념
  - 테스트 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법 및 활동을 말함.
  - 테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준임.
  - 결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 계산하거나 확인함.
- 특징
  - 제한된 검증
  - 수학적 기법
  - 자동화 가능
- 테스트 오라클의 유형
  - 참 오라클(True Oracle) : 모든 입력값에 대해 기대하는 결과를 생성함으로써 발생한 오류를 모두 검출할 수 있는 오라클.
  - 샘플링 오라클(Sampling Oracle) : 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클.
  - 추정 오라클(Heuristic Oracle) : 샘플링 오라클을 개선한 오라클. 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 추정으로 처리하는 오라클.
  - 일관성 테스트 오라클(Consistent Test Oracle) : 소프트웨어 변경이 있을 때, 수행 전과 수행 후의 결과 값이 동일한지 확인하는 오라클.
- 테스트 오라클의 적용 방안
  - 참 오라클은 주로 항공기, 임베디드, 발전소 소프트웨어 등 작은 실수만으로도 치명적인 결과를 초래하는 업무에 적용함.
  - 샘플링/추정 오라클은 일반, 업무용, 게임, 오락 등의 일반적인 업무에 적용함.



### 테스트 결과 분석(하)

#### 테스트 결과 분석

- 결함 종류 : 오류, 결함, 실패 등



### 연계 테스트 및 검증(하)



### 테스트 커버리지(하)



### 성능 분석 및 품질 평가(중)

#### 테스트 관리 지원 도구

- 소스코드 품질 분석 도구(정적 분석 지원 도구) 종류

#### 품질 목표 항목

- 정확성 / 신뢰성 / 효율성 등등등

#### 외계인 코드



## 5. 인터페이스 구현

### 인터페이스 설계 명세(중)

#### EAI

- EAI 구축 유형 : Point-to-Point / Hub&Spoke 등등등

#### 인터페이스 구현 도구

- JSON / XML 등



### 인터페이스 구현 검증(하)

#### 인터페이스 구현 검증 도구

- xUnit / STAF / FitNEsse 등등등



# 3과목 데이터베이스 구축

## 1. 데이터베이스의 개요

### 데이터베이스의 개요(하)

#### 데이터베이스 설계

- 데이터베이스 설계 순서
  1. 요구 조건 분석 : 요구 조건 명세서 작성
  2. 개념적 설계 : DBMS에 독립적인 개념 스키마, 트랜잭션 모델링, E-R 모델
  3. 논리적 설계 : 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계
  4. 물리적 설계 : 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
  5. 구현 : 목표 DBMS의 DDL로 데이터베이스 생성, 트랜잭션 생성



#### 스키마

- 개념
  - 데이터베이스를 구성하는 자료 개체, 이들의 성질, 이들 간의 관계, 자료의 조작 및 이들 자료 값들이 갖는 제약조건에 관한 정의를 총칭해서 스키마라고 함.
  - 데이터베이스의 논리적 구조 기술임
  - DBMS 특성과 구현 환경을 감안한 데이터 구조.
  - 직관적으로 하나의 데이터베이스로 이해 가능함.
  - 스키마는 데이터 사전에 저장되며 메타데이터라고도 함.
- 스키마 3단계
  - 외부 스키마(External Schema)
    - 서브스키마, 사용자 뷰
    - 응용 프로그래머나 사용자 그룹 입장에서의 데이터베이스 모습으로 조직의 일부분을 정의한 것.
    - 공용의 의미보다는 어느 개인이나 특정 응용에 한정된 논리적 데이터 구조이며, 데이터베이스의 개별 사용자나 응용 프로그래머가 접근하는 데이터베이스임.
    - 각 개인의 입장에서 필요로 하는 구조를 정의함
    - 하나의 데이터베이스 시스템에는 여러 개의 외부스키마가 존재할 수 있음.
  - 개념 스키마(Conceptual Schema)
    - 전체적인 뷰
    - 모든 응용 프로그램과 사용자들이 필요로 하는 데이터베이스 전체를 정의함.
    - 전체적인 논리적 구조
    - 트랜잭션 모델링을 하는 단계임.
    - 데이터베이스에서 데이터에 대한 접근 권한, 보안 정책, 무결성 규칙들이 포함됨.
  - 내부 스키마(Internal Schema)
    - 물리적 저장 장치의 입장에서 본 데이터베이스 구조
    - 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄.
- 인터페이스
  - 응용 인터페이스 : 외부 스키마와 개념 스키마 간의 사상 관계를 나타내는 인터페이스.
  - 저장 인터페이스 : 개념 스키마와 내부 스키마 간의 사상 관계를 나타내는 인터페이스



### 데이터베이스 관리 시스템(DBMS)(하)

### 데이터베이스의 종류(상)

#### RDBMS

- 기본 용어

  - 속성(Attribute)
    - 개체 정보의 특성에 대한 이름임.
    - 프로그래밍 언어에서 기억 장소 이름인 변수명에 해당됨.
    - 파일 시스템에서 레코드의 필드에 해당됨.
    - 각 속성은 유일한 값(원자 값)을 갖고 있어야 함.
    - 한 릴레이션을 구성하는 애트리뷰트 사이에는 순서가 없음.
  - 도메인(Domain)
    - 한 속성에 입력되는 실제 원자 값들의 범위임.
    - 하나의 속성이 가질 수 있는 원자 값들의 집합임.
    - 수험번호가 2byte 정수형으로 선언했다면 수험번호의 도메인은 -32768~32767 사이의 값임.

  - 튜플(Tuple)
    - 속성들에 실제 입력된 값들의 집합임.
    - 하나의 행, 하나의 줄에 해당되는 값임.
    - 파일 시스템에서 레코드에 해당됨.

  - 릴레이션(Relation)
    - 데이터 간에 나타내는 표 자체임.
    - 한 개 이상의 속성들 집합으로 이루어져 있음.
    - 릴레이션 스키마와 릴레이션 어커런스가 결합된 명칭임.
  - 릴레이션 스키마(Relation Schema)
    - 하나 이상의 속성을 합쳐 정의하는 이름임.
  - 릴레이션 어커런스(Relation Occurrence)
    - 실제 입력된 튜플들의 집합으로 시간에 따라 변화됨.
  - 차수(Degree)
    - 하나의 릴레이션에서 정의된 속성의 개수.
    - 레코드의 필드 수.
  - 카디널리티(Cardinality, 기수)
    - 하나의 릴레이션에 형성된 튜플의 개수 혹은 기수라고 함.
    - 레코드의 수를 의미함.
  - 널(NULL)
    - 속성 값이 비어 있는 상태임.
    - 숫자 0과 공백 문자는 속성 값에 입력된 데이터로 NULL은 아님.
    - 한 바이트가 모두 0인 상태임. 00000000. 초기화 상태. 무 상태. 공백, 숫자 0은 바이트로 00100000, 00110000 임. 
    - 메모리에 가장 많이 분포되어 있는 값.

- 릴레이션의 특징

  - 튜플의 유일성 : 입력되는 모든 튜플은 중복된 튜플이 존재하지 않음.
  - 튜플의 무순서 : 입력되는 모든 튜플은 순서적으로 입력되지 않고 상황에 따라 순서 없이 입력됨.
  - 속성의 원자성 : 속성으로 입력되는 도메인 값은 분해될 수 없는 형태로 입력되어야 함.
  - 속성의 무순서 : 속성 간의 논리적인 순서는 의미가 없음.
  - 속성 이름의 유일성 : 속성 이름은 중복되어서는 안 됨.

- RDBMS의 키

  - 후보키(Candidate Key)
    - 하나의 릴레이션에 있는 모든 튜플에 대해 유일성과 최소성을 모두 만족시켜야 함.
    - 유일성은 모든 튜플을 유일하게 구분할 수 있는 성질이고, 최소성은 가장 작은 개수의 속성으로 구성될 수 있는가를 나타내는 성질임.

  - 기본키(Primary Key)
    - 후보키들 중 데이터베이스의 설계자에 의해서 튜플 구별을 위해 선택된 한 개의 키임.
    - 기본키로 선택된 속성은 NULL 값을 가질 수 없음.

  - 대체키(Alternate Key, 보조키)
    - 후보키 중에서 기본키를 제외한 모든 키는 대체키가 됨.
  - 외래키(Foreign Key)

  - 슈퍼키(Super Key)
    - 튜플을 식별하기 위한 두 개 이상의 속성들의 집합으로 이루어진 키로 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못함.

- 무결성의 제약조건 (Integrity Constraint)

  - 도메인 무결성
    - 하나의 속성에 입력되는 값에 대한 정확성을 유지하는 성질.
  - 개체 무결성
    - 기본키를 설정하여 그 기본키에 대해 NULL 값을 허용하지 않으므로 하나의 릴레이션으로 삽입되거나 변경되는 튜플들에 대해 정확한 값을 유지하는 성질로 하나의 릴레이션에 있는 튜플은 중복된 튜플이 있어서는 안 된다는 성질임.
  - 참조 무결성
    - 릴레이션은 참조할 수 없는 외래키를 가질 수 없다는 성질임.



## 2. 논리 데이터베이스 설계

### 개체와 속성(하)

### 정보 모델링과 데이터 모델링(하)

#### 데이터 모델링

- 개념
  - 현실 세계의 데이터 구조를 컴퓨터 세계의 데이터 구조로 변환하는 개념적인 도구임.
  - 현실 세계의 요구사항을 컴퓨터 세계의 데이터 구조로 변환하기 위하여 개체와 관계를 중심으로 분석, 설계하여 점차적으로 자료 구조를 만들어 가는 과정.

- 데이터 모델링의 구성 요소
  - 논리적 구조(Logical Structure) : 논리적으로 표현된 데이터 구조임.
  - 연산(Operation) : 데이터 구조에서 삽입, 삭제, 변경하는 방법임. 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업.
  - 제약조건(Constraint) : 데이터 구조에서 허용할 수 있는 관계를 명세화함.



#### 데이터 모델링 절차

- 데이터 관점의 데이터 모델링 절차
  - 개념 데이터 모델링
  - 논리 데이터 모델링
  - 물리 데이터 모델링
  - 데이터베이스 구축



#### 논리(Logical) 데이터 모델링

- 개념
- 3단계
- 특성

#### 물리(Physical) 데이터 모델링



#### 데이터베이스 구축

- 설계된 데이터를 저장하기 위해 DBMS를 이용하여 데이터베이스를 생성하는 것.
- 구축 시 고려사항
  - 무결성 : 수정, 삽입, 삭제 후에도 데이터에 문제가 없어야 함.
  - 일관성 : DB 저장된 값의 질의응답 시에 모호성이 없어야 함.
  - 회복성 : 장애 발생 시에 원래 상태로 복구할 수 있어야 함.
  - 보안성 : 불법적인 데이터 접근이나 변경에 보호될 수 있어야 함.
  - 효율성 : 응답 시간의 단축, 저장 공간의 절약, 생산성 등을 고려해야 함.
  - 확장성 : 시스템에 영향을 받지 않는 범위 내에서 새로운 데이터 추가하거나 확대 가능해야 함.



### E-R 다이어그램(ERD) 작성(하)

#### E-R 다이어그램(ERD) 표기법

- 개체
- 속성
- 관계
- 연결



#### 확장 ERD

- 슈퍼 타입과 서브 타입
- 특수화
- 일반화
- 상속
- 집단화
- 분류화



### 관계 스키마와 함수적 종속(상)

#### 관계 스키마

- 개념
- 설계 원칙
- 이상 현상 (Anomaly)
  - 삭제 이상
  - 삽입 이상
  - 갱신 이상



#### 함수 종속

- 개념
- 결정자(Determinant)
- 종속자(Dependent)
- 폐포(Closure)



#### 관계 대수

- 개념
  - Relational Algebra
- 일반 집합 연산자
- 순수 관계 연산자
- 곱집합(Cartesian Product)
- 셀렉션(Selection)
- 디비전(Division)



### 데이터베이스의 정규화(중)

#### 정규화

- 개념
  - 하나의 릴레이션에 하나의 의미만 존재할 수 있도록 릴레이션을 분해해나가는 과정.
  - 데이터 모델링의 단계 중 가장 중요한 단계로써 논리 데이터 모델링을 상세화하는 단계임.
  - 중복성을 최소화하고 정보의 일관성을 보장하기 위한 개념임.
  - 정규형(Normal Form)이란 특정 조건에 만족하는 릴레이션 스키마의 형태를 의미함.
- 목적
  - 구성되는 모든 릴레이션이 중복되지 않게 효과적으로 데이터베이스 내에 표현이 가능하도록 함.
  - 보다 간단한 연산자에 의해 효과적인 연산이 가능하도록 구성함.
  - 새로운 형태의 데이터가 삽입될 때 릴레이션을 재구성할 필요성을 감소시키도록 함
  - 자료 검색과 추출의 효율성을 추구할 수 있음
  - 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만듦.
- 필요성
  - 자료의 저장 공간을 최소화
  - 자료의 불일치를 최소화
  - 자료 구조를 안정화
  - 자료의 삽입, 삭제, 갱신 시 이상 현상을 방지

- 장점
  - 정규화 수준이 높으면 유연한 데이터 구축이 가능함.
  - 정규화 수준이 높으면 데이터의 정확성 높아짐.
- 단점
  - 정규화 수준이 높으면 물리적 접근이 복잡해짐.
  - 정규화 수준이 높으면 길이가 짧은 데이터 생성으로 많은 조인이 발생함.

- **정규화 과정**

  - 비정규형

  - 제1NF(제1정규형) : 도메인을 원자 값만 갖도록 분해함.

  - 제2NF(제2정규형) : 부분 함수 종속을 제거함.

  - 제3NF(제3정규형) : 이행적 함수 종속을 제거함.

  - 보이스 코드 정규형 : 결정자가 후보키가 아닌 함수 종속을 제거함.

  - 제4NF(제4정규형) : 다중치 종속을 제거함.

  - 제5NF(제5정규형) : 후보키를 통하지 않은 조인 종속을 제거함.



#### 정규화의 단계

- 제1정규형(1NF : First Normal Form)
  - 하나의 튜플에서 여러 개의 값이 들어와 원자성을 가지지 못하는 경우(비정규형)에 도메인 값을 분해하면 1정규형이라고 함.
  - 반복 그룹(Repeat Group) 속성을 제거함.
  - 새로운 실체와 1:N 의 관계를 추가함.
  - 모든 속성은 반드시 하나의 값을 가져야 함. 반복 형태가 있어서는 안 됨.
  - 릴레이션에 속한 모든 도메인 혹은 속성이 원자 값만으로 되어 있다면 제1정규형에 속함.
  - 원자 값만으로 구성된 릴레이션을 제1정규형이라고 함.

- 제2정규형(2NF : Second Normal Form)
  - 릴레이션이 제1정규형이 속하고 기본키에 속하지 않는 모든 속성들이 기본키에 완전 함수 종속이면 제2정규형이 속함.
  - 제1정규형을 만족하고 모든 도메인이 원자 값인 상태에서 제2정규형이 만들어짐.
  - 주 식별자 전체에 완전 기능 종속(Full Function Dependency)이 되지 않는 속성을 제거함.
  - 주 식별자 속성 일부에만 함수적 종속되는 속성들을 상위 개체로 도출함.
- 제3정규형(3NF : Third Normal Form)
  - A->B, B->C, A->C 관계를 이행적 함수 종속이라고 함.
  - 학생, 학과, 지도교수의 관계에서 학생이 학과를 선택하면 지도교수가 배정되는 것인데, 마치 학생이 지도교수를 선택한 것처럼 보이는 경우가 이행적 함수 종속임.
  - 학생-학과 릴레이션과 학과-지도교수 릴레이션으로 분리하면 됨. 학과는 교수 릴레이션의 기본키이면서 학생 릴레이션의 외래키가 됨.
  - 중간 다리인 학과를 외래키와 기본키 역할을 하는 릴레이션 2개로 분할하는 것이 제3정규형임.
  - 릴레이션이 제2정규형에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 이행적 함수 종속이 아니면 제3정규형에 속함.
  - 주 식별자에 이행 종속(Transitive Dependency)되는 속성을 제거함.
- 보이스 코드 정규형(BCNF : Noyce-Codd NF)
  - 실제로 거의 고려되지 않는 정규화임.
  - 비결정자에 의한 함수 종속을 제거하여 모든 결정자가 후보키가 되도록 하는 데 있음.
  - 주 식별자에 다가 종속(Multi-Valued Dependency)되는 속성을 2가지 이상 두지 않도록 함.
  - 특정 조건에 대해 제공되는 결과 값에 같은 데이터 값이 2번 이상 발생하는 속성을 하위 개체로 도출함.
  - 결정자가 후보키가 아닌 함수 종속 제거 -> 후보키가 아닌 속성이 함수적 종속되는 것을 제거
  - 비결정자에 의한 함수적 종속 제거 -> 기본키가 아닌 다른 속성에 의해  함수적 종속되는 것을 제거
  - 비식별자 속성 간의 종속 제거 : 기본키가 아닌 속성에 의한 함수적 종속되는 것을 제거
  - 결정자이면서 후보키가 아닌 것 제거 : 기본키가 될 수 있으면서 후보키가 아닌 것을 제거
  - 학번, 과목을 기본키로 하고 비결정자인 지도교수만 존재한다면 당장은 이상이 없어 보일 수 있다. 그러나 지도교수가 이번 학기에 컴퓨터공학 과목을 준비 못해 수학 과목을 강의하기로 했다고 하자. 그러면 학번과 컴퓨터공학 과목으로 지도교수를 선택할 수 없어 데이터베이스의 이상 현상이 발생한다. 따라서 이러한 이상 현상을 제거하기 위해 지도교수를 기본키로 하여 새로운 릴레이션을 만들어야 한다.
- 제4정규형(4NF : Four Normal Form)
  - 1:1인 함수 종속 관계가 아닌 1:N 형태로 종속되는 관계를 다중치 종속 관계라고 함.
  - 제4정규형은 고급 정규화 과정으로 다중치 종속 관계를 제거하는 것임.
  - 만약 과목 10개, 교수10명, 출판사 10개를 하나의 릴레이션으로 표현하면 최대 1000개의 데이터 조합이 발생할 수 있음. 과목과 교수, 과목과 출판사로 릴레이션을 분해하면 각각 100개의 데이터씩 200개로 데이터 조합이 줄어듦. 데이터의 개수도 줄고 이상 현상도 발생하지 않게 됨.
- 제5정규형(5NF : Five Normal Form)
  - 어떤 릴레이션 R에 존재하는 모든 조인 종속성이 릴레이션 R의 후보키를 통해서만 성립됨.
  - 정규화를 통해서 분해된 각 릴레이션들은 처음의 릴레이션으로 재구성될 수 있다면 조인 종속성을 만족시킴.
  - 복원 확인 : 릴레이션의 이상 현상을 제거하기 위해 여러 개의 릴레이션으로 분해했다면, 분해된 릴레이션들로 자연조인 했을 때, 원래의 릴레이션이 될 수 있는지 확인해야 함.
  - 원래의 릴레이션으로 복원될 수 이싿면 제5정규형이 완료되는 것이고, 그렇지 않다면 새롭게 릴레이션을 추가해서라도 원래의 릴레이션으로 복원되도록 해야 함.
  - 자연조인할 때 존재하지 않는 튜플이 생성되는 것을 부당 튜플이라고 함.



### 논리 데이터 모델 품질 검증(하)



## 3. SQL

### SQL 명령어(상)

#### 데이터 정의어

- DDL : Data Definition Language
- 테이블 생성(CREATE)
- 테이블 변경(ALTER)
- 테이블의 삭제와 변경
- 삭제, 갱신의 제약조건(Constraint)

#### 데이터 조작어

- DML : Data Manipulation Language
- 데이터 삽입(INSERT)
- 데이터 수정(UPDATE)
- 데이터 삭제(DELETE)
- 데이터 조회(SELECT)



#### SELECT 명령어

- 기본적인 명령
- 조건 지정 검색 명령
- 부속, 복수 질의 명령
- 그룹 지정 명령
- 집합 명령



#### 데이터 제어어

- DCL : Data Control Language
- DCL 명령어
  - GRANT
  - REVOKE

#### 트랜잭션 제어어(TCL)

- TCL 명령어
  - COMMIT
    - 변경 사항이 물리적인 디스크에 저장됨.
    - COMMIT 명령 이후에는 COMMIT 이전 상태로 복구할 수 없음.
    - 모든 사용자가 변경된 결과를 볼 수 있음
  - ROLLBACK
    - 데이터베이스의 연산에 문제가 발생하면 이미 수행되었던 모든 작업을 취소하고 원래 상태로 복귀함.
    - ROLLBACK 명령 이후 메모리상의 버퍼(Buffer)에만 영향을 미치기 때문에 복구가 가능함.
  - SAVEPOINT
    - 특정 중간 시점을 SAVEPOINT로 지정하고, SAVEPOINT 이후에 오류가 발생하면, 처음부터 다시 시작하는 것이 아니라 SAVEPOINT부터 실행을 할 수 있음.



#### 트랜잭션

- 개념

  - 데이터베이스의 현재 상태를 하나의 일관된 상태에서 또 다른 일관된 상태로 변환시키는 논리적인 연산의 집합.
  - 트랜잭션은 일 처리 단위를 의미함.

- 특징

  - 트랜잭션은 논리적 연산 단위임.
  - 한 개 이상의 데이터베이스 조작임.
  - 하나 이상의 SQL 문장이 포함됨.
  - 트랜잭션은 거래임. 거래 결과가 모두 반영되거나 또는 모두 취소되어야 함.

- 특성 4가지

  - 원자성(Atomicity)
    - 트랜잭션의 연산은 모두 실행되거나 모두 실행되지 않아야 함.
    - 트랜잭션은 일부만 수행된 상태로 종료되어서는 안 됨.
    - 트랜잭션 A가 수행되는 동안 다른 트랜잭션 B는 트랜잭션 A가 지금까지 수행한 중간 결과를 참조할 수 없음.
  - 일관성(Consistency, 무결성)
    - 트랜잭션 실행 전과 후 동일하게 오류가 없어야 함.
    - 트랜잭션을 완전히 실행하면 데이터베이스를 하나의 일관된 상태에서 다른 일관된 상태로 바꿔야 함.

  - 고립성(Isolation, 독립성, 격리성)
    - 트랜잭션 실행 중 다른 트랜잭션에 영향을 받지 않아야 함.
    - 하나의 트랜잭션의 실행은 동시에 실행 중인 다른 트랜잭션의 간섭을 받아서는 안 됨.
  - 지속성(Durability, 계속성, 영속성, 장애 대응성)
    - 트랜잭션 결과는 항상 보존되어야 함.
    - 트랜잭션에 의해서 변화된 상태는 계속해서 유지될 수 있어야 함.
    - 완료한 트랜잭션에 의해 데이터베이스에 가해진 변경은 어떠한 고장에도 손실되지 않아야 함.

- 트랜잭션 상태 제어
  - 트랜잭션 상태를 제어한다는 것은 흐름의 구조를 바꾼다는 것이 아니라 트랜잭션의 결과를 수용하거나 취소하는 것을 의미함.
  - 활동(Active) : 트랜잭션 실행 중.
  - 부분 완료(Partially Committed) : 트랜잭션이 마지막 연산을 끝내고 데이터베이스에 실행 결과를 적용하기 직전의 상태.
  - 완료(Comitted) : 트랜잭션이 연산을 완료하고 연산의 결과를 데이터베이스에 적용한 상태(거래 확정)
  - 실패(Failed) : 트랜잭션이 실행 중 어떤 오류에 의해서 더 이상 진행될 수 없는 상태임.
  - 철회(Aborted) : 트랜잭션 실행이 실패하여 복귀되어 있는 상태. ROLLBACK 연산 수행한 상태.
  - Redo(Re+Do, 다시 실행) : 갱신이 완료된 데이터를 로그 파일을 이용하여 복원함. 이미 진행 중이었던 작업을 다시 함.
  - Undo(Un+Do, 실행취소 = ROLLBACK) : 변경되었던 데이터를 취소하여 원래의 내용으로 복원함. 했던 작업을 다시 하지 않고 원상태로 되돌림.



#### CRUD

- C(Create), R(Read), U(Update), D(Delete)
- CRUD Matrix
- CRUD 분석



### 절차형 SQL(하)

#### 트리거

- Trigger



### 인덱스와 뷰(하)

#### 인덱스

- Index
- 개념
  - 데이터베이스 성능에 많은 영향을 주는 DBMS의 구성 요소로 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유함.
  - 문헌의 색인, 사전과 같이 데이터를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조.
  - 테이블에 붙여진 색인으로 데이터 검색 시 처리 속도 향상에 도움이 됨.
  - 인덱스는 기본 테이블의 특정 레코드 위치를 알려주는 용도로 사용함.
  - 인덱스는 자동 생성되지 않기 때문에 데이터베이스 사용자가 지정해주어야 함. 다만 데이터베이스 사용자가 특정 컬럼을 기본키(PK)로 지정할 경우에 인덱스는 자동 생성됨.
  - 인덱스는 조건절에 '='로 비교되는 컬럼을 대상으로 인덱스를 생성하면 검색 속도를 높일 수 있음.
- 생성 : `CREATE [UNIQUE] INDEX <인덱스명> ON <테이블명> (<필드명들>);`
- 삭제 : `ALTER TABLE <테이블명> DROP INDEX <인덱스명>`
  - 보통 인덱스를 테이블의 종속 구조로 생각하기 때문에 인덱스를 삭제하기 위해 테이블에 변경을 가하는 형식의 명령을 사용함.
- 조회 : `SHOW INDEX FROM <테이블명>`



#### 뷰

- View.

- 개념
  - 하나 이상의 뷰 테이블은 기본 테이블로부터 유도되어 정의되는 가상 테이블이며 뷰 테이블로 정의한 정보는 시스템 카탈로그에 저장됨.
  - 뷰 테이블은 물리적으로 존재하지 않고 또한 물리적으로 분리될 수도 없음.
  - 외부 스키마를 구성하는 데 쓰임.
  - 같은 데이터를 동시에 여러 사용자에게 상이한 방법으로 제공할 수 있음.
  - 제공되지 않은 데이터에 대해서는 자동적으로 보안을 유지할 수 있음.
  - 뷰 위에 또 다른 뷰를 정의할 수 있음.
  - 뷰 테이블을 변경하려면 뷰 테이블을 DROP으로 삭제하고 다시 생성해야 함.
- 뷰(View)의 장점
  - 논리적 독립성 제공 : 테이블의 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 됨.
  - 사용자 데이터 관리 용이 : 복수 테이블에 존재하는 여러 종류의 데이터에 대해 단순한 질의어 사용이 가능함.
  - 데이터 보안 용이 : 중요 보안 데이터를 저장 중인 테이블에는 접근 불허하며, 해당 테이블의 일부 정보만을 볼 수 있는 뷰에는 접근을 허용하는 방식.
- 뷰의 단점
  - 뷰 자체 인덱스 불가능
  - 뷰 정의 변경 불가능
  - 데이터 변경 제약 존재
- 뷰의 생성
  - `CREATE VIEW <뷰 이름>(컬럼 목록) AS <SELECT문> [옵션];`
- 뷰의 옵션
  - REPLACE / FORCE / NOFORCE / WITH CHECK OPTION / WITH READ ONLY
- 뷰의 삭제
  - `DROP VIEW <뷰 이름>;`
- 뷰의 조회
  - `SELECT * FROM <뷰 이름>;`



### SQL 지원 도구(하)



#### 시스템 카탈로그

- System Catalog. 데이터 사전. 시스템 데이터베이스
- 개념
  - 테이블 정보, 인덱스 정보, 뷰 정보 등을 저장하는 시스템 테이블임.
  - 사용자들이 검색은 가능하나 직접적인 변경은 불가능함.
  - 시스템이 필요로 하는 모든 객체에 대한 정보를 가지고 있는 시스템 데이터베이스로 사용자 데이터베이스와는 구별됨.
  - 시스템 데이터베이스에는 카탈로그와 디렉토리로 나누어 저장하는데 카탈로그에는 객체에 대한 정보를 저장하고 디렉토리에는 그 정보를 어떻게 액세스할 것인가하는 시스템만이 사용하는 정보를 저장하게 됨.
- 구성 요소
  - 시스템 카탈로그 : 생성된 테이블에 관련된 정보를 기록함.
  - 데이터 디렉토리 : 데이터 사전에 수록된 데이터를 실제로 접근하는 데 필요한 정보를 기록하며 시스템만이 접근할 수 있는 구역.
  - 메타 데이터 : 사용자의 데이터를 설명해 놓은 데이터 사전임.
  - 데이터 사전 : 사용자의 테이블과 속성의 관련 정보를 기록함.



### 병행 제어와 로킹(중)

#### 로킹

- 개념
  - Locking
- 로킹 단위 크기에 따른 비교



#### 회복

- 개념
  - Recovery
- 장애의 유형
- 회복에 따른 연산자
- 회복 기법
  - 즉시 갱싱을 로그를 이용한 회복
  - 로그를 이용한 자연 회복 기법
  - 검사 시점에 의한 회복 기법
  - 그림자 페이징 기법 (Shadow Paging)



## 4. 물리 데이터베이스 설계

### 물리 데이터 모델 설계(하)

#### 파티션

- 종류
  - 범위 분할
  - 해시 분할
  - 조합 분할
- 장점



### 저장 레코드 형식 설계(하)



### 반정규화 수행(하)

#### 반정규화

- 개념
  - De-Normalization



#### 반정규화 유형

- 중복 테이블 추가
  - 중복 테이블 추가 용도
  - 집계(통계) 테이블을 추가하는 방법
  - 진행 테이블 추가 상황 확인
  - 진행 테이블 생성 시 유의 사항 확인
  - 특정 부분만 포함하는 테이블을 추가하는 방법
  - 테이블 추가 시 고려사항

- 테이블 조합
- 테이블 분할
  - 수평 분할 (Horizontal Partitioning)
  - 수직 분할 (Vertical Partitioning)



### 분산 데이터베이스 설계(중)

#### 분산 데이터베이스

- 개념
  - 하나의 논리적 데이터베이스가 물리적으로 네트워크에서 복수의 컴퓨터에 분산되어 있을 경우에도 사용자가 단일 데이터베이스와 같이 인식하는 것이 가능하도록 논리적으로 통합 및 공유되는 데이터베이스를 의미함.
- 구성 요소
  - 분산 처리기 : 물리적으로 분산되어 지역별로 필요한 데이터를 처리할 수 있는 지역 컴퓨터(Local Computer)를 분산 처리기(Distributed Processor)라고 함.
  - 분산 데이터베이스 : 지리적으로 분산된 데이터베이스
  - 통신 네트워크 : 분산 처리기들을 통신망으로 연결
- 장점
  - 데이터에 대한 지역적 분산 제어를 통해 원격 데이터에 대한 의존도를 감소시킬 수 있음.
  - 단일 서버에서 처리가 어렵거나, 불가능한 규모의 대용량 데이터 처리가 가능해짐.
  - 기존 시스템에 서버를 추가하는 방식을 통해 점진적 확장이 용이함.
  - 하나의 사이트에 문제가 생겨도 다른 사이트에서 사용할 수 있기 때문에 신뢰도와 가용성이 향상됨.
- 단점
  - 복잡도와 SW 개발 비용이 증가함.
  - 통제 기능이 상대적으로 취약함.
  - 오류 발생 가능성 증가함.
  - 응답 속도가 불규칙적으로 나타날 수 있으며 데이터의 무결성을 완전히 보장하기 어려움.
- 



#### 분산 DBMS

- 투명성 (Transparency)
  - 복수의 분할된 물리적 데이터베이스를 논리적으로 단일화된 데이터베이스처럼 인식하려면 사용자들이 데이터의 물리적 배치와 특정 지역 사이트의 데이터에 대한 액세스 방법을 별도로 알 필요가 없어야 함.

- 분할 투명성 (Fragmentation Trasparency, 단편화 투명성)
  - 사용자에게 전역 스키마의 분할 상태를 알려주는 역할을 함.
  - 사용자가 입력한 전역 질의를 여러 개의 단편 질의로 변환해 주기 때문에 사용자는 전역 스키마가 어떻게 분할되어 있는지를 알 필요가 없게 됨.
- 위치 투명성 (Location Transparency)
  - 사용자나 애플리케이션에서 어떤 작업을 수행하기 위해 분산 데이터베이스상에 존재하는 어떠한 데이터의 물리적인 위치도 알 필요가 없어야 함.
  - 사용자는 분산 환경과는 무관하게 동일한 명령을 사용할 수 있어야 함.
- 중복 투명성 (Replication Transparency, 복제 투명성)
  - 중복된 데이터가 무엇인지와 저장 위치 등에 대한 정보를 사용자가 별도로 인지할 필요가 없어야 한다는 것임.
  - 사용하고 있는 데이터가 논리적으로 유일하다고 생각할 수 있는 환경을 제공해야 함.
- 장애 투명성 (Failure Transparency, 장애 고장 투명성)
  - 데이터베이스의 분산된 물리적 환경에서 특정 지역의 컴퓨터 시스템이나 네트워크에 장애가 발생해도 데이터 무결성이 보장된다는 것.
- 병행 투명성 (Concurrency Transparency)
  - 다수의 트랜잭션이 동시에 수행되는 경우에도 결과의 일관성이 유지되어야 한다는 것.



#### 데이터웨어하우스

- 개념
  - DataWarehouse



#### 하둡

- Hadoop

- 스쿱 (Sqoop)
- 맵리듀스 (MapReduce)



## 5. 데이터 전환

### 데이터 전환(하)



### 데이터 정제(하)



# 4과목 프로그래밍 언어 활용

## 1. 프로그래밍 언어 기초

### 프로그램 언어와 번역(하)

#### 라이브러리

- Library
- 개념
  - 도서관처럼, 필요할 때 찾아서 쓸 수 있도록 모듈화되어 제공되는 부품화된 프로그램임.
  - 일반적으로 내장 함수, 지원 함수, 지원 프로그램 등을 말함.
- 구성
  - 도움말
  - 설치 파일
  - 샘플코드
- 표준 라이브러리
  - 프로그래밍 언어가 기본적으로 가지고 있는 라이브러리를 의미함.
  - 별도의 파일 설치 없이 사용할 수 있음.
- 외부 라이브러리
  - 별도의 파일을 설치해야 함.
  - 누구나 개발 설치 가능하고 인터넷 이용하여 공유할 수도 있음.
- C언어의 대표적인 라이브러리
  - stdio.h : 표준 입출력에 사용되는 함수, scanf, printf 등
  - string.h : 문자열 처리에 사용되는 함수, strlen, strcpy 등
  - math.h : 수학 함수, sqrt, abs 등
  - stdlib.h : 자료형 변환, 난수, 메모리 할당 함수, atoi, rand, malloc 등
  - time.h : 시간 처리 함수, time, clock 등



#### 스크립트 언어

- Script Language
- 원시 코드를 컴파일하지 않고도 실행할 수 있는 프로그래밍 언어.
- 스크립트 언어는 별도의 컴파일 없이 내장된 번역기(interpreter)에 의해 번역되므로 바로 실행할 수 있음.
- 스크립트 언어에는 Javascript, PHP, Basic, Python 등이 있음.



### 자료 객체(하)



## 2. 프로그래밍 언어 활용

### 알고리즘과 코딩(중)

#### 알고리즘 설계 기법

- 동적 계획법
- 탐욕적 알고리즘
- 재귀적 알고리즘
- 근사 알고리즘
- 배낭 알고리즘
- 분할 정복법
- 퇴각 검색법



#### 클린 코드 작성 원칙

- 가독성
- 단순성
- 의존성
- 중복성
- 추상화



#### 표준화된 코딩 형식

- 하나의 명령을 하나의 라인에 코딩함
- 명령어를 구분할 수 있는 줄 바꿈을 적절히 사용함
- 등등



#### C언어 변수명 작성 규칙

- 영문자, 숫자, 밑줄 문자(_)를 사용함.
- 첫 글자는 반드시 영문자로 시작해야 함. 밑줄 문자는 영문자로 취급되어 첫 글자로 사용할 수 있음.
- 영문자는 대소문자를 구분함.
- 공백을 포함하거나 다른 특수 문자를 포함해서는 안 됨.
- 예약어를 변수명으로 사용할 수 없음.



C언어의 문자열 함수

- strcpy() : 문자열을 복사함.
- strncpy() : 문자열에서 지정한 부분만큼 복사함.
- strcat() : 두 개의 문자열을 합침.
- strncat() : 두 개의 문자열을 지정한 부분만큼 합침.
- strlen() : 문자열의 길이를 셈.



### C언어와 연산자(하)

### C언어의 제어문(하)

### C언어의 고급 기법(하)

### 파이썬(Python)(하)



## 3. 객체지향 기술

### 객체지향 기술의 개념(중)

### 객체지향 개발 순서(상)

### 자바(Java)(하)

### UML 다이어그램(중)

### 디자인 패턴(Design Pattern)(중)



## 4. 프로그램 개발 환경 구축

### 프로그램 개발 환경(하)

### 배치 프로그램(하)



## 5. 명령어와 주소 지정

### 명령어 수행 순서(하)

### 명령어 형식과 주소 지정(하)



## 6. 운영체제

### 운영체제의 개념(상)

### 프로세스 관리(중)

### 기억 장치 관리(중)

### 디스크 관리(하)

### 분산 운영체제(하)



# 5과목 정보 시스템 구축 관리

## 1. 정보 통신의 기초

### 정보 통신(하)

### 데이터 전송의 기초(하)



## 2. 데이터 전송 제어

### 데이터 전송 제어(하)

### 회선 공유 기술(하)

### 통신망 기술(하)



## 3. 통신 프로토콜

### 통신 프로토콜(Protocol)(하)

### 인터넷 프로토콜(TCP/IP)(상)

### 신기술 동향(중)



## 4. 시스템 보안 구축

### 정보보호(하)

### 시스템 보안(하)

### 시스템 보안 설계와 구현(하)



## 5. 보안 공격 및 예방

위험 관리(하)

악성 프로그램(상)

정보보호 대책(하)



## 6. 암호 기술

### 암호 기술(하)

### 블록 암호와 스트림 암호(하)

### 전자서명(하)

### 네트워크 보안 기술(하)

### 인터페이스 보안(하)

### 정보 추적 기술(중)

