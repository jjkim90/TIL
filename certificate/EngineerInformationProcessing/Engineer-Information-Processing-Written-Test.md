1-18



# 1과목 소프트웨어 설계

## 1. 소프트웨어의 종류 및 개발 방법론

### 소프트웨어 분류 및 특성(중)

#### 시스템 소프트웨어

- 시스템의 기본 요소



#### 플랫폼

- 플랫폼의 성능 특성 분석 항목 : 가용성, 응답 시간 등등등



#### 프레임워크

- 프레임워크 적용할 경우 기대 효과



#### 컴포넌트

- CBD



#### 소프트웨어 공학



### 소프트웨어 개발 방법론(상)



#### 미들웨어

- 개념
  - 미들과 소프트웨어의 합성어
  - 운영체제와 해당 운영체제에서 실행되는 응용 프로그램 사이에서 운영체제가 제공하는 서비스 이외에 추가적인 서비스를 제공하는 소프트웨어
  - 클라이언트와 서버 간의 통신을 담당하는 소프트웨어
  - 시스템 간의 데이터 교환에 일관성을 보장함
  - 여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어
  - 소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공함
  - 여러 컴포넌트를 1대1, 1대다, 다대다 등 여러 가지 형태로 연결이 가능함.
  - 이기종 하드웨어, 소프트웨어, 네트워크, 프로토콜, PC 환경, 운영체제 환경 등에서 시스템 간의 표준화된 연결을 도와주는 소프트웨어임.
- **미들웨어의 종류**
  - DBMS(Database Management System, 데이터베이스)
    - 데이터베이스 벤더에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어
    - DB를 사용해 시스템을 구축하는 경우 보통 2-Tier 아키텍처라고 함
    - 마이크로소프트 ODBC, 볼랜드의 IDAPI, 오라클의 Glue
  - RPC(Remote Procedure Call, 원격 프로시저 호출)
    - 응용 프로그램의 프로시저를 사용해 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어.
    - 이큐브 시스템즈의 Entera, OSF의 ONC/RPC
  - MOM(Message Oriented Middleware, 메시지 지향 미들웨어)
    - 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어
    - 온라인 업무보다 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용됨.
    - IBM의 MQ, 오라클의 Message Q, JPC의 JMS
  - TP-Monitor(Transaction Processing Monitor, TP모니터)
    - 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션을 처리 및 감시하는 미들웨어
    - 사용자 수가 증가하더라도 빠른 응답속도를 유지해야 할 경우 주로 사용됨.
    - 오라클의 tuxedo, 티맥스소프트의 tmax
  - ORB(Object Request Broker, 객체 요청 브로커)
    - 객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현한 미들웨어
    - TP-Monitor의 장점인 트랜잭션 처리와 모니터링을 추가한 제품도 나오고 있음.
  - WAS(Web Application Server, 웹 어플리케이션 서버, 와스)
    - 정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위한 미들웨어
    - 클라이언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어임
    - HTTP 세션 처리를 위한 웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현이 가능함.
    - 오라클의 WebLogic, IBM의 WebSphere



#### DBMS



#### WAS

- 종류



#### 소프트웨어 개발 방법론

- 구조적 방법론
  - 프로세스 중심의 하향식 방법론
  - 복잡한 문제를 다루기 위해 분할과 정복(Divide and Conquer) 원리를 적용함.
  - 구조적 프로그래밍 표현을 위해 나씨-슈나이더만 차트를 사용한다.
- 정보공학 방법론
  - 정보 시스템 개발에 필요한 절차와 작업 기법을 체계화한 방법론
  - 개발주기를 이용해 대형 프로젝트를 수행하는 체계적인 방법론
  - 정보공학 방법론에서 데이터베이스 설계의 표현으로 사용하는 모델링 언어는 E-R 다이어그램
- 객체지향 방법론
  - 객체라는 기본 단위로 시스템을 분석 및 설계하는 방법론
- 컴포넌트 기반 방법론(CBD, Component Based Development)
  - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
  - 개발 기간 단축으로 인한 생산성 향상
  - 새로운 기능 추가가 쉬운 확장성
  - 소프트웨어 재사용이 가능
- 애자일 방법론
  - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론
- 제품 계열 방법론(Product Line Development)
  - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
- 나씨-슈나이더만(Nassi-Shneiderman) 차트
  - 논리의 기술에 중점을 둔 도형식 표현 방법
  - 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현함
  - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합함.



#### 객체지향

- 개념
  - 현실 세계의 개체(Entity)를 기계 부품처럼 하나의 객체(Object)로 만들어, 기계적인 부품들을 조립해 제품을 만들듯이 소프트웨어를 개발할 때에도 객체들을 조립해서 작성할 수 있는 기법
  - 소프트웨어의 재사용 및 확장 용이, 유지 보수 쉬움
  - 복잡한 구조를 단계적 계층적으로 표현
- 객체(Object)
  - 데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 소프트웨어 모듈
  - 데이터 = 속성, 상태, 변수, 상수, 자료구조
  - 함수 = 메소드, 서비스, 동작, 행위
  - 독립적으로 식별 가능한 이름을 가짐
  - 객체가 가질 수 있는 조건 = 상태(State)
- 클래스(Class)
  - 공통된 속성과 연산을 갖는 객체의 집합, 객체의 일반적인 타입을 의미
  - 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
  - 클래스에 속한 각각의 객체 = 인스턴스(Instance)
  - 동일한 클래스에 속한 각각의 개체들은 공통된 속성과 행위를 갖음
- 캡슐화(Encapsulation)
  - 데이터와 데이터를 처리하는 함수를 하나로 묶은 것을 의미
  - 불필요한 기능 최소화
  - 소프트웨어 개발 비용 절감
  - 개발 속도 향상
- 상속(Inheritance)
  - 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려 받는 것
  - 하위 클래스는 상위 클래스로부터 받은 속성과 연산 외에도 새로운 것을 첨가할 수 있음.
  - 소프트웨어의 재사용을 높이는 중요한 개념임
  - 다중 상속 : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속 받는 것
- 다형성(Polymorphism)
  - 하나의 메시지에 대해 여러 가지 형태의 응답이 있는 것.
  - 하나의 메시지에 대해 각 객체가 갖고 있는 고유한 방법대로 응답하는 것을 의미함
  - 하나의 클래스나 메소드가 다양한 방식으로 동작이 가능한 것을 의미함.
  - 오버로딩과 오버라이딩이 존재함.
    - 다형성의 오버라이딩 : 상속 관계에서 상위 클래스 메소드를 하위 클래스에서 재정의하는 것
    - 다형성의 오버로딩 : 하나의 클래스 내에서 같은 이름으로 여러 개 메소드 정의

- 정보은닉(Information Hiding)
  - 캡슐화에서 가장 중요한 개념으로 다른 객체에 자신의 정보를 숨기는 것을 말함.

  - 연산만을 통해 접근을 허용함

  - 각 객체의 수정이 다른 객체에 주는 Side Effect를 최소화하는 기술임

- 추상화(Abstraction)
  - 불필요한 부분을 생략, 객체 속성 중 가장 유용한 것에 중점을 두어 모델화하는 것을 말함.

  - 완전한 시스템 구축 전, 그 시스템과 유사한 모델을 만들어 여러 요인들을 테스트할 수 있음.




#### 애자일

- 개념

  - 애자일 방법론은 소프트웨어 개발방법론의 하나로 개발과 함께 즉시 피드백을 받아서 유동적으로 개발하는 방법

- 특징

  - 프로젝트의 요구사항은 기능 중심으로 정의
  - 절차와 도구보다 개인과 소통을 중요하게 생각
  - 작업 계획을 짧게 세워 요구 변화에 유연하고 신속하게 대응
  - 소프트웨어가 잘 실행되는 데 가치를 둠
  - 고객과의 피드백을 중요하게 생각

- 애자일 선언문

  - 공정과 도구보다 개인과 상호작용
  - 계획을 따르기보다 변화에 대응하기
  - 포괄적인 문서보다 동작하는 소프트웨어
  - 계약 협상보다 고객과의 협력

- 애자일 방법론 유형

  - 익스트림 프로그래밍
    - XP(eXtreme Programming) 기법
    - 애자일 방법 중 제일 많이 알려진 기법
    - 소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법
    - 익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것.
    - 5가지 핵심가치 (피존의용단)
      - 용기
      - 단순성
      - 의사소통
      - 피드백
      - 존중
    - XP 개발 프로세스
      - 사용자 스토리
      - 릴리즈 계획 수립
      - 스파이크 : 간단한 프로그램. 처리할 문제 외의 다른 조건 모두 무시
      - 주기(Iteration) : 1~3주 정도의 기간으로 진행.
      - 승인 검사(인수 테스트) : 고객이 직접 수행. 오류 발견시 다음 이터레이션에 포함
      - 소규모 릴리즈
    - XP의 주요 실천 방법
      - Pair Programming(짝 프로그래밍) : 책임 분산
      - Test-Driven Development(테스트 주도 개발)
      - Whole Team(전체 팀)
      - Continuous Integration(계속적인 통합) : 모듈 하나 마무리될 때마다 지속적 통합
      - Design Improvement(Refactoring, 리팩토링) : 기능 변경 없이 재구성
      - Small Release(소규모 릴리즈)
      - 40-Hour Work
      - On Site Customer(고객 상주)
      - Collective Ownership(공통 코드 소유)
  - 스크럼(SCRUM)
    - 팀이 중심이 되어 개발의 효율성을 높인다
    - 제품 책임자(PO, Product Owner) : 개발 의뢰자, 백로그 작성
    - 스크럼 마스터(SM, Scrum Master) : 조언. 진행 사항 점검. 장애 요소 공론화
    - 개발팀(DT, Development Team) : PO, SM 제외한 모든 팀원, 백로그 우선순위x
    - 스크럼 개발 프로세스
      - 제품 백로그(Product Backlog)
      - 스프린트 계획회의(Sprint Planning Meeting)
      - 스프린트(Sprint)
      - 일일 스크럼 회의(Daily Scrum Meeting)
      - 스프린트 검토 회의(Sprint Review)
      - 스프린트 회고(Sprint Retrospective)

  - 린(LEAN)
    - 도요타의 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론
    - 린의 7가지 원칙(낭품지 확인사전)
      - 낭비제거
      - 품질 내재화
      - 지식 창출
      - 늦은 확정
      - 빠른 인도
      - 사람 존중
      - 전체 최적화



#### 테일러링

- 필요성 내부기준 외부기준



#### 보안 개발 방법론

- MS-SDL, Seven Touchpoints 등



### 프로젝트 관리 및 생명주기 모형(상)

#### 인적 자원

- 개발자팀 구성 / 책임 프로그래머팀의 구성원 / 책임 프로그래머팀과 민주주의식팀의 비교



#### 위험 분석

- 개념
  - Risk Analysis
  - 프로젝트 추진 과정에서 예상되는 각종 돌발 상황을 예상하고 이에 대한 적절한 대책을 수립하는 일련의 활동.
- 위험 분석 절차
  - 위험 식별(Identification) : 위험 요소가 될 사항들을 파악함.
  - 위험 분석 및 평가 : 위험의 비중과 영향력을 파악함.
  - 위험 관리 계획 : 문서화.
  - 위험 감시 및 조치 : 위험을 항상 관찰하고, 발생 시 조치함.
- 위험 감시
  - Risk Monitoring
  - 위험 요소 징후들을 계속적으로 인지하는 것.
- 위험 회피
  - Risk Avoidance
  - 예상할 수 있는 위험을 회피하는 것. 상책.



#### CPM

- Critical Path Method

#### 비용 측정

- 간접 측정 평가 공식 : 생산성 / 개발기간 / 개발비용



#### 비용 측정 방법론의 분류



#### LOC 측정



#### COCOMO 모형



#### Putnam 모형



#### 형상 관리



#### 소프트웨어 생명주기

- Software Life Cycle
- 폭포수 모형(Waterfall)
  - 이전 단계를 확실히 마무리하고 다음 단계로 진행
  - 가장 오래됐고 폭넓게 사용
  - 선형 순차적 모델
  - 매뉴얼 작성 필수
  - 결과물 명확
- 프로토타입 모형(Prototype, 원형 모형)
  - 시제품을 만들어 최종 결과물 예측
  - 사용자와 시스템 사이 인터페이스에 중점
- 나선형 모형(Spiral)
  - 폭포수모형+프로토타입모형+위험분석 기능
  - 나선을 따라 돌듯이 여러 번의 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어 개발
  - 위험 관리 및 최소화가 목적
  - 누락되거나 추가된 요구사항을 첨가할 수 있음
  - 정밀하고 유지보수 과정이 필요 없음
- 애자일 모형(Agile)
  - 고객 요구사항 변화에 빠르고 유연하게 대응
  - 일정한 주기를 반복하며 진행
  - 고객과의 소통에 초점을 맞춘 모든 방법론을 통칭
  - 스프린트 또는 이터레이션이라 불리는 짧은 개발 주기 반복
  - 반복되는 주기마다 결과물에 대한 평과와 요구 수용

#### 테일러링을 위한 품질 관리

- ISO 12207 표준
- ISO/IEC
- CMM
- SPICE 모델



## 2. 요구사항 확인

### 현행 시스템 파악(하)

#### 현행 시스템 파악 개념

#### 저장 장치

- DAS
- NAS
- SAN
- SDS

#### 모듈화

- 79p



### 요구사항 정의(상)

#### 요구사항 정의

- 개념
  - 어떠한 문제를 해결하기 위해 필요한 조건이나 제약사항을 요구하는 것.
- 요구사항의 유형
  - 기능적 요구사항(Functional)
    - 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항
    - 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지, 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사항
    - 시스템이 반드시 수행해야 하는 기능
    - 사용자가 시스템을 통해 제공받기를 원하는 기능
  - 비기능적 요구사항(Non-functional)
    - 시스템 장비 구성 요구사항
    - 성능 요구사항
    - 인터페이스 요구사항
    - 데이터 요구사항
    - 테스트 요구사항
    - 보안 요구사항
    - 품질 요구사항
    - 제약 사항
    - 프로젝트 관리 요구사항
    - 프로젝트 지원 요구사항


#### 요구사항 개발 프로세스

- 도출(Elicitation) -> 분석(Analysis) -> 명세(Specification) -> 확인(Validation)
- 요구사항 도출(Elicitation, 수집)
  - 시스템, 사용자, 그리고 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항이 어디에 있는지, 어떻게 수집할 것인지를 식별하고 이해하는 과정
  - 요구사항 도출 단계에서 개발자와 고객 사이의 관계가 만들어지고 이해관계자가 식별됨.
  - 주요 기법
    - 인터뷰
    - 설문
    - 브레인스토밍
    - 프로토타이핑
    - 유스케이스 : 사용자의 요구 사항을 기능 단위로 표현하는 것
- 요구사항 분석(Analysis)
  - 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정
- 요구사항 명세(Specification, 문서화)
  - 요구사항 분석 후 승인될 수 있도록 문서화하는 것
- 요구사항 확인(Validation, 검증)
  - 개발 자원을 요구사항에 할당하기 전에 요구사항 명세서가 정확하고 완전하게 작성되었는지 검토하는 활동
  - 요구사항 문서는 이해관계자들이 검토해야 함

#### 자료 흐름도(DFD)

#### 자료 사전(DD)

#### UML

- Unified Modeling Language. 객체지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어.
- UML의 특징 (가구명문)
  - 가시화 언어
  - 구축 언어
  - 명세화 언어
  - 문서화 언어
- UML 구성 요소
  - 사물 (Things)
  - 관계 (Relationships)
  - 다이어그램 (Diagrams)
- **UML 다이어그램 유형**
  - 구조적 다이어그램 (정적)
    - 클래스(Class)
      - 구성요소 : 클래스 이름 / 속성 / 연산 / 접근 제어자
      - 접근 제어자 : private / public / protected / default
    - 객체(Object)
    - 컴포넌트(Component)
    - 배치(Deployment, 배포)
    - 복합체 구조(Composite structure)
    - 패키지(Package)
  - 행위적 다이어그램 (동적)
    - 유스케이스(Use case, 사용 사례)
      - 구성요소 : 유스케이스 / 액터 / 시스템
      - 관계 : 포함 / 확장 / 일반화
    - 시퀀스(Sequence, 순차)
      - 구성요소 : 객체 / 생명선 / 실행 / 메시지
    - 커뮤니케이션(Communication)
    - 상태(State Machine, State Transition)
    - 활동(Activity)
    - 상호작용 개요(Interaction overview)
    - 타이밍(Timing)
- UML의 관계
  - 연관 관계(Association)
  - 집합 관계(Aggregation)
  - 포함 관계(Composition)
  - 일반화 관계(Generalization)
  - 의존 관계(Dependency)
  - 실체화 관계(Realization)
- UML 확장 모델의 스테레오 타입
  - 기본적 요소 이외에 새로운 요소를 만들어내기 위한 확장 메커니즘
  - '<<>>'(Guillemet, 길러멧) 기호를 사용하여 표현함.

#### 요구사항 검증

- 개념
- 절차

#### 요구사항 검토

- Peer Review
  - 동료 검토
  - 2~3명 정도의 검토 담당자가 수행하는 검토.
  - 다수의 이해관계자에게 요구사항 명세서 작성자가 명세서를 설명하면 이해관계자들이 설명을 들으면서 결함을 발견하는 형태로 진행됨.

- Walk Through
  - 소프트웨어 개발 단계마다 실시하는 비정형 검토회의
  - 오류 조기 검출이 목적
  - 검토 자료를 회의 전에 배포하고 사전 검토한 후 짧은 시간 동안 회의를 진행함
  - 사용사례를 확장하여 명세하거나 설계 다이어그램, 원시코드, 테스트 케이스 등에 적용할 수 있음.
  - 복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용함.
  - 단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해 보는 것임.

- Inspection
  - 소프트웨어 개발에 참여하지 않은 다른 전문가에 의해 오류를 찾아내는 공식적 검토 방법임.
  - 순서는 계획 - 사전교육 - 준비 - 인스펙션 회의 - 수정 - 후속조치
- Prototype
  - 프로토타입.
  - 검증하려는 주요 기능이나 일부분을 임시적으로 개발하여 이해관계자나 고객을 대상으로 시연하면서 요구사항을 검증함.
- Re-Factoring
  - 리펙토링.
  - 오류를 제거하고 새로운 기능을 추가하는 것이 아니라 결과의 변경 없이 프로그램 소스의 구조를 재조정하는 것.
  - 리펙토링은 가독성을 높이고 유지보수를 편하게 함



#### CASE

- 개념
- 특징
- 종류 : SADT BS PSL/PSA SREM



## 3. 화면 설계

### UI 요구사항 확인(하)

#### 사용자 인터페이스(UI)

- 3가지 분야
  - 물리적 제어
  - 기능적 제어
  - 전체 구성 제어
- UI의 특징
  - SW 영역 중 변경이 가장 많이 발생
  - 사용자의 만족도에 가장 큰 영향을 미침
  - 수행 결과의 오류를 줄임
  - 작업 시간 단축, 업무에 대한 이해도 높임
  - 편리성과 가독성 높임
  - 사용자 인터페이스 설계를 위해선 소프트웨어 아키텍처를 반드시 숙지해야 함
- UI의 종류
  - CLI(Command Line Interface) : 명령과 출력이 텍스트 형태
  - GUI(Graphic User Interface) : 아이콘이나 마우스 사용하는 그래픽 형태
  - NUL(Natural User Interface) : 사용자의 말이나 행동으로 기기 조작 형태
  - OUI(Organic User Interface) : 평면 아닌 화면 조작 형태
- UI의 설계 지침
  - 사용자 중심 / 일관성 / 단순성 / 결과 예측 가능 / 가시성 / 표준화 / 접그성 / 명확성 / 오류 발생 해결 등
- UI 요소
  - Text box
  - Password box
  - Radio button
  - Checkbox button
  - Select box
  - Textarea box
  - submit button
  - reset button
  - Toggle button



### UI 설계(하)

#### UI 설계

- UI 설계 원칙
  - 직관성 : 누구나 쉽게 이해, 사용
  - 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 함
  - 학습성 : 누구나 쉽게 배워야
  - 유연성 : 사용자 요구사항 최대한 수용하고 실수 최소화
- UI 개발 필수 기능
  - 사용자 명령을 받아들일 프롬프트 기능
  - 사용자 명령 입력의 검증 기능
  - 에러 처리와 에러 메시지 처리 기능
  - 도움말 지원 기능



## 4. 애플리케이션 설계

### 공통 모듈(중)

#### 모듈

- 개념
  - SW구조를 이루며, 다른 것들과 구별할 수 있는 독립적인 기능을 갖는 단위
  - 서로 모여 하나의 완전한 프로그램으로 만들어질 수 있음.
  - 추상화되어 재사용 및 공유 가능한 수준으로 만들어진 기능 단위를 모듈로 규정함.
- 모듈의 기본 요소
  - 입력 요소, 파라미터
  - 출력 요소 RETURN
  - 기능 요소
  - 기관 요소 : 모듈 내부의 알고리즘을 의미
  - 내부 자료 요소 : 모듈 내부의 기억 장소를 의미

- 모듈의 공유도(Fan-in)와 제어도(Fan-out)
  - 공유도는 얼마나 많은 모듈이 주어진 모듈을 호출하는가를 나타내는 척도. 상위 모듈의 수. 공통 모듈화 측면에서 잘 설계되어 있으나, 단일 실패점이 발생할 수 있으므로 중점 관리 및 더 많은 테스트를 통한 검증이 필요함.
  - 제어도는 주어진 모듈이 호출하는 모듈의 개수, 하위 모듈의 수. 불필요한 기능을 호출하고 있지 않은지 추가 검토를 진행하고 업무 로직을 단순화시킬 수 있는지에 대해서도 검토.

- 모듈의 개수 및 비용 간 상관도
  - x축은 모듈 개수, y축은 노력 비용
  - 모듈 별 개발 비용 : 모듈의 개수가 많을수록 노력 비용 감소(반비례)
  - 모듈 통합 비용 : 모듈의 개수가 많을수록 모듈 통합 비용 증가(비례)
  - 전체 SW 개발 비용 : 모듈 통합 비용과 모듈 개발 비용이 교차되는 부분의 영역이 최소 노력 비용이 됨(두 그래프가 교차되는 지점)



#### 공통 모듈

- 원칙

- 공통 모듈의 재사용 범위 따른 분류



#### 재공학

- 소프트웨어 재사용의 2가지 기본 기술 : 생성 중심, 합성 중심 120p

- 소프트웨어 재사용의 이점



### 모듈의 평가(상)

#### 모듈의 평가 기준

- 결합도
- 응집도



#### 모듈 결합도

- 자료 결합도
- 스탬프 결합도
- 제어 결합도
- 외부 결합도
- 공통 결합도
- 내용 결합도



#### 모듈 응집도

- 우연적 응집도
- 논리적 응집도
- 시간적 응집도
- 절차적 응집도
- 통신적 응집도
- 순차적 응집도
- 기능적 응집도



### 설계 모델링(하)

#### N-S 도표

#### HIPO 도표



### 소프트웨어 아키텍처(하)

#### 시스템 아키텍처

#### 소프트웨어 아키텍처

#### 아키텍처 계층

- 표현계층-UI계층 등등등 137p

#### 마스터/슬레이브 패턴

#### 파이프-필터 패턴



### 코드 설계(하)

#### 코드의 기능

- 3대 기능, 추가 기능

#### 순차 코드

#### 표의 숫자 코드

#### 코드 오류의 종류

- 사본오류 전위오류 이중오류 등등



### 파일 설계(하)



#### 디자인 패턴

- 세부적 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
- 디자인 패턴 특징
  - 재사용 가능한 기본형 코드들이 포함되어 있음
  - 개발 과정 중 문제가 발생하면 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적
  - 한 패턴에 변형을 가하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화
  - 1995년 GoF가 처음으로 구체화 및 체계화
  - GoF의 디자인 패턴은 가장 일반적인 사례에 적용될 수 있는 패턴들을 분류하여 정리함. 가장 많이 사용되는 디자인 패턴
- 생성패턴(Creational Pattern)
  - 추상 팩토리(Abstact Factory)
  - 빌더(Builder)
  - 팩토리 메소드(Factory Method)
  - 프로토타입(Prototype)
  - 싱글톤(Singleton)
- 구조패턴(Structural Pattern)
  - 어댑터(Adapter)
  - 브릿지(Bridge)
  - 컴포지트(Composite)
  - 데코레이터(Decorator)
  - 파싸드(Facade)
  - 플라이웨이트(Flyweight)
  - 프록시(Proxy)
- 행위패턴(Behavioral Pattern)
  - 책임연쇄(Chain of Responsibility)
  - 커맨드(Command)
  - 인터프리터(Interpreter)
  - 반복자(Iterator)
  - 중재자(Mediator)
  - 메멘토(Memento)
  - 옵저버(Observer)
  - 상태(State)
  - 전략(Strategy)
  - 템플릿 메소드(Template Method)
  - 방문자(Visitor)



## 5. 인터페이스 설계

### 인터페이스 요구사항(하)

#### 인터페이스 송신 시스템



### 인터페이스 설계(하)



# 2과목 소프트웨어 개발

## 1. 데이터 입출력 구현

### 자료 표현 단위와 진법(하)

### 고정 소수점과 부동 소수점(하)

### 자료 구조(중)

#### 자료 구조 분류

- 단순 구조(Simple)
  - 프로그래밍 언어에서 제공하는 기본 데이터 타입
  - int, float, double, char 등

- 선형 구조(Linear)
  - 데이터들 사이의 선후 관계가 일대일인 구조.
  - 선형 구조는 크게 순차 구조와 연결 구조로 나눌 수 있음
  - 순차 구조는 삽입과 제거가 자주 일어날 때 처리 시간이 가장 많이 소요되는 자료 구조이며, 연결 구조인 연결 리스트는 데이터의 삽입, 삭제가 가장 용이한 방법임.
  - 스택, 큐, 데크, 선형 리스트, 연결 리스트가 있음.

- 비선형 구조(Non-Linear)
  - 데이터들 사이의 선후 관계가 계층 또는 그물 형태를 가지는 구조.
  - 데이터를 저장시키는 데 있어 데이터와 대응되는 다른 데이터가 여러 개 존재하는 경우의 관계성을 1:N, N:M 구조로 저장시키는 형태 구조를 비선형 구조라고 함.
  - 트리 구조, 그래프 구조가 있음.

- 파일 구조(File)
  - 보조 기억 장치에 데이터값이 실제로 기록되는 자료 구조임.
  - 순차 파일, 색인 파일 등이 있음.




#### 스택

- Stack
- 스택의 구조
  - 데이터를 저장하는 기억 장치가 한쪽으로만 입구와 출구가 있음.
  - 데이터가 저장될 때 입력된 데이터의 위치를 스택 포인터(TOP)가 가리키고 있음.
  - 스택 포인터는 데이터가 입력(PUSH)될 때마다 1씩 증가하며 스택 크기보다 큰 값을 갖게 되면 데이터를 더 이상 기억할 수 없는 오버플로우(Overflow) 상태가 됨.
  - 스택에 데이터가 출력(POP)될 때에는 1씩 감소하며 저장된 데이터가 없을 경우에는 스택 포인터는 0값을 기억하게 됨.

- 스택의 특징
  - 데이터의 삽입과 삭제가 같은 쪽에서 이루어지는 구조임.
  - 스택의 자료 삽입 : TOP 포인트가 스택의 크기(N) 이상이면 오버플로우, 아니면 TOP포인트 1 증가하고 스택에 TOP 포인트가 가리키는 곳에 자료 삽입함.
  - 스택의 자료 삭제 : TOP 포인트가 비어 있으면 언더플로우, 아니면 스택에 TOP 포인트가 가리키는 곳에 자료 삭제하고 TOP 포인트 1 감소.
  - 나중에 입력된 데이터가 먼저 출력하는 메모리 사용 방법.
  - 후입선출(LIFO) 구조.
  - 데이터와 데이터 사이는 1:1 관계임.
  - 함수 호출하여 복귀할 때 / 깊이 우선 탐색 / 재귀적 함수를 호출 사용할 때 / 인터럽트 수행 시 현재 수행 중인 프로세스의 복귀 주소를 저장할 때 / 수식을 우선적으로 연산하기 위한 방법으로 / 0-주소 명령어 방법에서 사용됨.




#### 큐

- Queue
- 큐의 구조
  - 한쪽 방향으로 데이터가 삽입되고 반대 방향으로 데이터가 삭제되는 데이터 구조임.
  - 큐는 가장 먼저 삽입된 데이터가 가장 먼저 삭제되므로 선입선출(FIFO) 구조라고도 함.
  - 데이터를 저장하는 기억 장치가 양쪽으로 있으며 한쪽으로는 입구, 다른 한쪽으로는 출구가 있음.
  - 데이터가 저장될 때 입력된 데이터의 위치를 삽입 포인터(Rear)가 가리키고 있고, 출력된 데이터는 삭제 포인터(Front)가 가리키고 있음.
  - 삽입(Rear), 삭제(Front)

- 큐의 구조
  - 프린터 스풀(Spool) / 입출력 버퍼(Buffer) / 은행 번호표 서비스 / 각종 스케줄링 / 동영상 버퍼 / 인터넷에서 동영상을 실시간으로 받아보는 스트리밍 서비스
  - 키보드를 입력하면 바로 CPU로 전달되지 않고 큐 구조의 버퍼에 대기했다가 CPU에 전달됨.




#### 트리

- Tree

- 트리의 구조
  - 그래프의 특수한 형태로 노드(Node)와 선분(Branch)으로 되어 있고, 정점 사이에 사이클(Cycle)이 형성되어 있지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조임.
  - 트리 구조는 나무를 뒤집은 모습으로 계층 구조를 표현하기에 적합함.
  - 트리는 프로그램의 에러를 찾아내는 구문 분석에서 필요한 기본 이론을 제공함.

- 트리의 용어
  - 노드(Node) : 원
  - 간선(Edge), 링크(Link) : 노드와 연결된 선
  - 루트(Root) 노드 : 뿌리가 되는 노드
  - 단노드 단말노드(Terminal) : 자식이 없는 노드
  - 간노드(Nonterminal) : 자식이 있는 노드
  - 노드의 차수(Degree) : 자식 노드의 개수
  - 노드의 레벨(Level) : 특정 깊이를 가지는 노드 집합. 루트 노드는 1레벨.
  - 노드의 크기(Size) : 자신을 포함한 자식 노드의 수. 차수+1.
  - 노드의 깊이(Depth) : 루트에서 거쳐 간 간선의 수. 레벨-1.
  - 노드의 높이(Height) : 루트에서 가장 깊은 노드. 레벨.
  - 부노드 부모노드(Parent) : 부모 노드
  - 자노드 자식노드(Children) : 자식 노드
  - 제노드(Sibling) : 형제 노드
  - 숲(Forest) : 루트를 제외한 나머지 부분
  - 서브 트리(Sub Tree) : 부분 집합 트리




#### 이진 트리 순회

- 중위 순회 방법(In-order) : 좌근우
- 전위 순회 방법(Pre-order) : 근좌우
- 후위 순회 방법(Post-order) : 좌우근
- 순회 방법 3가지



#### 폴리쉬 표기법

- 중위식(Infix) : 수학식처럼 연산자가 중간에 있는 것.
- 전위식(Prefix) : 연산자가 앞에 있는 것.
- 후위식(Postfix) : 연산자가 뒤에 있는 것.
- 전위식은 CPU 명령어 형식, 후위식은 프로그램의 문법 에러를 확인하는데 주로 사용됨.



### 검색(하)

#### 검색의 시간 복잡도

- 일반적인 알고리즘에서 시간 복잡도는 O(log_2n)이 가장 빠르고 O(n!)이 가장 느림.
- 입력 자료의 개수가 무한히 크다고 가정하는 경우
  - O(long_2n) : 로그형. 이진 검색, 이진 트리 검색에 해당함
  - O(n) : 선형. 수열이나 순차 검색에 해당함
  - O(nlog_2n) : 로그 선형. 퀵 정렬, 힙 정렬, 합병 정렬 시 비교 횟수에 해당함.
  - O(n^2) : 2차형. 선택 정렬, 버블 정렬 시 자료 비교 횟수에 해당함.
  - O(n^3) : 3차형. 행렬 곱셈 알고리즘에 해당함.



#### 이진 검색

- 이분 검색. Binary Search.
- 이진 검색을 하려면 검색 대상의 전체 자료의 수를 알고 있어야 하고, 검색 대상의 자료들이 정렬되어 있어야 함.
- 시간 복잡도는 O(log_2n) 로그형.



#### 이진 트리 검색

- Binary Tree Search
- 검색 대상의 자료를 이진 트리로 변형한 뒤 검색하는 방법.
- 처음 자료는 근노드가 되고 두 번째 자료는 근노드와 비교해서 작으면 왼쪽으로 크면 오른쪽에 연결함.
- 시간 복잡도는 O(log_2n) 로그형.



#### AVL 트리 검색

- Adelson, Velskii, Landis. 균형 이진 트리
- 이진 트리 검색의 효율을 높이기 위해 구성함.
- 트리의 좌우 균형이 맞지 않으면 균형이 맞도록 균형 인수를 +-1이나 0으로 맞추는 트리.
- 노드가 삽입되거나 삭제될 때 트리의 모양이 변함.
- 균형을 측정할 때는 절대적 개수가 아니라 레벨을 비교함.



#### 해싱 검색

- 자료를 찾는 특별한 규칙으로 검색 대상의 자료를 저장하여 자료를 찾음.
- 특별한 규칙이란 해싱 함수를 말하며 해싱 함수의 결과로 자료들의 저장 위치(주소)가 결정됨.
- 해싱 함수로 계산된 저장 위치가 중복될 때에는 충돌이라고 하며 충돌에 대비한 조치가 필요함.
- 서로 다른 탐색키가 해싱 함수를 통해 동일한 해시 주소로 사상될 수 있음.
- 충돌이 발생하지 않는 해싱 함수를 사용한다면 시간 복잡도는 O(1)임.
- 해싱 함수 종류
  - 제산법(Division) : 레코드 키 값을 소수나 전체 자료수로 나누어 그 나머지 값으로 저장할 위치를 정하는 방법.
  - 폴딩법(Folding) : 레코드 키 값을 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방법.
  - 제곱법(Square) : 레코드 키 값을 제곱한 결과 값의 일부를 선택하여 저장할 위치를 정하는 방법.
  - 중간 제곱법(Mid-Square) : 레코드 키 값을 제곱하고, 이 값의 중간 부분을 취하여 홈 주소로 취하는 해싱 방법.
  - 숫자 분석법(Digit Analysis) : 레코드 키 값을 이루는 숫자들의 분포를 파악해서 분포가 고른 부분을 선택해 저장할 위치를 정하는 방법.
  - 기수 변환법(Radix Transformation) : 레코드 키 값을 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수는 절단하고, 이를 다시 버킷의 개수 범위에 맞게 조정하는 방법.
  - 의사 무작위법(Pseudo-random) : 난수를 발생시킨 후 그 난수를 이용하여 저장할 홈 주소의 위치를 정하는 방법.
- 해싱 함수
  - 홈 주소 : 해싱 함수에 의해서 결정됨. 해싱 주소라고도 함.
  - 버킷 : 자료가 저장될 공간.
  - 슬롯 : 하나의 버킷은 여러 개의 슬롯을 가질 수 있음. 충돌 대비
    - 동거자(Synonym, 동의어) : 서로 다른 키 값이지만 해싱 함수에 의해 같은 버킷에 저장되는 키 값들.
  - 충돌 : 해싱 함수에 의해 서로 다른 키가 같은 홈 주소를 갖게 되는 현상.
  - 오버플로우 : 버킷에 할당된 슬롯 수보다 많이 발생하게 되면 버킷에 더 이상 항목을 저장할 수 없는 경우에 발생함.
  - 프로빙(Probing, 조사법) : 충돌이 발생하여 더 이상 같은 홈 주소를 갖는 버킷을 사용할 수 없을 때 사용하지 않는 다른 버킷을 찾아 저장하는 방법으로 1차 조사법, 2차 조사법 등이 있음.
  - 체인법(Chaining) : 해싱에서 오버플로우 발생 시 이를 해결하기 위한 방법으로 연결 리스트를 사용하며 버킷의 크기에 제한을 두지 않는 기법.

#### 그래프 탐색

- 그래프의 모든 정점을 방문하는 것을 그래프 탐색이라고 함.
- 깊이 우선 탐색(DFS : Depth First Search)
  - 스택(Stack) 구조를 이용하여 운용함.
  - 시작 노드(A)에서 인접한 노드 중 하나를 알파벳순으로 스택에 삽입함.
- 너비 우선 탐색(BFS : Breadth First Search)
  - 큐(Queue) 구조를 이용하여 운용함.
  - 시작 노드(A)에서 인접한 노드를 모두 알파벳순으로 큐에 삽입함.



### 정렬(하)

#### 정렬의 시간 복잡도

|      정렬의 분류       |    평균    |    최상    |    최하    |
| :--------------------: | :--------: | :--------: | :--------: |
|    삽입(Insertion)     |   O(n^2)   |    O(n)    |   O(n^2)   |
|      버블(Bubble)      |   O(n^2)   |   O(n^2)   |   O(n^2)   |
|    선택(Selection)     |   O(n^2)   |   O(n^2)   |   O(n^2)   |
|       쉘(Shell)        |  O(n^1.5)  |    O(n)    |  O(n^1.5)  |
|       퀵(Quick)        | O(nlog_2n) | O(nlog_2n) |   O(n^2)   |
|        힙(Heap)        | O(nlog_2n) | O(nlog_2n) | O(nlog_2n) |
| 이진 병합(2-Way Merge) | O(nlog_2n) | O(nlog_2n) | O(nlog_2n) |
|      버킷(Bucket)      |   O(dn)    |   O(dn)    |   O(dn)    |



#### 선택 정렬

- 첫 번째 위치에 가장 작은 값을 위치시킴.

- Pass 2에서는 첫 번째 위치를 제외한 자리 중 첫 번째 위치에 가장 작은 값을 위치시킴.

  

#### 버블 정렬

- Pass 1 : 1,2 비교 2,3 비교 3,4비교 끝까지
- Pass 2 : 제일 뒤를 제외하고 다시 처음부터 Pass 1 진행함.



#### 삽입 정렬

- Pass 1 : 2를 키값으로 설정하여 1,2 비교
- Pass 2 : 3을 키값으로 설정하여 1,2,3 비교
- 정렬할 자료 일부가 정렬되어 있는 경우에 유리한 방법.



#### 힙 정렬

- 임의의 자료에서 최솟값 또는 최댓값을 구할 경우 가장 적합한 정렬 방법
- 자료를 순서적으로 완전 이진 트리 형태로 만들어 정렬하는 방법.
- 공식을 통해 시작하는 하위 노드 그룹을 결정하고 오름차순 정렬인 경우 자노드가 부노드보다 크면 자료를 교환함. 공식은 k = n/2



#### 퀵 정렬

- 레코드의 키를 기준으로 작은 값은 왼쪽에 큰 값은 오른쪽 서브 파일로 분해하여 정렬하는 방식.
- 정렬 방식 중에서는 가장 빠른 방식이며, 프로그램에서 재귀적 함수를 이용하기 때문에 스택을 필요로 함.



### 모듈 구현(하)



## 2. 통합 구현

### 통합 구현 도구(하)

#### 형상 관리 도구

- 개념
  - Software Configuration Management. 소프트웨어 구성 관리.
  - 소프트웨어의 변경 사항을 체계적으로 추적하고 통제하는 것.
  - 형상 관리는 일반적인 단순 버전 관리 기반의 소프트웨어 운용을 좀 더 포괄적인 학술 분야의 형태로 넓히는 근간을 의미함.
  - 프로그램 소스 코드나 문서의 버전 관리, 이력 관리, 추적, 변경 사항을 체계적으로 관리할 수 있는 기능을 제공하는 프로그램.
  - 동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구.
- 형상 관리 도구 기능
  - check-out : 저장소에서 개발자 PC로 가져오는 기능. PULL. 최신 버전 아닌 원하는 버전으로 체크아웃하는 것도 가능함.
  - check-in : 개발자가 수정한 소스를 저장소로 업로드하는 기능. PUSH.
  - commit : 개발자가 소스를 형상 관리 도구 저장소에 업로드한 후 최종적으로 업데이트가 되었을 때 형상 관리 서버에 반영되도록 하는 기능. COMMIT.
  - update : 변경 사항이 있는 경우 서버 형상을 로컬 형상으로 가져오는 기능. FETCH.
  - import : 아무것도 들어있지 않은 저장소에 맨 처음 소스를 넣는 기능.
  - export : 버전 관리 파일을 뺀 순수한 소스 파일을 받아올 수 있음. 오픈소스 프로젝트의 경우 소스를 압축하여 릴리즈할 때 사용함.
- 형상 관리 도구 종류
  - RCS (Revision Control System)
    - 파일, 잠금 방식으로 소스 파일 수정은 한 명으로 제한하여 버전 관리.
    - 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식.
  - CVS (Concurrent Versions System)
    - 가장 오랫동안 사용한 형상 관리 도구임.
    - 중앙 집중형 서버 저장소에 클라이언트가 접속해서 버전 관리를 실행함.
    - Diff를 통해 이전 버전과 현재 버전을 비교함.
    - 파일 단위로 변경 사항을 관리함.
    - 직관적이고 비교적 단순한 명령 구조.
    - Commit 실패 시 Rollback하지 못함.
  - SVN(Subversion)
    - CVS의 단점을 보완한 방식이며 CVS 사용자도 쉽게 도입하여 사용 가능.
    - Auto Commit을 사용하기 때문에 실패 시 Rollback할 수 있음.
  - Git
    - 공개 소프트웨어 커뮤니티 중심으로 사용하는 개발자가 많이 확대되고 있는 도구.
    - 분산형 저장소 사용함.
    - 중앙 집중 방식으로도 사용할 수 있는 융통성이 있음.
    - Commit은 로컬 저장소에 이루어지고, PUSH 동작에 원격 저장소에 반영됨.
  - Perforce(P4D)
    - 2014 출시. Merge 속도가 빠름.
    - 여러 가지 편리함.
    - CLI가 상대적으로 약함.



### 연계 통합 구현(하)



### 연계 메커니즘(하)



### 연계 장애 및 오류 처리 구현(하)



### 연계 모듈 구현 환경 구성 및 개발(하)



## 3. 제품 소프트웨어 패키징

### 제품 소프트웨어 패키징(하)

#### 제품 소프트웨어 패키징

- 특징

#### 제품 소프트웨어 패키징 도구

- 개념
  - 제품 소프트웨어의 배포를 위한 패키징 시 디지털 콘텐츠의 지적 재산권을 보호하고 관리하는 기능을 제공함
  - 안전한 유통과 배포를 보장하는 도구이자 솔루션임.
  - 불법 복제로부터 디지털 콘텐츠의 지적 재산권을 보호해 주는 사용 권한 제어 기술, 패키징 기술, 라이선스 관리, 권한 통제 기술 등을 포함함.

- 패키징 도구 활용시 고려사항
  - 반드시 암호화 및 보안 기능을 고려한다
  - 다양한 다른 기종 연동을 고려한다
  - 사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려한다
  - 제품 소프트웨어의 종류에 적합한 암호화 알고리즘을 적용한다
  - 지속적인 배포를 고려한다



#### DRM

- 개념
  - 디지털 저작권 관리. Digital Right Management
  - 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술을 말함.
  - 디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 하드웨어 제조업자, 저작권자, 출판업자 등이 사용할 수 있는 접근 제어 기술을 의미함.
  - 디지털 미디어의 생명 주기 동안 발생하는 사용 권한 관리, 과금, 유통 단계를 관리하는 기술.
- 구성 요소
  - 클리어링 하우스(Clearing House) : 저작권에 대한 사용 권한, 라이선스 발급, 사용량에 따른 관리 등을 수행하는 곳
  - 콘텐츠 제공자(Content Provider) : 콘텐츠를 제공하는 저작권자 ex)작곡가
  - 패키저(Packager) : 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
  - 콘텐츠 분배자(Content Distributor) : 암호화된 콘텐츠를 유통하는 곳이나 사람 ex)멜론
  - 콘텐츠 소비자(Customer) : 콘텐츠 사용 주체 ex) 멜론 이용자
  - DRM 컨트롤러(DRM Controller) : 배포된 콘텐츠의 이용 권한을 통제하는 프로그램 ex) 멜론 플레이어
  - 보안 컨테이너(Security Container) : 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치
- 패키징 도구 구성 요소
  - 암호화
  - 키 관리
  - 암호화 파일 생성
  - 식별 기술
  - 저작권 표현
  - 정책 관리
  - 크랙 방지
  - 인증



### 제품 소프트웨어 매뉴얼(하)

#### 제품 소프트웨어 설치 매뉴얼

- 기본 사항

#### 제품 소프트웨어 사용자 매뉴얼

- 준비절차 / 작성절차



### 제품 소프트웨어 버전 관리(하)

#### 제품 소프트웨어 버전 관리

- 버전 관리 항목 : 가져오기 , 체크아웃, 체크인, 커밋, 리파지토리 등

#### 제품 소프트웨어 버전 관리 도구

- 도구 유형 : 공유폴더방식 클라서버방식 분산저장소방식 등

#### 빌드 자동화 도구

- 개념, 종류



## 4. 애플리케이션 테스트 관리

### 애플리케이션 테스트(하)

#### 테스트 관련 용어

- 디버그 / 디버거 / 워크스루 / 정형 기술 검토

#### 테스트의 원칙



### 단위 테스트(중)

#### 단위 테스트

- 개념
  - 원시 프로그램의 모듈이나(함수, 프로시저, 독립적인 루틴 등) 컴포넌트 대상으로 화이트박스 테스트를 실시하는 방법.
  - 모듈의 기능 수행 여부를 판정하고 내부에 존재하는 논리적인 오류를 검출함.
  - 개별 모듈을 시험하는 것으로 예정된 기능이 제대로 수행하는지를 점검하는 검사임.
  - 구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트한다.
  - 모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다.
  - 테스트할 모듈을 호출하는 모듈도 있고, 테스트할 모듈이 호출하는 모듈도 있다.


- 종류
  - 정적 테스트
    - 애플리케이션 실행하지 않고, 명세서나 소스코드 대상으로 분석하는 테스트
    - 코드 워크쓰루
    - 인스펙션
  - 동적 테스트
    - 애플리케이션을 직접 실행해 오류를 찾음, 소프트웨어 모든 단계에서 테스트
      - 블랙박스 테스트(기능 테스트)
      - 화이트박스 테스트



#### 화이트박스 테스트

- 개념
  - 단위 테스트의 가장 기본적인 방법.
  - 소스 코드의 모든 문장을 한 번 이상 수행함으로써 진행됨.
  - 소스 코드를 보면서 테스트 케이스를 다양화하게 만들어 테스트함.
  - 모듈의 내부 구현을 자세히 테스트함.
- 화이트박스 테스트의 종류
  - 기초 경로 테스트(Base Path Testing, Structure Testing, 구조 테스트)
  - 루프 테스트(Loop Testing)
  - 데이터 흐름 테스트(Data Flow Testing, 논리흐름도)
  - 조건 커버리지(Condition Coverage, 검증 기준)
- 화이트박스 테스트를 통해 찾을 수 있는 오류
  - 세부적 오류
  - 논리 구조상의 오류
  - 반복문 오류
  - 수행 경로 오류
  - 알고리즘 오류에 따른 원치 않는 결과
  - 무한 루프
  - 틀린 계산 수식에 의한 잘못된 결과



#### 블랙박스 테스트

- 개념
  - 프로그램의 외부 사용자 요구사항 명세를 보면서 테스트함.
  - 프로그램의 동작만으로 오류를 찾아 내는 방법.
  - 주로 구현된 기능을 테스트함.
  - 모듈의 내부 구현보다는 입력과 출력에 의해 기능을 테스트함.
  - 프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정함.
- 블랙박스 테스트의 종류
  - 동등(균등, 동치) 분할(Equivalence Partitioning)
  - 경계값 분석(Boundary Value Analysis)
  - 오류 예측(Error Forecast)
  - 원인 결과 그래프(Cause and Effect Graphing)
  - 비교 테스트(Compare Testing)
- 블랙박스 테스트를 통해 찾을 수 있는 오류
  - 인터페이스 오류
  - 자료 구조상의 오류
  - 성능 오류
  - 시작과 종결상의 오류
  - 부정확하거나 빠진 오류
  - 비정상적인 자료를 입력해도 오류 처리를 수행하지 않는 경우
  - 정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우
  - 경계값을 입력할 경우 요구된 출력 결과가 나오지 않는 경우



#### 기초 경로 테스트

- Basic Path Testing, Structure Testing(구조 테스트)이라고 함.
- 흐름 도표 작성 -> 복잡도 계산 -> 복잡도 1당 테스트 1번 시행 -> 복잡도 판정
- 복잡도 계산 방법 : 받는 화살표의 수 + 1
- 복잡도 판정 : 5이하 단순, 6~10 구조적&안정적, 20이상 매우 복잡, 50이상 비구조적&불안정 -> 다시 작성
- 모든 프로그램의 복잡도를 6~10 이하로 만들기 위해서는 모듈화가 필수적임.



#### 경계값 테스트

- 개념
  - 범위의 한계 부분을 집중적으로 검사.
  - 해당 경계값 주변에 값들을 입력하여 정상적으로 출력되는지 확인하여 오류가 발생하면 소스 코드를 수정함.



#### 단위 테스트 도구

- 단위 디버깅의 자동화 도구임.

- JUnit : 자바 프로그래밍 언어용.
- CppUnit : C++ 프로그래밍 언어용.
- HttpUnit : 웹 브라우저 없이 웹 사이트 테스트를 수행하는 데 사용되는 오픈 소스 소프트웨어 테스트 프레임워크.
- Unitest : Python 기반의 단위 모듈 테스트, 디버깅 도구.
- NUnit : .NET 플랫폼 기반의 단위 테스트 프레임워크.



### 통합 테스트(하)

#### 통합 테스트

- 개념
  - 통합 테스트는 소프트웨어 각 모듈 간의 인터페이스 관련 오류 및 결함을 찾아내기 위한 체계적인 테스트 기법을 말함.
  - 단위 테스트가 끝난 모듈 또는 컴포넌트 단위의 프로그램이 설계 단계에서 제시한 동일한 구조와 기능으로 구현된 것인지를 확인하는 것.
  - 설계 명세서와 통합된 프로그램과의 차이를 확인하는 것.
- 수행 방법
  - 점증적인 방식 : 드라이버나 스터브를 사용하여 테스트함. 일부 먼저 테스트
    - 상향식 통합 테스트
    - 하향식 통합 테스트
  - 빅뱅 방식(비 점증적) : 한꺼번에. 드라이버나 스터브 없이 실제 모듈로. 단시간 테스트에 적당하고 작은 시스템에 유리함. 장애 위치 파악 어려우며 모든 모듈이 개발되어야 테스트가 가능함.



#### 하향식 통합 테스트

- 메인 제어 모듈로부터 아래 방향으로 제어의 경로를 따라 이동하면서 하향식으로 통합하면서 테스트함.
- 하위 모듈과 최하위 모듈은 깊이우선 또는 너비우선 방식으로 통합됨.(선택 가능)
- 아직 작성되지 않은 하위 제어 모듈 및 모든 하위 컴포넌트를 대신하여 더미 모듈인 스터브(Stub)를 개발함. 테스트 완료되면 스터브는 실제 모듈 또는 컴포넌트로 대치함.



#### 상향식 통합 테스트

- 최하위 레벨의 모듈 또는 컴포넌트로부터 위쪽 방향으로 제어의 경로를 따라 이동하면서 테스트함.
- 최하위 레벨의 모듈 또는 컴포넌트들이 하위 모듈의 기능을 수행하는 클러스터(Cluster)로 결합함.
- 상위 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈은 드라이버(Driver)를 작성함.
- 필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 드라이버(Driver)라고 함.
- 통합된 클러스터 단위를 테스트함.
- 테스트할 때 프로그램 전체를 실행할 수 없음 (하향식은 가능)
- 테스트할 때 독립적인 구조를 갖지 못함 (클러스터로 묶어야 함. 하향식은 독립적인 구조 가능)
- Stub 필요없음. Driver 필요함
- 하위 모듈 그룹(클러스터) 형성이 필요함
- 중요 모듈을 우선 테스트할 때 적당함



### 시스템 테스트(중)

#### V-모델

- 확인
- 검증
- 부하 테스트

#### 인수 테스트

- 수행 방법 : 알파 / 베타

#### 테스트 자동화 도구

- 정적 분석 도구
- 성능 테스트 도구

#### 테스트 장치 구성

- 드라이버 / 스터브 / 수트 등

#### 테스트 케이스

- 개념
  - 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서를 의미함.
  - 테스트 케이스의 가장 핵심적인 사항은 테스트 항목의 도출임.
  - 프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는 것이 중요함.
- 테스트 케이스 작성 순서
  1. 테스트 계획 검토 및 자료 확보
  2. 위험 평가 및 우선순위 결정
  3. 테스트 요구사항 정의
  4. 테스트 구조 설계 및 테스트 방법 결정
  5. 테스트 케이스 정의
  6. 테스트 케이스 타당성 확인 및 유지 보수



#### 테스트 오라클

- 개념
  - 테스트 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법 및 활동을 말함.
  - 테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준임.
  - 결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 계산하거나 확인함.
- 특징
  - 제한된 검증
  - 수학적 기법
  - 자동화 가능
- 테스트 오라클의 유형
  - 참 오라클(True Oracle) : 모든 입력값에 대해 기대하는 결과를 생성함으로써 발생한 오류를 모두 검출할 수 있는 오라클.
  - 샘플링 오라클(Sampling Oracle) : 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클.
  - 추정 오라클(Heuristic Oracle) : 샘플링 오라클을 개선한 오라클. 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 추정으로 처리하는 오라클.
  - 일관성 테스트 오라클(Consistent Test Oracle) : 소프트웨어 변경이 있을 때, 수행 전과 수행 후의 결과 값이 동일한지 확인하는 오라클.
- 테스트 오라클의 적용 방안
  - 참 오라클은 주로 항공기, 임베디드, 발전소 소프트웨어 등 작은 실수만으로도 치명적인 결과를 초래하는 업무에 적용함.
  - 샘플링/추정 오라클은 일반, 업무용, 게임, 오락 등의 일반적인 업무에 적용함.



### 테스트 결과 분석(하)

#### 테스트 결과 분석

- 결함 종류 : 오류, 결함, 실패 등



### 연계 테스트 및 검증(하)



### 테스트 커버리지(하)



### 성능 분석 및 품질 평가(중)

#### 테스트 관리 지원 도구

- 소스코드 품질 분석 도구(정적 분석 지원 도구) 종류

#### 품질 목표 항목

- 정확성 / 신뢰성 / 효율성 등등등

#### 외계인 코드



## 5. 인터페이스 구현

### 인터페이스 설계 명세(중)

#### EAI

- EAI 구축 유형 : Point-to-Point / Hub&Spoke 등등등

#### 인터페이스 구현 도구

- JSON / XML 등



### 인터페이스 구현 검증(하)

#### 인터페이스 구현 검증 도구

- xUnit / STAF / FitNEsse 등등등



# 3과목 데이터베이스 구축

## 1. 데이터베이스의 개요

### 데이터베이스의 개요(하)

### 데이터베이스 관리 시스템(DBMS)(하)

### 데이터베이스의 종류(상)



## 2. 논리 데이터베이스 설계

### 개체와 속성(하)

### 정보 모델링과 데이터 모델링(하)

### E-R 다이어그램(ERD) 작성(하)

### 관계 스키마와 함수적 종속(상)

### 데이터베이스의 정규화(중)

### 논리 데이터 모델 품질 검증(하)



## 3. SQL

### SQL 명령어(상)

### 절차형 SQL(하)

### 인덱스와 뷰(하)

### SQL 지원 도구(하)

### 병행 제어와 로킹(중)



## 4. 물리 데이터베이스 설계

### 물리 데이터 모델 설계(하)

### 저장 레코드 형식 설계(하)

### 반정규화 수행(하)

### 분산 데이터베이스 설계(중)



## 5. 데이터 전환

### 데이터 전환(하)

### 데이터 정제(하)



# 4과목 프로그래밍 언어 활용

## 1. 프로그래밍 언어 기초

### 프로그램 언어와 번역(하)

### 자료 객체(하)



## 2. 프로그래밍 언어 활용

### 알고리즘과 코딩(중)

### C언어와 연산자(하)

### C언어의 제어문(하)

### C언어의 고급 기법(하)

### 파이썬(Python)(하)



## 3. 객체지향 기술

### 객체지향 기술의 개념(중)

### 객체지향 개발 순서(상)

### 자바(Java)(하)

### UML 다이어그램(중)

### 디자인 패턴(Design Pattern)(중)



## 4. 프로그램 개발 환경 구축

### 프로그램 개발 환경(하)

### 배치 프로그램(하)



## 5. 명령어와 주소 지정

### 명령어 수행 순서(하)

### 명령어 형식과 주소 지정(하)



## 6. 운영체제

### 운영체제의 개념(상)

### 프로세스 관리(중)

### 기억 장치 관리(중)

### 디스크 관리(하)

### 분산 운영체제(하)



# 5과목 정보 시스템 구축 관리

## 1. 정보 통신의 기초

### 정보 통신(하)

### 데이터 전송의 기초(하)



## 2. 데이터 전송 제어

### 데이터 전송 제어(하)

### 회선 공유 기술(하)

### 통신망 기술(하)



## 3. 통신 프로토콜

### 통신 프로토콜(Protocol)(하)

### 인터넷 프로토콜(TCP/IP)(상)

### 신기술 동향(중)



## 4. 시스템 보안 구축

### 정보보호(하)

### 시스템 보안(하)

### 시스템 보안 설계와 구현(하)



## 5. 보안 공격 및 예방

위험 관리(하)

악성 프로그램(상)

정보보호 대책(하)



## 6. 암호 기술

### 암호 기술(하)

### 블록 암호와 스트림 암호(하)

### 전자서명(하)

### 네트워크 보안 기술(하)

### 인터페이스 보안(하)

### 정보 추적 기술(중)

