1-18



# 1과목 소프트웨어 설계

## 1. 소프트웨어의 종류 및 개발 방법론

### 소프트웨어 생명주기

- Software Life Cycle
- 폭포수 모형(Waterfall)
  - 이전 단계를 확실히 마무리하고 다음 단계로 진행
  - 가장 오래됐고 폭넓게 사용
  - 선형 순차적 모델
  - 매뉴얼 작성 필수
  - 결과물 명확
- 프로토타입 모형(Prototype, 원형 모형)
  - 시제품을 만들어 최종 결과물 예측
  - 사용자와 시스템 사이 인터페이스에 중점
- 나선형 모형(Spiral)
  - 폭포수모형+프로토타입모형+위험분석 기능
  - 나선을 따라 돌듯이 여러 번의 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어 개발
  - 위험 관리 및 최소화가 목적
  - 누락되거나 추가된 요구사항을 첨가할 수 있음
  - 정밀하고 유지보수 과정이 필요 없음
- 애자일 모형(Agile)
  - 고객 요구사항 변화에 빠르고 유연하게 대응
  - 일정한 주기를 반복하며 진행
  - 고객과의 소통에 초점을 맞춘 모든 방법론을 통칭
  - 스프린트 또는 이터레이션이라 불리는 짧은 개발 주기 반복
  - 반복되는 주기마다 결과물에 대한 평과와 요구 수용



### 소프트웨어 개발 방법론

- 구조적 방법론
  - 프로세스 중심의 하향식 방법론
  - 복잡한 문제를 다루기 위해 분할과 정복(Divide and Conquer) 원리를 적용함.
  - 구조적 프로그래밍 표현을 위해 나씨-슈나이더만 차트를 사용한다.
- 정보공학 방법론
  - 정보 시스템 개발에 필요한 절차와 작업 기법을 체계화한 방법론
  - 개발주기를 이용해 대형 프로젝트를 수행하는 체계적인 방법론
  - 정보공학 방법론에서 데이터베이스 설계의 표현으로 사용하는 모델링 언어는 E-R 다이어그램
- 객체지향 방법론
  - 객체라는 기본 단위로 시스템을 분석 및 설계하는 방법론
- 컴포넌트 기반 방법론(CBD, Component Based Development)
  - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
  - 개발 기간 단축으로 인한 생산성 향상
  - 새로운 기능 추가가 쉬운 확장성
  - 소프트웨어 재사용이 가능
- 애자일 방법론
  - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론
- 제품 계열 방법론(Product Line Development)
  - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
- 나씨-슈나이더만(Nassi-Shneiderman) 차트
  - 논리의 기술에 중점을 둔 도형식 표현 방법
  - 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현함
  - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합함.



### 애자일

- 개념

  - 애자일 방법론은 소프트웨어 개발방법론의 하나로 개발과 함께 즉시 피드백을 받아서 유동적으로 개발하는 방법

- 특징

  - 프로젝트의 요구사항은 기능 중심으로 정의
  - 절차와 도구보다 개인과 소통을 중요하게 생각
  - 작업 계획을 짧게 세워 요구 변화에 유연하고 신속하게 대응
  - 소프트웨어가 잘 실행되는 데 가치를 둠
  - 고객과의 피드백을 중요하게 생각

- 애자일 선언문

  - 공정과 도구보다 개인과 상호작용
  - 계획을 따르기보다 변화에 대응하기
  - 포괄적인 문서보다 동작하는 소프트웨어
  - 계약 협상보다 고객과의 협력

- 애자일 방법론 유형

  - 익스트림 프로그래밍
    - XP(eXtreme Programming) 기법
    - 애자일 방법 중 제일 많이 알려진 기법
    - 소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법
    - 익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것.
    - 5가지 핵심가치 (피존의용단)
      - 용기
      - 단순성
      - 의사소통
      - 피드백
      - 존중
    - XP 개발 프로세스
      - 사용자 스토리
      - 릴리즈 계획 수립
      - 스파이크 : 간단한 프로그램. 처리할 문제 외의 다른 조건 모두 무시
      - 주기(Iteration) : 1~3주 정도의 기간으로 진행.
      - 승인 검사(인수 테스트) : 고객이 직접 수행. 오류 발견시 다음 이터레이션에 포함
      - 소규모 릴리즈
    - XP의 주요 실천 방법
      - Pair Programming(짝 프로그래밍) : 책임 분산
      - Test-Driven Development(테스트 주도 개발)
      - Whole Team(전체 팀)
      - Continuous Integration(계속적인 통합) : 모듈 하나 마무리될 때마다 지속적 통합
      - Design Improvement(Refactoring, 리팩토링) : 기능 변경 없이 재구성
      - Small Release(소규모 릴리즈)
      - 40-Hour Work
      - On Site Customer(고객 상주)
      - Collective Ownership(공통 코드 소유)
  - 스크럼(SCRUM)
    - 팀이 중심이 되어 개발의 효율성을 높인다
    - 제품 책임자(PO, Product Owner) : 개발 의뢰자, 백로그 작성
    - 스크럼 마스터(SM, Scrum Master) : 조언. 진행 사항 점검. 장애 요소 공론화
    - 개발팀(DT, Development Team) : PO, SM 제외한 모든 팀원, 백로그 우선순위x
    - 스크럼 개발 프로세스
      - 제품 백로그(Product Backlog)
      - 스프린트 계획회의(Sprint Planning Meeting)
      - 스프린트(Sprint)
      - 일일 스크럼 회의(Daily Scrum Meeting)
      - 스프린트 검토 회의(Sprint Review)
      - 스프린트 회고(Sprint Retrospective)

  - 린(LEAN)
    - 도요타의 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론
    - 린의 7가지 원칙(낭품지 확인사전)
      - 낭비제거
      - 품질 내재화
      - 지식 창출
      - 늦은 확정
      - 빠른 인도
      - 사람 존중
      - 전체 최적화



## 2. 요구사항 확인

### 요구사항 정의

- 개념
  - 어떠한 문제를 해결하기 위해 필요한 조건이나 제약사항을 요구하는 것.
- 요구사항의 유형
  - 기능적 요구사항(Functional)
    - 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항
    - 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지, 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사항
    - 시스템이 반드시 수행해야 하는 기능
    - 사용자가 시스템을 통해 제공받기를 원하는 기능
  - 비기능적 요구사항(Non-functional)
    - 시스템 장비 구성 요구사항
    - 성능 요구사항
    - 인터페이스 요구사항
    - 데이터 요구사항
    - 테스트 요구사항
    - 보안 요구사항
    - 품질 요구사항
    - 제약 사항
    - 프로젝트 관리 요구사항
    - 프로젝트 지원 요구사항

- 요구사항 개발 프로세스
  - 도출(Elicitation) -> 분석(Analysis) -> 명세(Specification) -> 확인(Validation)
  - 오구사항 도출(Elicitation, 수집)
    - 시스템, 사용자, 그리고 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항이 어디에 있는지, 어떻게 수집할 것인지를 식별하고 이해하는 과정
    - 요구사항 도출 단계에서 개발자와 고객 사이의 관계가 만들어지고 이해관계자가 식별됨.
    - 주요 기법
      - 인터뷰
      - 설문
      - 브레인스토밍
      - 프로토타이핑
      - 유스케이스 : 사용자의 요구 사항을 기능 단위로 표현하는 것
  - 요구사항 분석(Analysis)
    - 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정
  - 요구사항 명세(Specification, 문서화)
    - 요구사항 분석 후 승인될 수 있도록 문서화하는 것
  - 요구사항 확인(Validation, 검증)
    - 개발 자원을 요구사항에 할당하기 전에 요구사항 명세서가 정확하고 완전하게 작성되었는지 검토하는 활동
    - 요구사항 문서는 이해관계자들이 검토해야 함

### UML

- Unified Modeling Language. 객체지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어.
- UML의 특징 (가구명문)
  - 가시화 언어
  - 구축 언어
  - 명세화 언어
  - 문서화 언어
- UML 구성 요소
  - 사물 (Things)
  - 관계 (Relationships)
  - 다이어그램 (Diagrams)
- **UML 다이어그램 유형**
  - 구조적 다이어그램 (정적)
    - 클래스(Class)
      - 구성요소 : 클래스 이름 / 속성 / 연산 / 접근 제어자
      - 접근 제어자 : private / public / protected / default
    - 객체(Object)
    - 컴포넌트(Component)
    - 배치(Deployment, 배포)
    - 복합체 구조(Composite structure)
    - 패키지(Package)
  - 행위적 다이어그램 (동적)
    - 유스케이스(Use case, 사용 사례)
      - 구성요소 : 유스케이스 / 액터 / 시스템
      - 관계 : 포함 / 확장 / 일반화
    - 시퀀스(Sequence, 순차)
      - 구성요소 : 객체 / 생명선 / 실행 / 메시지
    - 커뮤니케이션(Communication)
    - 상태(State Machine, State Transition)
    - 활동(Activity)
    - 상호작용 개요(Interaction overview)
    - 타이밍(Timing)
- UML의 관계
  - 연관 관계(Association)
  - 집합 관계(Aggregation)
  - 포함 관계(Composition)
  - 일반화 관계(Generalization)
  - 의존 관계(Dependency)
  - 실체화 관계(Realization)
- UML 확장 모델의 스테레오 타입
  - 기본적 요소 이외에 새로운 요소를 만들어내기 위한 확장 메커니즘
  - '<<>>'(Guillemet, 길러멧) 기호를 사용하여 표현함.



### 미들웨어

- 개념
  - 미들과 소프트웨어의 합성어
  - 운영체제와 해당 운영체제에서 실행되는 응용 프로그램 사이에서 운영체제가 제공하는 서비스 이외에 추가적인 서비스를 제공하는 소프트웨어
  - 클라이언트와 서버 간의 통신을 담당하는 소프트웨어
  - 시스템 간의 데이터 교환에 일관성을 보장함
  - 여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어
  - 소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공함
  - 여러 컴포넌트를 1대1, 1대다, 다대다 등 여러 가지 형태로 연결이 가능함.
  - 이기종 하드웨어, 소프트웨어, 네트워크, 프로토콜, PC 환경, 운영체제 환경 등에서 시스템 간의 표준화된 연결을 도와주는 소프트웨어임.
- **미들웨어의 종류**
  - DBMS(Database Management System, 데이터베이스)
    - 데이터베이스 벤더에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어
    - DB를 사용해 시스템을 구축하는 경우 보통 2-Tier 아키텍처라고 함
    - 마이크로소프트 ODBC, 볼랜드의 IDAPI, 오라클의 Glue
  - RPC(Remote Procedure Call, 원격 프로시저 호출)
    - 응용 프로그램의 프로시저를 사용해 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어.
    - 이큐브 시스템즈의 Entera, OSF의 ONC/RPC
  - MOM(Message Oriented Middleware, 메시지 지향 미들웨어)
    - 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어
    - 온라인 업무보다 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용됨.
    - IBM의 MQ, 오라클의 Message Q, JPC의 JMS
  - TP-Monitor(Transaction Processing Monitor, TP모니터)
    - 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션을 처리 및 감시하는 미들웨어
    - 사용자 수가 증가하더라도 빠른 응답속도를 유지해야 할 경우 주로 사용됨.
    - 오라클의 tuxedo, 티맥스소프트의 tmax
  - ORB(Object Request Broker, 객체 요청 브로커)
    - 객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현한 미들웨어
    - TP-Monitor의 장점인 트랜잭션 처리와 모니터링을 추가한 제품도 나오고 있음.
  - WAS(Web Application Server, 웹 어플리케이션 서버, 와스)
    - 정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위한 미들웨어
    - 클라이언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어임
    - HTTP 세션 처리를 위한 웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현이 가능함.
    - 오라클의 WebLogic, IBM의 WebSphere

## 3. 화면 설계

### 사용자 인터페이스(UI)

- 3가지 분야
  - 물리적 제어
  - 기능적 제어
  - 전체 구성 제어
- UI의 특징
  - SW 영역 중 변경이 가장 많이 발생
  - 사용자의 만족도에 가장 큰 영향을 미침
  - 수행 결과의 오류를 줄임
  - 작업 시간 단축, 업무에 대한 이해도 높임
  - 편리성과 가독성 높임
  - 사용자 인터페이스 설계를 위해선 소프트웨어 아키텍처를 반드시 숙지해야 함
- UI의 구분
  - CLI(Command Line Interface) : 명령과 출력이 텍스트 형태
  - GUI(Graphic User Interface) : 아이콘이나 마우스 사용하는 그래픽 형태
  - NUL(Natural User Interface) : 사용자의 말이나 행동으로 기기 조작 형태
  - OUI(Organic User Interface) : 평면 아닌 화면 조작 형태
- UI의 설계 지침
  - 사용자 중심 / 일관성 / 단순성 / 결과 예측 가능 / 가시성 / 표준화 / 접그성 / 명확성 / 오류 발생 해결 등
- UI 요소
  - Text box
  - Password box
  - Radio button
  - Checkbox button
  - Select box
  - Textarea box
  - submit button
  - reset button
  - Toggle button



### UI 설계

- UI 설계 원칙
  - 직관성 : 누구나 쉽게 이해, 사용
  - 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 함
  - 학습성 : 누구나 쉽게 배워야
  - 유연성 : 사용자 요구사항 최대한 수용하고 실수 최소화
- UI 개발 필수 기능
  - 사용자 명령을 받아들일 프롬프트 기능
  - 사용자 명령 입력의 검증 기능
  - 에러 처리와 에러 메시지 처리 기능
  - 도움말 지원 기능



## 4. 애플리케이션 설계

### 모듈

- 개념
  - SW구조를 이루며, 다른 것들과 구별할 수 있는 독립적인 기능을 갖는 단위
  - 서로 모여 하나의 완전한 프로그램으로 만들어질 수 있음.
  - 추상화되어 재사용 및 공유 가능한 수준으로 만들어진 기능 단위를 모듈로 규정함.
- 모듈의 기본 요소
  - 입력 요소, 파라미터
  - 출력 요소 RETURN
  - 기능 요소
  - 기관 요소 : 모듈 내부의 알고리즘을 의미
  - 내부 자료 요소 : 모듈 내부의 기억 장소를 의미

- 모듈의 공유도(Fan-in)와 제어도(Fan-out)
  - 공유도는 얼마나 많은 모듈이 주어진 모듈을 호출하는가를 나타내는 척도. 상위 모듈의 수. 공통 모듈화 측면에서 잘 설계되어 있으나, 단일 실패점이 발생할 수 있으므로 중점 관리 및 더 많은 테스트를 통한 검증이 필요함.
  - 제어도는 주어진 모듈이 호출하는 모듈의 개수, 하위 모듈의 수. 불필요한 기능을 호출하고 있지 않은지 추가 검토를 진행하고 업무 로직을 단순화시킬 수 있는지에 대해서도 검토.

- 모듈의 개수 및 비용 간 상관도
  - x축은 모듈 개수, y축은 노력 비용
  - 모듈 별 개발 비용 : 모듈의 개수가 많을수록 노력 비용 감소(반비례)
  - 모듈 통합 비용 : 모듈의 개수가 많을수록 모듈 통합 비용 증가(비례)
  - 전체 SW 개발 비용 : 모듈 통합 비용과 모듈 개발 비용이 교차되는 부분의 영역이 최소 노력 비용이 됨(두 그래프가 교차되는 지점)



### 객체지향

- 개념
  - 현실 세계의 개체(Entity)를 기계 부품처럼 하나의 객체(Object)로 만들어, 기계적인 부품들을 조립해 제품을 만들듯이 소프트웨어를 개발할 때에도 객체들을 조립해서 작성할 수 있는 기법
  - 소프트웨어의 재사용 및 확장 용이, 유지 보수 쉬움
  - 복잡한 구조를 단계적 계층적으로 표현
- 객체(Object)
  - 데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 소프트웨어 모듈
  - 데이터 = 속성, 상태, 변수, 상수, 자료구조
  - 함수 = 메소드, 서비스, 동작, 행위
  - 독립적으로 식별 가능한 이름을 가짐
  - 객체가 가질 수 있는 조건 = 상태(State)
- 클래스(Class)
  - 공통된 속성과 연산을 갖는 객체의 집합, 객체의 일반적인 타입을 의미
  - 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
  - 클래스에 속한 각각의 객체 = 인스턴스(Instance)
  - 동일한 클래스에 속한 각각의 개체들은 공통된 속성과 행위를 갖음
- 캡슐화(Encapsulation)
  - 데이터와 데이터를 처리하는 함수를 하나로 묶은 것을 의미
  - 불필요한 기능 최소화
  - 소프트웨어 개발 비용 절감
  - 개발 속도 향상
- 상속(Inheritance)
  - 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려 받는 것
  - 다중 상속 : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속 받는 것
- 다형성(Polymorphism)
  - 하나의 메시지에 대해 여러 가지 형태의 응답이 있는 것.

- 다형성의 오버라이딩
  - 상속 관계에서 상위 클래스 메소드를 하위 클래스에서 재정의하는 것
- 다형성의 오버로딩
  - 하나의 클래스 내에서 같은 이름으로 여러 개 메소드 정의



### 디자인 패턴

- 세부적 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
- 디자인 패턴 특징
  - 재사용 가능한 기본형 코드들이 포함되어 있음
  - 개발 과정 중 문제가 발생하면 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적
  - 한 패턴에 변형을 가하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화
  - 1995년 GoF가 처음으로 구체화 및 체계화
  - GoF의 디자인 패턴은 가장 일반적인 사례에 적용될 수 있는 패턴들을 분류하여 정리함. 가장 많이 사용되는 디자인 패턴
- 생성패턴(Creational Pattern)
  - 추상 팩토리(Abstact Factory)
  - 빌더(Builder)
  - 팩토리 메소드(Factory Method)
  - 프로토타입(Prototype)
  - 싱글톤(Singleton)
- 구조패턴(Structural Pattern)
  - 어댑터(Adapter)
  - 브릿지(Bridge)
  - 컴포지트(Composite)
  - 데코레이터(Decorator)
  - 파싸드(Facade)
  - 플라이웨이트(Flyweight)
  - 프록시(Proxy)
- 행위패턴(Behavioral Pattern)
  - 책임연쇄(Chain of Responsibility)
  - 커맨드(Command)
  - 인터프리터(Interpreter)
  - 반복자(Iterator)
  - 중재자(Mediator)
  - 메멘토(Memento)
  - 옵저버(Observer)
  - 상태(State)
  - 전략(Strategy)
  - 템플릿 메소드(Template Method)
  - 방문자(Visitor)



## 5. 인터페이스 설계











# 2과목 소프트웨어 개발



# 3과목 데이터베이스 구축



# 4과목 프로그래밍 언어 활용



# 5과목 정보 시스템 구축 관리