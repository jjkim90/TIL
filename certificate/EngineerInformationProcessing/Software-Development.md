### 소프트웨어 개발



## 1. 데이터 입출력 구현

### 1.1. 자료 표현 단위와 진법(하)

- 자료 표현
  - 니블(Nibble) : 4개의 비트 모여 구성.
  - 워드(Word) : 컴퓨터에서 한 번에 처리될 수 있는 데이터의 양. 보통 범용 레지스터 길이와 같음. 컴퓨터 기종에 따라 다름.
  - 필드(Field) : 몇 개의 워드가 모여서 구성되며 정보 표현의 최소 단위. 보통 데이터베이스 테이블의 하나의 열을 의미하며 항목(Item)이라고도 함.
  - 레코드(Record) : 하나 이상의 필드가 모여서 구성하며 자료 처리의 기본 단위. 데이터베이스 테이블에서 하나의 행을 의미하며 튜플(Tuple)이라고도 함.
  - 블록(Block) : 실제 저장 매체에서 한 번에 읽어 올 수 있는 물리적인 크기로 입출력될 때의 기본 단위.
  - 파일(File) : 서로 관련 있는 레코드의 모임. 컴퓨터 저장 기본 단위.
  - 데이터베이스(Database) : 서로 관련성 있는 파일들의 집합으로 중복을 제거한 집합체.
- 2, 8, 16진수를 10진수 변환 : 거듭제곱으로 계산
- 10진수의 2, 8, 16진수 변환 : 8진수 3자리, 16진수 4자리씩 계산
- 8, 16진수 변환 : 중간에 2진수 거치기

<br>

### 1.2. 고정 소수점과 부동 소수점(하)

- 고정 소수점(정수)
  - 고정 소수점의 표현
    - 음수를 표현하기 위해 부호화 절대치에서 1의 보수, 2의 보수 방법으로 발전됨.
    - 보수는 컴퓨터에서 기본적으로 사용하는 덧셈 연산을 이용하여 뺄셈을 수행하기 위해서 사용함.
    - 현재는 2의 보수 방법으로 음수 표현함.
  - 부호화 절대치
    - 상위 1비트는 부호 비트. 0이면 양수, 1이면 음수.
    - 0이 2개 존재
    - n비트면 -(2^(n-1) - 1) ~ + 2^(n-1) - 1
  - 1의 보수
    - 각 자릿수의 값이 모두 1인 수에서 주어진 2진수를 빼면 1의 보수를 얻음.
    - 상위 1비트 부호 비트, 0이면 양수, 1이면 음수
    - 0이 2개 존재
    - 최대 표현수에 도달하면 그 다음수는 최소 표현수로 회전시킴.
    - n비트면 -(2^(n-1) -1) ~ 2^(n-1) -1
  - 2의 보수
    - 1의 보수에 1을 더한 값.
    - 상위 1비트 부호비트, 0이면 양수, 1이면 음수
    - 0이 하나만 존재함.
    - 최대 표현수에 도달하면 그 다음수는 최소 표현수로 회전시킴.
    - n비트면 -(2^(n-1)) ~ 2^(n-1) -1
- 부동 소수점(실수)
  - 부동 소수점 수의 표현
    - 정규화 과정을 통하여 부호부, 지수부, 가수부로 구성됨.
    - 고정 소수점보다 복잡, 실행 시간 오래 걸림, 아주 큰 수나 작은 수의 표현이 가능함, 정밀도가 제한적임.
  - 부동 소수점의 정규화
    - 47.5 -> 0.475x10^2 -> 0, 475, 2 기억
    - -255.75 -> -0.25575x10^3 -> 1, 25575, 3 기억
  - 부동 소수점 연산
- 자료형 변환 시 확장과 축소
  - 확장(Widening) : 정수형을 실수형으로 변환 시 정보의 손실이 없음.
  - 축소(Narrowing) : 실수형을 정수형으로 변환 시 정보 손실 발생.
- 기억 장치의 용량
  - 저장용량단위 : 2의 10승부터 10단위 차례대로 kb, mb, gb, tb, pb, eb, zb, yb
  - 속도및길이 단위 : deci, centi, 3milli, 6micro, 9nano, 12pico, 15femto, 18atto, 21zepto,24yocto



### 1.3. 자료 구조(중)

- 자료구조
  - 개념
    - 데이터 간 논리적 관계, 효율적인 데이터 컴퓨터 저장 방법
    - 선형 리스트, 스택, 큐, 트리 등이 있음.
  - 데이터 형태에 따른 자료 구조 분류
    - 단순 구조(Simple) : 기본 데이터 타입
    - 선형 구조(Linear)
      - 1:1 대응 구조. 순차 구조와 연결 구조(중간 삽입 용이).
      - 스택, 큐, 데크, 선형 리스트, 연결 리스트가 있음.
    - 비선형 구조(Non-Linear)
      - 1:N, N:M 대응 구조. 트리 구조와 그래프 구조.
    - 파일 구조(File)
      - 보조 기억 장치에 데이터값이 실제로 기록되는 자료 구조.
      - 순차 파일, 색인 파일 등이 있음.
- 선형 구조
  - 스택(Stack)
    - 스택 포인터(TOP) : 입력된 데이터 위치 가리킴. 데이터 입력(PUSH)될 때마다 스택 포인터 1씩 증가하며 스택 크기보다 큰 값을 갖게 되면 오버플로우(Overflow) 상태가 됨. 데이터 출력될 때는 스택 포인터 1씩 감소함. 저장된 데이터 없을 경우 언더플로우(Underflow) 상태가 되어 0값을 기억함.
    - LIFO : 나중에 입력된 데이터가 먼저 출력하는 메모리 사용 방법. 후입선출.
    - 사용 알고리즘 : 함수호출복귀, DFS, 재귀함수, 수식 우선 연산, 0-주소명령어방법
  - 큐(Queue)
    - 한쪽 방향으로 데이터가 삽입되고 반대 방향으로 데이터가 삭제되는 데이터 구조.
    - 선입선출FIFO 구조.
    - 삽입포인터(Rear) : 데이터 삽입시 Rear=Rear+1
    - , 삭제포인터(Front) : 데이터 삭제시 Front=Front+1
    - 사용 알고리즘 : 프린터 스풀, 입출력 버퍼, 은행 번호표, 각종 스케줄링, 동영상 스트리밍.
  - 데크(Deque)
    - 양쪽 모두에서 입력, 출력 가능함.
    - Left포인터, Right포인터 존재.
    - 가장 많이 사용하는 메모리 사용 방법.
    - 데이터 가득 차면 스크롤, 데이터 비어 있으면 셀프 방법 이용하여 조절.
    - 스크롤 : 출력은 양쪽, 입력은 한쪽에서만 사용하는 방법.
    - 셀프 : 입력은 양쪽, 출력은 한쪽에서만 사용하는 방법.
  - 선형 리스트(Linear List)
    - 배열과 같이 연속되는 기억 공간에 저장되는 리스트 구조.
    - 간단한 구조, 접근 속도 빠름. 중간에 자료 삽입하려면 연속된 빈 공간 필요.
    - 삽입, 삭제가 많은 처리에 적합하지 않음.
    - 배열
      - 같은 데이터 타입이 동일한 크기로 순차적으로 나열되어 있는 집합. (레코드 : 이질형의 데이터 집단)
      - 데이터마다 변수 이름 따로 두지 않아 처리 간편함.
      - 배열이름[첨자]. arr[i]
      - 주어진 데이터를 찾을 때 가장 좋은 방법.
      - 논리적 순서와 물리적 순서 같음.
      - 삽입 시 데이터의 평균 이동 횟수 = (n+1) / 2
      - 삭제 시 데이터의 평균 이동 횟수 = (n-1) / 2
      - 정적 메모리 할당 방법을 사용하여 메모리 효율이 떨어짐. <-> 연결리스트 동적 메모리 할당.
  - 연결 리스트(Linked List)
    - 자료들을 임의의 공간에 기억시키되 각 자료의 포인터(Pointer)를 이용하여 연결한 구조.
    - 자료의 삽입과 삭제가 용이함.
    - 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 선형 리스트에 비해 느림.
    - 포인터를 포함한 자료 구조를 노드(Node)라고 하고, 노드에는 포인터의 추가 공간이 필요함.
    - 연결 리스트에 비하여 배열은 임의의 위치에 있는 원소를 접근할 때 효율적.
    - 단일 연결 리스트(Single Linked List) : 최종 노드의 포인터 NULL
    - 단일 환형 연결 리스트(Single Circular Linked List) : 최종 노드의 포인터가 최초 노드를 가리킴.
    - 이중 연결 리스트(Double Linked List) : 한 노드에 2개의 포인터
    - 이중 환형 연결 리스트(Double Circular Linked List)

- 비선형 구조
  - 트리(Tree)
    - 노드와 선분으로 구성. 계층 구조 표현에 적합. 
    - 루트 노트 : 뿌리
    - 단(말)노드(Terminal) : 자식 없는 노드
    - 간노드(Nonterminal) : 자식이 있는 노드
    - 노드의 차수(Degree) : 자식 노드의 개수
    - 트리의 차수(Degree) : 노드의 차수가 가장 큰 값
    - 노드의 레벨(Level) : 특정 깊이를 가지는 노드 집합. 루트노트는 레벨1
    - 노드의 크기(Size) : 자신을 포함한 자식 노드의 수
    - 노드의 깊이(Depth) : 루트에서 거쳐 간 간선의 수
    - 노드의 높이(Height) : 루트에서 가장 깊숙히 있는 노드의 깊이
    - 부노드(Parent) : 부모 노드
    - 자노드(Children) : 자식 노드
    - 제노드(Sibling) : 형제 노드
    - 숲(Forest) : 루트를 제외한 나머지 부분
    - 서브 트리(Sub Tree) : 부분 집합 트리
  - 그래프(Graph)
    - 표시 방법 : G=(V, E) V : 정점, E : 간선
    - 정점(Vertex) : 표현할 자료, 원으로 표시
    - 간선(Edge) : 자료 관계, 선이나 화살표로 표시
    - 무방향성 그래프 : 화살표가 없는 간선
    - 방향성 그래프 : 화살표가 있는 간선
    - 완전 그래프 : 모든 정점에 간선이 연결된 경우
    - 부분 그래프 : 그래프의 일부분, 자기 자신도 부분 그래프
    - 경로(Path) : 정점과 정점으로 연결된 경로
    - 경로의 길이 : 경로에 존재하는 간선의 수
    - 단순 경로 : 중복 없는 경로
    - 사이클(Cycle) : 시작, 종료 정점이 같고 길이가 2 이상
    - 해밀톤 사이클 : 모든 정점을 한 번씩 거쳐 가는 사이클
    - 오일러 사이클 : 임의 경로에서 모든 간선을 한 번씩 사용한 사이클
    - 차수(Degree) : 정점에 연결된 간선의 수
    - 진입차수 : 정점으로 들어오는 차수
    - 진출차수 : 정점에서 나가는 차수
    - 인접(Adjacent) : 무방향 그래프에서 하나의 간선으로 연결된 정점
    - 부속(Incident) : 무방향 그래프에서 인접 관계에 있는 간선 

- 이진 트리 순회
  - 중위(In-order) 순회 방법 : 좌근우
  - 전위(Pre-order) 순회 방법 : 근좌우
  - 후위(Post-order) 순회 방법 : 좌우근
- 폴리쉬 표기법
  - 중위식(Infix) : A+B
  - 전위식(Prefix) : +AB
  - 후위식(Postfix) : AB+
  - 중위식-전위식 변환 A=(B-C)*D+E -> =A+\*\-BCDE
  - 중위식-후위식 변환 A=(B-C)*D+E -> ABC-D\*E\+=

- 



### 1.4. 검색(Search, 탐색)(하)







### 1.5. 정렬(Sort)(하)







### 1.6. 모듈 구현(하)



## 2. 통합 구현

### 2.1. 통합 구현 도구







### 2.2. 연계 통합 구현







### 2.3. 연계 메커니즘







### 2.4. 연계 장애 및 오류 처리 구현







### 2.5. 연계 모듈 구현 환경 구성 및 개발



## 3. 제품 소프트웨어 패키징

### 3.1. 제품 소프트웨어 패키징









### 3.2. 제품 소프트웨어 매뉴얼







### 3.3. 제품 소프트웨어 버전 관리

## 4. 애플리케이션 테스트 관리

### 4.1. 애플리케이션 테스트







### 4.2. 단위 테스트







### 4.3. 통합 테스트







### 4.4. 시스템 테스트







### 4.5. 테스트 결과 분석







### 4.6. 연계 테스트 및 검증







### 4.7. 테스트 커버리지







### 4.8. 성능 분석 및 품질 평가



## 5. 인터페이스 구현

### 5.1. 인터페이스 설계 명세







### 5.2. 인터페이스 구현 검증