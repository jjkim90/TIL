# 소프트웨어 설계



## 1. 소프트웨어 종류 및 개발 방법론

### 1.1. 소프트웨어 분류 및 특성

####  상용 소프트웨어

- 홍보를 위한 무료 소프트웨어도 포함.
- 원시코드 제공하지 않고, 실행 코드(기계어로 된 파일)만 제공하기 때문에 수정이나 추가 등이 불가능함.

- 산업 범용 소프트웨어 3가지 : 시스템 소프트웨어, 미들웨어, 응용 소프트웨어



#### 시스템 소프트웨어

- 시스템의 기본 요소 : 입력, 출력, 처리, 제어, 피드백
- 시스템 소프트웨어 : 응용 프로그램을 실행하기 위한 환경을 제공하고 컴퓨터 하드웨어를 동작시키고 관리하는 소프트웨어.



#### 플랫폼

- 응용 프로그램을 실행하기 위해 사용하는 하드웨어와 소프트웨어의 결합. 응용 프로그램 지원해주는 하드웨어나 소프트웨어 환경.
- 플랫폼으로 소프트웨어 개발 및 운영 비용을 절약할 수 있음. 네트워크 효과를 최대화할 수 있음. 개발 생산성 향상시킬 수 있음.
- 플랫폼의 성능 특성 분석 항목 : 가용성 / 응답시간 / 정확성 / 사용률



#### 프레임워크

- 문제를 해결하기 위한 구조이자 소프트웨어 개발에 있어 하나의 뼈대 역할.
- 소프트웨어 프레임워크 : 설계와 구현을 재사용이 가능한 형태로 제공하는 소프트웨어 환경. 코드 라이브러리, 애플리케이션 인터페이스, 설정 정보 등의 집합. 다양한 소프트웨어 개발을 가능하게 하는 여러 형태의 컴포넌트. 완전한 제품 아님.
- 소프트웨어 프레임워크의 특징
  - 모듈화(Modularity) : 부분적으로 묶어서 처리.
  - 재사용성(Reusability) : 다른 응용 목적으로 사용될 수 있는 정도.
  - 확장성(Extensibility) : 추가 설계 없이 확장 용이성.
  - 제어의 역 흐름(Inversion of Control) : 다형성 통해 제어가 소프트웨어 프레임워크부터 애플리케이션으로 거꾸로 흐르게 함.
- 프레임워크 적용 기대 효과 : 개발 용이성 / 품질 보증 / 변경 용이성 / 유지보수 용이성 / 재사용성 향상 / 표준화율 향상 / 상호 운용성 향상



#### 기업용 소프트웨어

- 오피스웨어  : 기업 업무에 사용되는 소프트웨어. 워드, 파워포인트, 엑셀 등.
- ERP : 기업에서 발생하는 정보들을 서로 공유하고 새로운 정보의 생성과 신속한 의사 결정을 도와줌으로써 전사적(회사 전체 차원)으로 자원을 관리함.
- SCM : 부품 공급자를 지원하는 소프트웨어.
- BI : 구성원에게 적시에 의사 결정을 지원하는 소프트웨어.
- CRM : 고객 특성에 기초한 마케팅 활동을 지원하는 소프트웨어.



#### 컴포넌트

- 모듈 < 라이브러리 < 컴포넌트. 라이브러리를 기능별로 분류하여 지원함.
- 컴포넌트는 독립적으로 사용될 수 있음.
- 컴포넌트 설계시 포함 조건(선행, 결과, 불변)
  - 컴포넌트의 오퍼레이션 사용 전에 참이 되어야 할 선행 조건
  - 사용 후 만족되어야 할 결과 조건
  - 오퍼레이션이 실행되는 동안 항상 만족 되어야 할 불변 조건

- CBD(Component Based Development)
  - 독립적 컴포넌트 단위의 관리로 복잡성 최소화, 재사용성 향상, 개발기간단축, 유지보수비용최소화, 신속구축, 확장 용이.
  - CBD 산출물 목록 : 분석, 설계, 구현, 시험.



#### 소프트웨어 공학(SE: Software Engineering)

- 최소비용 최대품질 소프트웨어 개발 위한 모든 도구 및 방법론 총칭.
- 기본 원칙 : 현대적 프로그래밍 기술 적용, 지속적 검증, 결과 기록 유지, 품질 높은 상품 개발.



### 1.2. 소프트웨어 개발 방법론

#### 소프트웨어 개발 환경

- 운영체제(OS : Operating System)
  - 하드웨어와 소프트웨어 자원을 관리하고 컴퓨터 프로그램을 위한 공통 서비스를 제공하는 시스템 소프트웨어.
  - 운영체제 종류 : Windows, UNIX, Linux, iOS, Android.
  - 운영체제 분석 시 고려사항 : 신뢰도, 성능, 기술지원, 주변기기, 구축비용.
  - CISC -> Windows, Linux / RISC -> UNIX / ARM -> iOS, Android
- CPU(중앙 처리 장치)
  - CISC(Complex Instruction Set Computer) 설계 방식
    - 복잡하고 많은 종류의 명령어와 주소 지정 모드를 사용.
    - 가변 길이 명령어 방식.
    - 100~250개 정도의 많은 명령어 가지고 있어 설계 어려움.
    - 마이크로 프로그래밍(소프트웨어적) 제어 방식.
    - 컴파일 과정이 쉽고 호환성이 좋지만 속도가 느림.
  - RISC(Reduced Instruction Set Computer)  설계 방식
    - 간단하고 적은 종류의 명령어와 적은 수의 주소 지정 모드를 사용.
    - 고정 길이 명령어 방식.
    - 명령어 수가 상대적으로 적음.
    - 효율적인 파이프라이닝 구조 사용.
    - 많은 수의 범용 레지스터 사용됨.
    - 처리 속도가 빠르고 하드웨어 구조 간단해짐. 전력 소모가 적음.
    - 효율성이 떨어지고 호환성이 떨어짐.
    - 고성능 워크스테이션이나 그래픽용 컴퓨터에서 주로 사용됨.
- DBMS(Database Management System)
  - 대량의 데이터를 저장하고 있는 데이터베이스를 생성, 조회, 변경 등의 관리를 하는 프로그램.
  - 종류 : Oracle, IBM DB2, SQL Server, MySQL, SQLite, MongoDB, Redis
  - DBMS 분식 시 고려사항 : 가용성, 성능, 기술지원, 상호호환성, 구축비용.
- 미들웨어(Middleware)
  - OS와 소프트웨어 애플리케이션 사이에 위치함. 소프트웨어 애플리케이션에게 운영체제가 제공하는 서비스를 추가 및 확장하여 제공하는 컴퓨터 소프트웨어.
  - 클라이언트와 서버 간 통신을 담당하는 시스템 소프트웨어.
  - 종류
    - DBMS : DB연결 미들웨어. DBMS시스템 구축하면 2티어 아키텍처라고 함.
    - RPC : 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어.
    - MOM : 메시지 기반 비동기형 메시지 전달하는 미들웨어.
    - TP-Monitor : 트랜잭션 처리, 감시, 제어 프로그램.
    - ORB : 객체 지향 미들웨어. 코바(CORBA) 표준 스펙 구현.
    - WAS : 웹 환경 구현하기 위한 미들웨어.
- WAS(Web Application System)
  - 동적인 웹 사이트, 웹 어플리케이션, 웹 서비스의 개발을 지원하기 위해 설계된 소프트웨어. 데이터 접근 관리, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리를 제공하고 있음.
  - 정적 데이터는 웹 서버가, 동적 데이터는 WAS에서 지원받아 처리.
  - WAS 종류 : GlassFish, JBoss, Jetty, JEUS, Resin, WebLogic, WebSpere
  - WAS 분석시 고려사항 : 가용성, 성능, 기술지원, 구축비용
- 오픈소스(Open Source)
  - 소스 코드를 공개해 누구나 특별한 제한 없이 그 코드를 보고 사용할 수 있는 오픈 소스 라이선스를 만족하는 소프트웨어



#### 소프트웨어 개발 방법론

- 구조적 방법론 : 타당성검토 -> 계획 -> 요구사항 -> 설계 -> 구현 -> 시험 -> 운용/유지보수
  - 모듈 중심 개발.
  - 하향식으로 기능을 분해.
  - 재사용성, 유지보수성이 낮음.
- 정보공학 방법론 : 수직) 정보 전략 계획 -> 업무 영역 분석 -> 업무 시스템 설계 -> 기술 설계 -> 업무 시스템 구축 -> 업무 시스템 실행. 수평)데이터 -> 업무활동 -> 상호작용
  - 자료 구조 중심의 방법론
  - 비교적 안정적이고 데이터와 프로세스가 균형적
  - 기능적 설계 벗어나지 못함. 기능별 유지보수 필요하고 재사용성 낮음.
- 객체지향 방법론 : 요구분석 -> 설계 -> 구현 -> 시험 -> 인수
  - 객체 중심으로 캡슐화, 추상화 기술이 필요.
  - 분석 초점이 명확하고 자연스럽고 유연하며 재사용이 용이함.
  - 개발 전문가가 부족함.
- 컴포넌트 기반 방법론 : 개발준비 -> 분석 -> 설계 -> 구현 -> 시험 -> 전개 -> 인도
  - 공공 행정 정보 시스템의 개발에 많이 활용되고 있는 표준 프로세스.
  - 재사용성, 생산성, 품질 높음.
  - 테스트 환경 부족하고 컴포넌트 평가, 인증 환경이 미흡함.
- 애자일 방법론
  - 반복적인 개발을 통한 잦은 출시를 목표로 함.
  - 애자일 방법론 선언문 : 개인과 상호작용, 동작하는 소프트웨어, 고객과의 협력, 변환의 대응
  - 애자일 방법론의 5가지 가치 : 의사소통, 용기, 피드백, 단순함, 존경
  - XP(eXtreme Programming, 익스트림 프로그래밍) : 소프트웨어 개발 방식을 애자일 모형으로 개발하는 대표적인 방법.
  - 스크럼(SCRUM) : 추정 및 조정 기반의 경험적 관리 기법.
    - 스크럼의 5가지 가치 : 확약, 전념, 정직, 존중, 용기
    - 스크럼의 요소 : 백로그, 스프린트, 스크럼미팅, 스크럼마스터
  - 린(Lean) : 낭비적 요소를 제거하고, 개발 결과를 측정, 성과를 분석하여 품질을 향상시킴.
    - 린의 7가지 원칙 : 낭비적요소제거, 품질내재화, 지식창출, 늦게결정, 빠르게인도, 사람존중, 공정최적화
  - DSDM(Dynamic Systems Development Method)
    - RAD 방식으로 개발하여 소프트웨어 개발 여부를 판단하는 방식.
    - 5단계 : 타당성조사, 비지니스연구, 기능모델반복, 설계, 구현
  - FDD(기능 중심 개발) 방법
    - 사용자가 원하는 기능의 시나리오에 필요한 만큼만 개발하는 방법. 기능 중심 단위 개발.
    - 깊이 우선 통합. 2주의 반복 주기.
- 제품 계열 방법론
  - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론.
  - 임베디드 소프트웨어 작성에 유용한 방법론.
- 테일러링(Tailoring) 개발 방법론
  - 실제 업무 분야별로 융통성 있게 여건에 맞게 수정 보완하는 방법. 표준이 없음.
  - 커스터마이징의 작업이 반복됨.
- 보안 개발 방법론
  - MS-SDL
  - Seven Touchpoints
  - CLASP
  - CWE



### 1.3. 프로젝트 관리 및 생명 주기

#### 프로젝트 관리

- 일정, 예산, 인력, 위험, 품질 관리
- 프로젝트 관리의 3P : 사람, 문제, 프로세스
- 프로젝트 계획 수립
  - 소프트웨어 범위 측정 : 처리기능, 성능, 제한조건, 개발인원, 일정계획
  - 자원 측정 : 하드웨어자원, 소프트웨어자원, 인적자원
- 인적자원
  - 개발자팀 구성 : 책임 프로그래머팀, 민주주의식팀, 혼합형팀
  - 책임 프로그래머팀 : 소규모 개발 유리, 단기, 쉬운 프로젝트, 스타형 구조, 팀원 대다수 만족도 낮고 이직률 높음.
- 일정 계획 방법론
  - PERT(Program-Evaluation and Review Technique) 네트워크
    - 소요 기간 예측 어려울 때 유리함.
    - 작업별로 낙관치, 기대치, 비관치를 나누어 종료 시기를 결정함.
    - 노드에는 작업명, 간선에는 낙관치, 기대치, 비관치 표시
    - 예측치 공식 사용.
    - 비용 측정은 하지 않음.
  - CPM(Critical Path Method) 네트워크
    - 임계경로 기법이라고 함.
    - 소요기간이 확실할 때 유리함.
    - 노드는 작업명, 간선에는 작업 사이의 전후 의존 관계를 표시함.
    - 원형 노드는 작업명, 박스 노드는 이정표와 예상 완료 시간을 표시함.
- 위험 관리
  - 식별, 분석 및 평가, 관리 계획, 감시 및 조치



#### 비용 측정

- 비용 측정 요소
  - 직접 측정 요소 : 인월, 비용, 처리 속도, 문서 수 등
  - 간접 측정 요소 : 비교 대상이 있어야 측정이 가능. 생산성, 품질, 효율성, 신뢰도 등

- 인월(MM: Man Month)
  - 한 사람이 1개월 동안 작업할 양
  - 비용 측정 단위로 가장 많이 사용되는 요소.
- 비용 측정의 원칙
  - 소프트웨어 비용 측정을 최대한 지연시킨다.
  - 분해 기술 이용한다.
  - 실험적 비용 측정 모델 이용한다.
  - 자동화 도구를 이용한다.
- 간접 측정 평가 공식
  - 생산성 = LOC / 인월
  - 개발 기간 = 인월 / 개발 인원
  - 개발 비용 = 인월 x 단위 비용
- 비용 측정 방법론의 분류
  - 하향식
    - 전문가 측정
    - 델파이식 측정 : 여러 전문가 측정 평균치
  - 상향식
    - LOC 측정 : 낙관치 비관치 기대치 -> 예측치 계산.
    - 단계별 인월(Effort per Task 기법) : 단계별 중요도를 인월로 가중치를 부여한 후 측정.
    - 수학적 산정
      - Walston 모형 : 규모 난이도 고려 없어 오차가 많음.
      - COCOMO 모형
        - 유기형(Organic) : 5만 라인 이하.
        - 준 분리형(Semi-Detached) : 30만 라인 이하
        - 내재형(Embedded) : 초대형 규모
      - Putnam 모형 : Rayleigh-Norden 곡선의 노력 분포도 곡선으로 그려짐. Putnam 모형 기초로 만든 자동화 추정 도구 SLIM.
      - 기능 점수 모형 : 사용자 관점에서 기술적 요소 배제하고 측정.
        - 기능 점수의 비용 산정 요소 : 입력유형의수, 출력유형의수, 사용자명령어수, 데이터파일의수, 인터페이스의수
      - 간이 기능 점수



#### 형상 관리(SCM : Software Configuration Management)

- 소프트웨어 개발 과정에서 발생하는 산출물의 변경 사항에 대한 버전 관리 활동.

- 형상 관리 절차 : 형상 식별 -> 변경 제어 -> 형상 상태 보고 -> 형상 감사



#### 소프트웨어 개발의 생명주기 모형

- 폭포수 모형(Waterfall model)
  - 폭포수의 물흐름처럼 한 번 지나가면 다시는 되돌릴 수 없듯이 각 단계를 명확히 하고 다음 단계로 넘어가는 모형
  - 개발 순서 : 타당성 검토 -> 계획 단계 -> 요구분석 -> 설계 단계 -> 구현 단계 -> 검사 단계 -> 운용 + 유지보수
  - 적용 경험과 성공 사례 많음.
  - 요구사항 변경 어려움. 단계별 문서화 작업 필요.
- 프로토타입 모형(Prototyping model)
  - 개발 순서 : 요구 수집 -> 빠른 설계 -> 프로토타입 구축 -> 고객 평가 -> 프로토타입조정 -> 구현
  - 조정 단계에서 다시 사용자에게 요구를 수집하는 첫 번째 단계로 가고, 모든 단계를 사용자의 요구가 만족되는 수준까지 반복함.
  - 요구사항 변경 용이
  - 브룩스(Brooks)의 이론 : 프로토타입 소프트웨어는 폐기 처분하는 첫 번째 시스템이다. 개발 일정 지연된다고 해서 말기에 새로운 인원을 투입하면 일정이 더욱 지연된다.
- 나선형 모형(Spiral model)
  - 개발 순서 : 계획 수립 -> 위험 분석 -> 개발 및 검증 -> 고객 평가
  - 계획 수립부터 모든 단계를 반복하면서 개발함.
  - 폭포수 + 프로토타입 장점 살린 모형.
  - 대규모 시스템의 소프트웨어 개발에 적합함.
- V 모형
  - 개발 순서 : 요구분석 -> 검증 -> 시스템 설계 -> 검증 -> 상세 설계 -> 검증 -> 코딩
  - 코딩을 중심으로 각 단계가 V자 모양을 이루고 있음.
  - 검증을 강조한 기법.
  - 높은 신뢰성을 필요로 하는 의료 제어 시스템이나 원자력 발전소 제어 시스템 등의 개발에 적합함.
- 4세대(4GT : Fourth Generation Techniques) 모형
  - 개발자나 사용자가 쉽게 접근할 수 있는 4세대 언어를 이용한 기법.
  - 자연 언어와 가까운 수준에서 개발할 수 있음.
  - 설계 축소하여 단기간에 개발될 수 있지만 대규모 프로젝트에 어울리지 않음.



#### 테일러링을 위한 품질 관리

- ISO 12207 표준
  - 소프트웨어 개발 프로세스를 정의하고 향상시키기 위한 프로세스.
  - 기본 공정 프로세스 : 공급 / 획득 / 개발 / 운영 / 유지보수
  - 지원 공정 프로세스 : 문서화 / 형상관리 / 문제해결 / 품질보증 / 검증 / 확인 / 합동검토 / 감리
  - 조직 공정 프로세스 : 관리 / 기반 구조 / 개선 / 교육 훈련
- ISO / IEC
  - ISO (International Organization for Standardization, 국제 표준화 기구)
  - IEC (Interna tional Electronical Commission, 국제전기표준회의)
  - ISO / IEC 품질 특성 6가지 : 기능성 / 신뢰성 / 사용성 / 효율성 / 유지보수성 / 이식성
- CMM(Capability Maturity Model)
  - 소프트웨어 개발과 유지보수에 대한 프로세스 개선과 능력 향상을 위한 프레임워크이며 실용화된 모델임.
  - 5가지 성숙 단계와 핵심 프로세스
    1. 초기 단계(Initial) : 없음
    2. 반복 단계(Repeatable) : 요구 관리, 계획, 추적, 감시, 형상 관리, 품질 보증
    3. 정의 단계(Defined) : 조직 프로세스 관리, 교육 훈련 프로그램, 통합 소프트웨어 관리, 생산 공학, 동료 검토, 그룹 간 조정, 중간 심사
    4. 관리 단계(Managed) : 정량적 프로세스 관리, 소프트웨어 품질 관리
    5. 최적 단계(Optimizing) : 결함 예방, 기술 변화 관리, 프로세스 변경 관리
  - CMM 모델 프로세스 평가 기준
    - level1 : 혼돈적 관리
    - level2 : 경험적 관리
    - level3 : 정성적 관리
    - level4 : 정량적 관리
    - level5 : 최적화 관리
- SPICE(Software Process Improvement and Capability dEtermination) 모델
  - 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준.
    - 수준0 : 불안정 단계
    - 수준1 : 수행 단계
    - 수준2 : 관리 단계
    - 수준3 : 확립 단계
    - 수준4 : 예측 단계
    - 수준5 : 최적화 단계
  - 개발 기관이 스스로 평가
  - CMM은 조직 평가. 소규모 업체 적용 곤란함. 조직 전체에 대한 등급 판정 비현실적임.
- CMMI 모델
  - CMM의 후속 모델. 조직의 개발 프로세스 역량 성숙도를 평가.
    - 프로세스 관리 영역 / 프로젝트 관리 영역 / 엔지니어링 영역 / 지원 영역
  - 모델의 종류 : SW-CMM / SECM / IPD-CMM / People-CMM / SA-CMM / SECAM



## 2. 요구사항 확인

### 2.1. 현행 시스템 파악

#### 현행 시스템 파악

- 현행 시스템 파악 절차
  - 1단계 : 시스템 구성/기능 현황 및 인터페이스 파악
  - 2단계 : 시스템 아키텍처 및 소프트웨어 파악
  - 3단계 : 하드웨어 및 네트워크 파악



#### 시스템 구성/기능 현황 및 인터페이스 파악

- 현행 시스템 구성 현황 : 현행 조직의 주요한 업무를 처리하는 동안의 업무와 이를 지원하는 업무로 구분하여 기술.
- 현행 시스템 기능 현황 : 단위 업무 시스템이 현재 제공하고 있는 기능을 기술한 것.
- 인터페이스(Interface) 현황 : 단위 업무 시스템이 다른 단위 업무 시스템과 주고 받는 데이터의 종류, 데이터 형식, 프로토콜, 연계유형 주기 등을 명시한 것.
- 인터페이스 분류
  - 하드웨어 인터페이스 : 입출력 포트, 커넥터, 프로토콜
  - 소프트웨어 인터페이스 : OS와 HW 사이.
  - 사용자 인터페이스 : 컴퓨터와 인간 사이



#### 시스템 아키텍처 및 소프트웨어 파악

- 현행 시스템 아키텍처 구성도 : 현재 업무를 처리하기 위하여 최상위 수준에서 계층별로 어떠한 기술 요소들을 사용하고 있는지 표현한 것.
- 소프트웨어 구성도 : 현재 업무 처리를 위해 설치되어 있는 소프트웨어들의 제품명, 용도, 라이선스 적용 방식, 라이선스 수를 명시한 것.



#### 하드웨어 및 네트워크 파악

- 하드웨어 구성도
- 네트워크 구성도
- 저장 장치(Storage System, 스토리지 시스템)
  - DAS(Direct Attached Storage)
    - 데이터 저장 장치를 호스트 버스 어댑터에 직접 연결.
    - 저장 장치와 호스트 기기 사이에 네트워크 디바이스 없음.
    - 구성이 용이함.
  - NAS(Network Attached Storage)
    - 서버와 저장 장치를 네트워크로 연결하는 방식. 구성 설정이 간편함.
    - 별도의 os가진 서버 한 곳에서 파일을 관리하기 때문에 서버 간에 스토리지 및 파일 공유가 용이함.
  - SAN(Storage Area Network)
    - DAS의 빠른 처리와 NAS의 스토리지 공유 장점을 합친 방식.
    - 광케이블과 광채널 스위치를 통해 근거리 네트워크 환경을 구성하여 빠른 속도로 데이터를 처리할 수 있음.
  - SDS(Software Defined Storage)
    - 기존 저장 장치 시스템의 한계점(데이터 폭증, 예측 불가능한 데이터 등)을 극복하기 위한 소프트웨어 시스템.
    - 하드웨어에서 저장 장치 소프트웨어를 분리하는 스토리지 구조.
    - 하드웨어에 대한 소프트웨어의 종속성을 제거하여 모든 업계에서 표준적으로 동작하도록 설계됨.
    - 서버 가상화와 유사함. 클라우드 시스템을 포함하는 개념.



#### 가상화 기계

- 개념 : 서버 가상화는 한 대의 서버를 많은 서버로 분할하여 이용하는 기술. 서버 가상화로 만든 서버를 가상화 기계 혹은 가상 서버라고 함. 논리적으로 분할하여 OS에 할당.
- 가상화 기계 운영 방법
  - 하이퍼바이저(Hypervisor)형
    - 컴퓨터 시스템에서 다수의 OS 운영할 수 있게 하는 프로그램.
    - 하드웨어와 각각의 가상 시스템을 감시하며 중간 관리자 역할을 하는 것이 하이퍼바이저.
    - 임의의 VM에 오류가 발생해도 다른 VM에 영향을 주지 않음.
    - 호스트 OS, 게스트 OS(가상화기계 VM)
  - 호스트(Host) 하이퍼바이저형
    - 하이퍼바이저가 일반 응용 프로그램처럼 설치되어 운영됨.
  - 컨테이너(Container)형
    - 하이퍼바이저가 없고, 하나의 운영체제만이 존재하는 유형.
    - 컨테이너라는 프로그램이 여러 개의 가상화 기계가 있는 것처럼 논리적으로 운영해줌.
    - 크기가 수십MB에 불과하고 OS 부팅이 필요 없어 서비스 시작 시간도 짧음.
    - 크기가 작아 컨테이너 복제와 배포가 용이함.



#### 전자 정부 프레임워크

- 전자 정부 프레임워크의 계층
  - 공통 기반 계층
  - 화면 처리 계층
  - 업무 처리 계층
  - 데이터 처리 계층
  - 연계 통합 계층
- 전자 정부 프레임워크의 목표
  - 정부는 기본적이고 공통적인 부분(공통 프로그램, 공통 컴포넌트)들을 제시하고, 이 범위 안에서 모든 프로그램이 운영되기를 원함.
- 전자 정부 프레임워크의 장점
  - 공통 컴포넌트 재사용으로 중복 예산 절감
  - 표준화된 개발 기반으로 사업자 종속성 해소
  - 무상 제공으로 비용 경쟁력 향상
  - 표준화된 연계 모듈 활용으로 상호 운용성 향상
  - 개발 표준에 의한 모듈화로 유지보수가 용이



### 2.2. 요구사항 정의

#### 요구공학

- 요구공학은 시스템 요구사항 문서를 생성, 검증, 관리하기 위하여 수행되는 구조화된 활동의 집합.
- 요구사항 개발 프로세스 : 도출 -> 분석 -> 명세 -> 확인
- 요구사항 도출(Requirement Elicitation)
  - 요구사항 출처 누구, 어느 부서, 어디에 있는지 파악
  - 요구사항 수집 방법 파악
  - 도출 기법에는 인터뷰, 스토리텔링, 프로토타이핑, 워크숍, 벤치마킹 등이 있음.
- 요구사항 분석(Requirement Analysis)
  - 사용자 요구 이해하는 실질적 첫 단계
  - 요구사항을 분석하고 정의해서 문서화.
  - 요구사항의 타당성 조사
  - 소프트웨어 범위 파악
  - 분석 기법에는 DFD, DD, E-R Diagram, UML Diagram 등이 있음.
- 요구사항 명세(Requirement Specification)
  - 파악된 요구사항을 체계적으로 검토, 평가하고 승인될 수 있는 문서를 작성
  - 고객도 알 수 있을 정도로 쉽게 작성.
- 요구사항 명세 기법
  - 정형 명세기법
    - 수학적 원리와 표기법을 이용하여 서술
    - 정확하게 표현
    - 가장 강력한 표현 방법으로 도구 사용이 필수적
    - 간결하고 명세와 구현 일치
    - 수학적 이해가 필요하여 사용자와 개발자 간의 부담 생김
    - 종류 : VDM, Z, CSP, CSS 등
  - 비정형 명세기법
    - 자연어 기반 서술
    - 일반적이고 친숙하지만 명세서로 바람직하지 못함
    - 이해가 용이함
    - 불충분한 명세서 작성될 수 있고 모호성 발생할 수 있음.
    - 종류 : FSM, Decision Table, E-R, SADT 등
  - 요구사항 명세서 작성 시 고려사항
    - 쉬운 이해
    - 모두 동의한 내용으로 작성(계약서 역할)
    - 시스템 모든 기능과 모든 제약조건 기술
    - 요구사항 검증 절차도 기술
    - 우선순위에 따른 중요도 기술
  - 요구사항 명세서 작성 원칙
    - 명확성, 완전성, 검증가능성, 일관성, 수정용이성, 추적가능성, 개발후이용성
  - 요구사항 확인(Requirement Validation)
    - 개발단계의 산출물이 최초의 사용자 요구사항 또는 소프트웨어 요구에 적합한지를 입증하기 위한 활동
- 요구사항 도출 기법
  - 사용자 그룹 인터뷰
    - 가능한 많은 사용자 인터뷰
    - 회의록 작성 필수 녹음,  반복 청취
  - 이해관계자 설문 조사
  - 문헌 조사
    - 유사 소프트웨어 문서나 양식 조사하여 형핸 시스템 정보 이해
  - 프로토타이핑
    - 기본 기능만 빠르게 구현하여 사용자 피드백 받기
  - 스토리텔링
    - 애자일 방법에서 주로 사용.
  - 분석과 중재 기술
  - 관찰과 모델 작성



#### 구조적 분석

- 기능(모듈) 중심으로 시스템을 파악하여 순차적인 처리가 중요시되는 하향식 방식

- 구조적 분석의 원리
  - 추상화 원칙
  - 정형화 원칙
  - 분할 정복의 개념
  - 계층적 구조의 개념
- 구조적 분석의 특징
  - 그림 중심의 도형과 도표 형태로 분류
  - 사용자 참여 기회 확대
  - 하향식 분석
- 구조적 분석의 도구(방법론)
  - 자료 흐름도(DFD : Data Flow Diagram)
    - 자료 흐름 그래프 또는 버블 차트라고 함
    - 자료의 흐름은 알 수 있지만 시간의 흐름은 알 수 없음.
  - 자료 사전(DD : Data Dictionary)
    - 소프트웨어에서 사용하는 모든 자료 항목을 규칙에 맞게 정리한 집합.
  - 소단위 명세서(Mini-spec)
    - 처리 절차나 논리적 활동을 프로그램 설계 언어(PDL)로 기술하는 도구.
    - 자료 흐름도 부족한 부분을 간략하게 서술
    - 소규모일 경우 생략  가능.
- 자료 흐름도(DFD)의 표기법
  - 외부입출력 ㅁ
  - 처리과정 O
  - 자료흐름 ->
  - 자료저장소 =
- 자료 사전의 표기법
  - 자료의정의 =
  - 자료의연결 +
  - 자료의선택 [ | ]
  - 자료의반복 { }^n
  - 자료의생략 ( )
  - 자료의설명 **



#### 요구사항 분석 과정

- 요구사항 분류(Requirement Classification)
  - 고수준 요구사항에서 유도됨 vs 이해관계자나 다른 소스로부터 발생
  - 사용용이성, 효율성 vs 입력처리, 데이터베이스처리
  - 형상관리대상 vs 아님
  - 기능적 요구사항 vs 비기능적 요구사항
  - 기능적 요구사항
    - 시스템이 수행해야 하는 행위들을 구체화한 것.
    - 입력기능, 출력기능, 데이터베이스기능, 통신기능 등
  - 비기능적 요구사항
    - 기능 이외의 요구사항
    - 품질, 제약사항 등
    - 사용용이성, 효율성, 신뢰성, 이식성, 유연성, 확장성 등
    - 성능측면 : 응답속도, 자원사용량 등
    - 보안측면 : 침입대응, 침입탐지, 사용자인증, 권한부여 등
- 개념 모델링(Conceptual Modeling)
  - 개념 모델은 문제 도메인의 엔티티들과 그들의 관계 및 종속성을 반영.
  - 요구사항 구체화 위해 UML 사용.
- 요구사항 할당(Requirement Allocation)
  - 요구사항 만족시키기 위한 구성 요소들을 식별한 후 업무에 맞게 할당.
- 요구사항 협상(Requirement Negotiation)
  - 두 명의 이해관계자 서로 의견 다를 때 협상 필요.
  - 기능, 비기능 요구사항 상충시 적절한 트레이드오프 지점에서 협상이 중요함.
- 정형 분석(Formal Analysis)
  - 형식적으로 정의된 의미를 지닌 언어로 요구사항을 표현.
  - 요구사항 분석의 마지막 단계에서 정형 분석이 이루어짐.



#### 요구사항 확인 과정

- 요구사항 검토(Requirement Reviews)
  - 완성한 시점에서 이루어짐
  - 검토자 그룹 구성이 가장 중요함.
- 프로토타이핑(Prototyping)
  - 사용자 요구사항 변경 급격히 감소함.
  - 잘못된 요구사항이 줄어들면서 자원 낭비 방지
- 모델 검증(Model Verification)
  - 분석 단계에서 개발 모델의 품질을 검증할 필요 있음.
- 인수 테스트(Acceptance Test)



#### 요구사항 검증 과정

- 요구사항 검증(Verification)
  - 많은 이해관계자와 함께 다양한 시각에서 공식적으로 검토하고 승인하는 작업
  - 모든 요구사항 문제를 발견할 수는 없음.
- 요구사항 검증 절차
  - 요구사항 검토 계획 수립
    - 품질 관리 담당자가 검토 계호기 수립
    - 인터페이스 요구사항 검증은 기술 아키텍처 전문가 또는 인터페이스 전문가 참여
  - 요구사항 명세서 검토와 오류 수정
  - 요구사항 베이스라인 설정
    - 검증된 요구사항을 공식적으로 승인
    - 베이스라인 정해지면 요구사항의 수정은 공식적인 변경 통제 절차로만 변경할 수 있음.



#### 요구사항 검증 방법

- 요구사항 검토
  - Peer Review : 2~3명 정도의 검토 담당자가 수행하는 검토.
  - Walk Through : 개발 단계마다 실시하는 비정형 검토회의. 오류 조기 검출 목적.
  - Inspection : 개발 참여하지 않은 다른 전문가에 의해 오류 찾는 공식적 검토 방법.
  - 프로토타입 : 주요 기능 임시 개발하여 요구사항 검증.
  - 리펙토링 : 결과 변경 없이 프로그램 소스 구조 재조정. 가독성 높이고 유지보수 편하게 함.
- 테스트 설계
  - 요구사항 테스트 가능하도록 작성되어야 함.
  - 테스트 케이스 생성하여 검토.
- CASE(Computer Aided Software Engineering)
  - 소프트웨어를 개발하는 시점부터 요구분석, 설계, 개발, 유지보수에 이르기까지 소프트웨어의 생명주기 전반을 지원하는 프로그램 또는 소프트웨어 개발을 지원하는 자동화 도구 혹은 방법론의 결합.
  - 소프트웨어 개발 과정의 일부 또는 전체를 자동화하기 위한 도구.
  - 구조적 시스템, 객체지향 시스템 모든 분야에 적용됨.
  - 상위CASE / 하위CASE / 통합CASE
  - CASE 특징
    - SW생명주기 전 단계를 연결
    - 툴 가격 비싸지만 전체 개발 비용 절감
    - 스스로 동작하는 것이 아니라 분석가의 지원이 필요함.
    - CASE 툴 간의 호환성 없음.
    - CASE툴은 전문성을 갖추고 있는 고액의 프로그램이기 때문에 그 수요가 적어 호환성을 고려하지 않음.
    - 컴파일러나 인터프리터와 같은 언어 번역 프로그램은 지원하지 않음.
    - 개발자의 보조적인 도구임. SW가 처리하는 방식이나 운용 방식이 아님.
    - 프로토타이핑 SW구현해 주기도 함.
- 요구사항 관리
  - 협상, 기준선, 변경관리, 확인
- 요구사항 분석 자동화 도구(CASE)
  - SADT(Structure Analysis & Design Technique)
    - SoftTect사에서 개발 대규모 프로젝트용 요구사항 분석 자동화 도구.
  - BS(Brain Storming)의 4가지 규칙
    - 비판금지 / 자유분방 / 다수환영 / 연쇄개선
  - PSL/PSA(Program Statement Language / Program Statement Analysis)
    - 미시간 대학 ISDOS프로젝트에서 개발
    - 요구분석에 필요한 내용을 PSL이란 기술 언어를 사용하여 작성한 뒤 PSA에 입력하면 최적의 요구 명세서 자동 출력해줌.
  - SREM(Software Requirement Engineering Methodology), RSL/REVS
    - TRW사가 미 국방성의 의뢰로 개발한 실시간 시스템용 요구 분석 방법론 및 자동화 도구.
    - 도형 표기법 R-Net과 기술용 언어 RSL로 작성된 요구분석의 기본 자료를 REVS에 입력하면 자동 출력.



#### 요구사항의 기술적 타당성 검토

- 성능 및 용량 산정 적정성 -> 시스템 간 상호 운용성 -> IT 시장 성숙도 및 트렌드 부합성 -> 기술적 위험 분석
- 성능 및 용량 산정 적정성
- 시스템 간 상호 운용성
  - 호환.
- IT 시장 성숙도 및 트렌드 부합성
  - 시장 성숙도가 낮거나 발전 방향에 적합하지 않은 기술들은 유지보수가 어려움.
- 기술적 위험 분석
  - 복잡성
  - 검증여부
  - 의존성



## 3. 화면 설계

### 3.1 UI 요구사항 확인

#### UI 요구사항

- UI 개념 : UI는 사용자가 어떤 방식으로 응용 프로그램을 이용하는가를 설계하는 작업임. 사용자와 응용 프로그램 사이에 접근 방식, 레이아웃 구조, 색상이나 모양 등의 시각적인 것임.
- UI 발전 : 단순 상호 작용 -> 시각, 청각, 촉각, 지능의 데이터 상호작용, 데이터의 의미까지 상호 작용
- UI 종류
  - TUI(Text UI, 텍스트 사용자 인터페이스)
    - RUN, STOP, WAIT 등
    - CLI(명령줄 인터페이스) 등장하기 전에 사용했던 UI
  - CLI(Command Line Interface, 명령 줄 인터페이스)
    - 일정한 형식을 갖춘 문자열을 입력하여 상호 작용을 수행하는 방식.
    - MS-DOS 시절에 사용했던 방식.
  - GUI(Graphic UI, 그래픽 사용자 인터페이스)
    - 그래픽을 통해 상호작용. 마우스 사용
  - WUI(Web base UI, 웹 기반 사용자 인터페이스)
    - 인터넷 웹 페이지를 열람하고 조작하는 인터페이스
  - Touch UI(터치 사용자 인터페이스)
    - 음성, 온도, 촉감을 통해 상호 작용을 수행하는 방식
    - 스마트TV, 스마트폰, 노트북, 출입 관리 등에 응용하는 방식
- UI 분야
  - 물리적 제어
    - 물리적 기계 조작 장치가 있는 하드웨어적인 UI
  - 기능적 제어
    - 키보드, 마우스, 펜 마우스 등 기능적 UI
  - 전체 구성 제어
    - 화면의 레이아웃, 스크롤여부, 버튼, 화면 분할 등에 해당하는 UI
- UI 요구사항 확인
  - 응용 소프트웨어 개발을 위한 UI 표준과 UI 지침을 근거로 요구사항을 수용.
  - 확인 -> 스토리보드 작성 -> 와이어프레임 제작 -> 프로토타입 개발 -> 적정성 검토.
- UX(User Experience)
  - 사용자 경험이란 뜻으로 프로그램에 무엇이 있어야 하는지 전체적인 정보를 수집하여 설계하는 작업.
- UX 고려사항
  - 직관적이고 쉬운 방법 선택
  - 웹이나 모바일 서비스 특성에 적합한 디자인 선택
  - 사용자 입력 최소화, 자동 완성 기능 추가
  - 사용자 입력 실수를 원래 상태로 되돌릴 수 있는 기능 추가



#### UI 표준

- 웹 스타일 가이드 구성
  - Instruction : 웹 스타일 가이드의 기본 활용 및 적용 범위 등을 정함.
  - Basic Rules : 색, 글자 폰트, 이미지 폰트 등을 정함.
  - Layout : 웹 페이지의 작업 유형이나 목적별로 시안을 정함. 기기 유형에 따라 정함. 주메뉴, 서브메뉴, 고정영역과 가변영역 등 구체적으로 정함.
  - Element : 텍스트, 아이콘, 내비게이션, 탭 메뉴, 버튼, 불릿 등을 정함.
- Layout의 구성 요소
  - Indicator : 서비스 상태 알림 및 수신 상태, 네트워크 연결 상태, 배터리 상태 등을 아이콘으로 제공.
  - Header : 회사 로고, 사이트명 제공
  - Navigation : 웹 페이지에서 자신의 경로 위치를 제공
  - Contents Area : 정보 내용을 제공
  - Button : 웹 페이지 메뉴 선택을 제공. 위치는 아래가 일반적이고 상단에 위치시키는 경우도 있음.
  - Footer : 저작권 정보, 전화번호, E-메일의 내용을 제공.
- UI 요소
  - Text box
  - Password box
  - Radio button : 택일
  - Checkbox button : 중복 택일
  - Select box : 드롭다운 형식의 택일
  - Textarea box : 여러 줄의 텍스트 입력
  - submit button
  - reset button
  - Toggle button : Num Lock, Caps Lock, Insert 등
- 기본 환경
  - 용량 규정
    - 메인 전체 1MB 이미지 500KB 서브 전체 200KB 이미지 100KB 공통 이미지 30KB
  - PC 웹 브라우저 규정
    - 해상도 1280x1024 기준
    - 메인 페이지 가로 1110px 이내, 세로 가변
    - 화면 중앙 정렬 기본
    - 가로 스크롤 가능하면 사용x, 세로스크롤바 메인2개이하, 서브3개이하
    - 프레임 가능하면 사용x
  - 모바일 웹 브라우저 규정
    - 해상도 640x480 기준
    - 메인 페이지 가로 600px 이내, 세로 가변
    - 화면 중앙 정렬 기본
    - 가로 세로 스크롤바 가능하면 사용x
    - 프레임 가능하면 사용x
  - 태블릿 웹 브라우저 규정
    - 해상도 1024x768 기준
    - 메인 페이지 가로 825px 이내, 세로 가변
    - 화면 중앙 정렬 기본
    - 가로 세로 스크롤바 가능하면 사용x
    - 프레임 가능하면 사용x



#### UI 지침

- UI 지침의 개념 : 웹이나 모바일 서비스 구축 시 효율적인 정보 전달이 가능하게 하기 위해서 UI 설계에서 지켜야 할 세부 사항을 규정짓는 것.

- UI의 지침 : 핵심 기능 / 호환성과 확장성 / 정보 소외 계층의 접근성 / 일관성 / 이미지 / 사용자 중심 / 단순성 / 결과 예측 / 가시성 / 표준화 / 접근성 / 명확성 / 오류 발생



#### 스토리보드

- 스토리보드의 개념 : 디자이너와 개발자가 최종적으로 참고하는 설계 산출 문서. 정책, 프로세스 및 콘텐츠의 구성, 와이어프레임, UI/UX, 기능 정의 데이터베이스 연동 등 서비스 구축을 위한 대부분의 정보가 수록되어 있음. 스토리보드 도구에는 손글씨, 파워포인트, 키노트, 스케치, 포토샵 등이 있음.

- 스토리보드의 작성 절차
  - 1단계 : 메뉴 구성도 만들기
    - 메뉴의 순서와 구성 단계 정의. 다양하고 동일한 용어들을 하나로 정의.
  - 2단계 : 스타일 확정하기
    - 레이아웃이나 글자 모양, 크기, 색상, 그래픽들을 확정. 개발 중 일관성 유지.
  - 3단계 : 설계하기



### 3.2 UI 설계

#### UI 설계

- UI 설계 개념 : UI 요구사항과 UI의 표준 및 지침을 기준으로 UI를 설계함.
- UI 설계 원칙
  - 직관성 / 유효성 / 학습성 / 유연성
- UI 개발 시스템의 필수 기능
  - 프롬프트 기능 / 검증 기능 / 에러 처리와 에러 메시지 처리 기능 / 도움말 지원 기능
- UI 설계 절차
  - 문제 정의
  - 사용자 모델 정의 : 컴퓨터 지식 정도에 따라 초보자, 중급자, 숙련자로 분류
  - 작업 분석
  - 컴퓨터 오브젝트 및 기능 정의
  - 사용자 인터페이스 정의
  - UI 설계 평가 : GOMS, 휴리스틱, 사용성 공학을 통해 사용성 평가.
- UI 설계 도구
  - 문서 작성 도구 및 드로잉 전문 도구
  - 화면 설계를 위한 전문 도구
  - UI 설계 및 개발 전문 도구
  - 해당 UI 플랫폼에 포함된 도구
  - 인터랙션 도구



#### UI 흐름 설계

- 화면에 구현 기능을 정의 (기능적 + 비기능적)
- 화면의 입력 요소를 파악
- UI 요구사항의 유스케이스 설계



#### 상세 설계

- 메뉴 구조 설계
- UI 검토 및 보완



#### UI 감성 공학

- 개념 : 인체의 특성이나 감정을 UI 설계에 최대한 반영시키는 기술.
- 감성 공학 분야
  - 생체 측정 기술 분야
  - 인간의 오감 센서 및 감성 처리 기술 분야
  - 감성 디자인 기술 분야
  - 마이크로 가공 기술 분야
- 감성 공학의 접근 방법
  - 감성 공학 1류 : 인간 감성의 표현 특성을 강조한 접근 방법
  - 감성 공학 2류 : 인간 감성의 심리적 특성을 강조한 접근 방법
  - 감성 공학 3류 : 인간 감성의 생리적 특성을 강조한 접근 방법



## 4. 애플리케이션 설계

### 4.1. 공통 모듈

#### 모듈

- 개념 : 소프트웨어 구조를 이루며, 다른 것들과 구별할 수 있는 독립적인 기능을 갖는 단위. 서로 모여 완전한 프로그램으로 만들어 질 수 있음. 추상화되어 재사용 및 공유 가능한 수준으로 만들어진 기능 단위를 모듈로 규정함.

- 기본 요소
  - 입력 요소
  - 출력 요소
  - 기능 요소
  - 기관 요소 : 모듈 내부의 알고리즘을 의미함.
  - 내부 자료 요소 : 모듈 내부의 기억 장소를 의미함.
- 모듈의 장점
  - 복잡성 감소.
  - 시험 통합 수정 쉬워짐.
  - 인터페이스 단순해짐
  - 오류 파급 부작용 최소화
  - 개발 유지보수 용이
- 모듈의 공유도(Fan-in)와 제어도(Fan-out)
  - 공유도(Fan-in)
    - 얼마나 많은 모듈이 주어진 모듈을 호출하는 가를 나타내는 척도, 상위 모듈의 수.
    - 공유도가 높은 경우 해당 클래스를 사용하는 클래스의 수가 많다는 것을 의미.
    - 단일 실패점 발생 주의.
  - 제어도(Fan-out)
    - 주어진 모듈이 호출하는 모듈의 개수, 하위 모듈의 수
    - 제어도가 높은 경우 하나의 모듈이 많은 수의 다른 모듈을 사용한다는 것을 의미.
    - 로직 단순화 가능한지 검토.
- 모듈의 개수 및 비용 간 상관도
  - x축 모듈개수  y축 노력비용
  - 모듈통합비용 정비례, 모듈별개발비용 반비례
  - 전체 S/W 개발 비용 2차함수
  - 가운데 부분에서 최소노력비용 찾기.
- 모듈의 특징
  - 다른 프로그램에서 재사용 가능.
  - 실행은 종속적.
  - 기본 라인 수는 100라인 이내가 적당함.
- 모듈의 크기
  - 너무 작으면 모듈의 개수가 많아져 통합 비용 과도하게 발생.
  - 너무 크면 모듈 개발 비용 커짐.



#### 공통 모듈

- 개념 : 프로그램에서 공통적으로 사용할 수 있는 모듈. 복잡한 계산식, 반복 사용되는 검증 기능, 연관되어 발생하는 조건식 등의 경우 별도의 공통 모듈로 구성하여 재사용성 향상.
- 공통 모듈의 원칙
  - 정확성 / 명확성 / 완전성 / 일관성 / 추적성
- 공통 모듈 식별 및 명세
  - 기능을 분석하여 공통 부분 식별
  - 공통 부분에 대한 검토회의
- 공통 모듈의 재사용 범위에 따른 분류
  - 함수와 객체 재사용
  - 컴포넌트 재사용
  - 애플리케이션 재사용



#### 재공학(Re-Engineering)

- SW 재사용 정의 : 이미 개발된 소프트웨어를 반복 사용하여 생산성을 향상시키는 방법으로 소프트웨어를 개발할 때 재사용이 가능한 정보를 찾아 재사용이 가능한 코드로 발전시키는 것.
- SW 재사용의 2가지 기본 기술
  - 생성 중심(모듈화)
  - 합성 중심(모델화)
- SW 재사용의 이점
  - 개발 지식 공유
- 재사용 모듈 설계의 유의사항
  - 사용법 공개.
  - 공통 기능 응집도 최대한 높게 구성
  - 모듈의 독립성 향상을 위해 결합도는 최대한 낮게 구성
  - 공유도 높고 제어도 낮추어 설계
- 모듈의 평가 기준
  - 결합도(연관성) : 모듈 간의 관계성의 척도
  - 응집도(완성도) : 한 모듈 내에 있는 처리 요소들 사이의 기능적인 연관 정도
  - 좋은 설계 위해 결합도 작게, 응집도 크게.
- 소프트웨어 재공학
  - SW 위기를 해결하기 위해 개발의 생산성이 아닌 유지보수의 생산성으로 해결하려는 방법.
  - 시스템에 대한 재분석, 문서화 작업을 통해 공학적으로 우수한 시스템을 만드는 것을 의미함.
- 역공학과 재공학이 등장한 순서
  - 유지보수 -> 외계인 코드 -> 복구 -> 역공학(소스코드보고문서화) -> 재공학(소스코드변경)
- 소프트웨어 역공학 정의
  - 코드의 역공학 : 코드로부터 자료 흐름도를 변경
  - 데이터의 역공학 : 코드로부터 자료 사전을 변경



### 4.2. 모듈의 평가

#### 소프트웨어 모듈 결합도

- 결합도가 높을수록 품질이 낮음.
- 자료결합도 -> 스탬프결합도 -> 제어결합도 -> 외부결합도 -> 공통결합도 -> 내용결합도
- 모듈의 독립성
  - 하나의 모듈에 오류가 발생했을 때 다른 모듈에 전파되어 오류가 발생하는 파문 효과(Ripple Effect)를 최소화할 수 있음.
  - 인터페이스가 정확하게 사용되지 않을 경우 불필요한 인터페이스가 나타나 모듈 사이의 의존도가 높아지고 결합도가 증가하여 좋지 못한 결과가 발생하게 됨.
  - 다른 모듈과 데이터 교류가 필요한 경우 전역 변수보다는 매개 변수를 사용하는 것이 모듈의 독립성이 좋아져 결합도를 낮출 수 있음.
- 자료 결합도(Data Coupling)
  - 두 모듈 간의 인터페이스가 자료 요소만으로 구성된 결합
  - Call By Value 형태로 가장 좋은 결합도
  - 실인수와 가인수의 번지가 독립적으로 사용됨.
    - 하나의 모듈에서 다른 모듈을 호출할 때 넘겨주는 변수를 실인수, 넘겨받는 변수를 가인수라고 함.
  - 단일 파일 또는 동종 테이블을 매개 변수로 통신하는 모듈 간의 결합성을 가진 관계를 말함.
  - 예를 들어 제곱근을 계산하는 함수에 하나의 정수를 전달하는 경우.
- 스탬프 결합도(Stamp Coupling, 구조 결합)
  - 두 모듈 간에 같은 레코드를 부분적으로 공유. 모듈간 독립성은 유지되지만 같은 작업 대상인 자료로 묶인 결합을 의미.
  - 두 모듈 간에 인터페이스가 배열이나 레코드, 객체나 구조적인 데이터 등의 자료 구조가 전달된 경우임.
    - 배열 : 동일한 데이터의 집단
    - 레코드 : 이질형 데이터의 집단
  - 두 모듈이 동일한 자료 구조를 조회하는 경우의 결합성이며, 포맷이나 구조의 변화는 그것을 조회하는 모든 모듈 및 변화되는 필드를 실제로 조회하지 않는 모듈까지도 영향을 미치게 됨.
- 제어 결합도(Control Couping)
  - 처리하는 방법을 제어 요소로 전달되는 경우.
  - 모듈 간에는 제어 변수로 종속적인 관계를 갖음.
  - 제어 결합은 논리 조작을 제어하기 위한 목적, 상위 모듈에게 처리 명령을 부여하는 권리를 전도하는 현상임.
  - 단순 처리할 대상인 값만 전달되는 게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되는 경우임.
- 외부 결합도(Extern Couping)
  - 외부 변수에 의해 영향을 받는 두 모듈이 결합된 관계를 갖음.
  - 모듈 외부에서 데이터, 프로토콜, 인터페이스 등을 공유할 때 발생하는 경우.
  - 외부 변수에 의해 영향을 받는 두 모듈이 결합된 관계로 모듈 내부에서 외부 변수를 사용하게 되면 외부 변수에 의해 두 모듈이 결합력이 높아지며, 경우에 따라서는 부작용이 발생할 수 있는 결합임.
- 공통 결합도(Common Couping)
  - 모듈이 다른 모듈의 내부 자료를 참조하는 형태의 결합된 관계를 갖음.
  - 모듈 외부에 있는 전역 변수를 참조하고 상호 작용하는 경우.
  - 파라미터가 아닌 모듈 밖에 선언되어 있는 동일한 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호 작용하는 경우.
  - Call by Reference 형태임.
- 내용 결합도(Content Couping)
  - 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 형태의 결합된 관계를 갖음.
  - 가장 좋지 않은 결합으로 내용 결합도를 갖는 모듈들은 다시 설계해야 함.
  - 모듈 내부에 있는 변수나 기능을 다른 모듈에서 직접적으로 사용(참조)하는 경우임.



#### 소프트웨어 모듈 응집도

- 응집도가 높을수록 품질이 높음.
- 우연적 응집도 -> 논리적 응집도 -> 시간적 응집도 -> 절차적 응집도 -> 통신적 응집도 -> 순차적 응집도 -> 기능적 응집도
- 응집도가 높을수록 필요한 요소들로 구성되어 있고 낮을수록 관련이 적은 요소들로 구성되어 있음.
- 우연적 응집도(Coincidental Cohesion)
  - 모듈 내부의 루틴들이 뚜렷한 관계없이 묶인 경우로 응집도가 가장 약하고 가장 좋지 않은 모듈 설계.
  - 서로 간에 어떠한 의미 있는 연관 관계도 지니지 않은 기능 요소로 구성되는 경우.
  - 서로 다른 상위 모듈에 의해 호출되어 처리상의 연관성이 없는 서로 다른 기능을 수행하는 응집도.
  - 모듈화의 장점이 없어지며 유지보수를 어렵게 만듦.
  - 우연적 응집도의 예 : 프로그램 전체 라인을 100라인씩 구분하여 모듈화하였다면 100라인은 서로 관계가 있기도 하겠지만 관계가 없는 경우가 대부분.
- 논리적 응집도(Logical Cohesion)
  - 모듈 내부의 루틴들이 같은 범주에 속하는 기능끼리 묶인 모듈.
  - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우임.
  - 논리적 응집도의 예 
    - 오류 처리 모듈. 자판기의 잔액 부족 시, 음료수 부족 시 처리 루틴이 같이 존재하는 경우.
    - 출력 처리 모듈. 인사 정보 출력, 회계 정보 출력, 급여 명세 출력 루틴들이 같이 존재함.
    - 파일 모듈. 불러오기, 저장하기, 출력하기 루틴이 같이 존재하는 경우.
- 시간적 응집도(Temporal Cohesion)
  - 모듈 내부의 루틴들이 시간적으로 수행 시기가 같은 기능끼리 묶인 모듈.
  - 같은 시간에 처리되어야 하는 활동들이 묶인 경우.
  - 시간적 응집도의 예
    - 파일 OPEN 모듈 : 여러 파일들의 OPEN(열기) 작업이 같이 존재함.
    - 파일 CLOSE 모듈 : 여러 파일들의 CLOSE(닫기) 작업이 같이 존재함.
    - 변수 초기화 모듈 : 여러 변수들을 초기화하는 작업들이 같이 존재함.
- 절차적 응집도(Procedure Cohesion)
  - 모듈 내부의 루틴들이 수행 시기가 순위가 있는 기능끼리 묶인 모듈.
  - 모듈 안의 구성 요소들이 순차적으로 수행할 경우.
  - 절차적 응집도의 예
    - 재시작(Restart) 모듈과 같이 총계를 출력하고 화면을 지우고 메뉴를 표시하는 루틴이 같이 존재한다.
- 통신적 응집도(Communication Cohesion, 정보적, 교환적)
  - 모듈 내부의 루틴들 중 작업 대상이 같은 기능끼리 묶인 모듈.
  - 동일한 입력과 출력을 사용하는 작업이 모인 경우로 일반적으로 하나의 파일을 대상으로 갱신 작업을 하는 루틴끼리 묶인 모듈이 여기에 속함.
  - 통신적 응집도의 예
    - 같은 입력 자료를 사용하여 A를 계산한 후 B를 계산하는 경우 입력 모듈에 해당됨.
- 순차적 응집도(Sequential Cohesion)
  - 모듈 내부의 루틴(구성 요소)들이 이전의 명령어(활동)로부터 나온 출력 결과(자료)를 그다음 명령어(활동)의 입력 자료로 사용하는 경우의 응집도.
  - 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동의 입력값으로 사용하는 경우.
  - 순차적 응집도의 예
    - 역행렬 모듈 : 행렬 요소를 입력한 후 그 행렬의 역행렬을 구해서 이를 출력하는 모듈에 해당됨.
    - 평균을 구하는 모듈 : 합계를 계산한 후 합계를 이용하여 평균을 구하는 모듈에 해당됨.
- 기능적 응집도(Functional Cohesion, 함수적 응집도)
  - 모듈 내부가 하나의 단일 기능으로 존재하는 경우로 프로그램 언어에서 지원받는 라이브러리가 모두 이에 속함.
  - C 언어에서는 sin(), cos(), sqrt(), scanf(), printf()... 등이 있음.
  - 구조도 최하위 모듈(트리 구조의 단노드)에서 많이 발견됨.
  - 응집도 중 가장 강하고 좋은 모듈이라고 할 수 있음.



### 4.3. 설계 모델링

#### 설계 모델링

- 개념 : 요구사항 분석 단계에서 정의한 필수 기능들을 구체적인 구현 방법으로 명시하는 단계. 소프트웨어에서 요구되는 기능과 성능 조건을 만족하도록 설계 명세서를 작성하는 과정.
- 설계 모델링의 절차
  - 요구 명세 -> 설계 프로세스(모델링->분석->명세화->검증) -> 설계 명세
- 구조 모델링
  - 소프트웨어 구성 요소들 사이의 구조적 관계에 대한 특성을 모델링함.
  - 구성 요소들은 유형, 인터페이스, 내부 설계 구조 형태별로 분류하여 구조화함.
- 행위 모델링
  - 구성 요소들의 기능적 특성 모델링 : 입출력 데이터, 데이터 흐름, 데이터 변환, 데이터 저장 등
  - 구성 요소들의 동적 특성 모델링 : 상태 전이, 데이터 흐름 경로, 사건 발생 순서, 실행 경로 등



#### 구조 모델링 도구

- N-S(Nassi-Schneiderman) 도표
  - N-S 도표의 3가지 제어 구조 : 순차 / 선택 / 반복
  - N-S 도표의 특징
    - 논리의 기술에 중점을 둔 도형 표현 방법.
    - 임의의 제어 이동이 어려움. (Go To문과 같은 무조건 분기를 표현할 도표가 없음.)
    - 그래픽 설계 도구. 상자 도표라고도 함.
    - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합함.
- HIPO(Hierarchy Input Process Output) 도표
  - HIPO 도표의 종류
    - 가시적 도표(도식 목차) : 전체적인 흐름과 구조를 나타내는 도표.
    - 총체적 도표(총괄 도표) : 입력, 처리, 출력 등의 기능을 명확히 표현한 도표.
    - 세부적 도표(상세 도표) : 총괄 도표를 구체적으로 표현한 모듈 도표.
  - HIPO 도표의 특징
    - 분석 및 설계 도구로 사용됨.
    - 기본 시스템 모델은 입력, 처리, 출력으로 구성.
    - 하향식 개발에 적합함.
    - 소규모 프로젝트에 적합함.
- Dijkstra의 구조적 설계 방법론
  - 개념 : 순차, 선택, 반복 구조만을 이용하므로 소프트웨어의 복잡도를 감소시키고 읽기 쉽고, 검사하기 쉽고, 유지보수하기 쉽다는 특징을 가진 전통적인 기법.
  - 구조적 설계 방법론의 특징
    - 표준화된 설계 기법.
    - 단일 입출력 구조.
    - 순차, 선택, 반복 구조만을 이용함.
    - 한정된 범위 내에서 GO TO문을 사용함.



#### 설계 모델링의 구성과 요소

- 설계 모델의 구성

  - 구조모델
    - 시스템 구조
      - 구성 요소
      - 컴포넌트 연결 구조
    - 컴포넌트 구조
      - 인터페이스
      - 데이터 구조
      - 알고리즘 구조
  - 행위모델
    - 시스템 행위
      - 시스템 기능 입출력
      - 컴포넌트 제어
    - 컴포넌트 행위
      - 계산
      - 실행 제어
      - 상호 작용

- 설계 모델의 요소

  - 구조 모델
    - 정적 요소
      - 유형 및 유형 계통
      - 배열 결합 관계
      - 인터페이스
      - 상호 작용 채널
    - 동적 요소
      - 생성 및 소멸
      - 결합과 연결
      - 위치 이동, 복제

  - 행위 모델
    - 정적 요소
      - 입출력 데이터
      - 입출력 매핑
      - 데이터 흐름 채널
    - 동적 요소
      - 제어
      - 상호 작용 프로토콜
      - 상호 작용 실행 경로
      - 상태 전이
      - 순서
      - 알고리즘



### 4.4. 소프트웨어 아키텍처

#### 시스템 아키텍처

- 개념 : HW와 SW를 포함하는 시스템 전체에 대한 논리적인 기능 체계임. 시스템이 어떻게 작동하는지를 설명하는 프레임워크임.
- 시스템 아키텍처의 요구사항
  - 시스템 구성 및 동작 원리를 나타내고 있어야 함.
  - 시스템 구성 요소에 대한 설계 및 구현이 자세히 기술되어야 함.
- 시스템 아키텍처(상위 설계)의 설계
  - 시스템 아키텍처 설계는 SW 아키텍처 설계에 제약을 하는 상위 설계임.
  - 시스템 아키텍처 설계는 상위 설계이므로 전체적인 아키텍처 설계, 인터페이스 정의, 사용자 인터페이스 설계 등을 수행함.
  - 모듈이나 컴포넌트 설계는 소프트웨어 아키텍처 설계에서 수행함.



#### 소프트웨어 아키텍처

- 개념소프트웨어의 골격이 되는 기본 구조로, 소프트웨어 전체에 대한 큰 밑그림임. 소프트웨어를 이루고 있는 구성 요소인 모듈이나 컴포넌트를 다룸.
- 소프트웨어 개발 순서 : 요구분석 -> 아키텍처 -> 설계 -> 구현 -> 시험
- 소프트웨어 아키텍처 설계
  - 아키텍처 드라이버
    - 요구사항 중 아키텍처에 영향을 주는 요구사항을 아키텍처 드라이버라고 함.
  - 아키텍처 설계의 입력물과 출력물
    - 입력물 : 시스템 요구사항, 아키텍처 드라이버
    - 태스크(Task) : 아키텍처 설계
    - 출력물 : 아키텍처 문서, 아키텍처 가이드라인
- 소프트웨어 아키텍처 설계 시 고려사항
  - 개발자와 사용자 간의 의사소통 도구로 활용할 수 있어야 함.
  - 재사용할 수 있도록 설계해야 함.
  - 버전 관리 해야 함.
- 소프트웨어 아키텍처의 비지니스 품질 속성
  - 시장 적시성(Time to Market)
  - 비용과 이익(Cost and Benefit)
  - 예상 시스템 수명(Predicted Lifetime of the System)
  - 목표 시장(Targeted Market)
  - 신규 발매 일정 또는 공개 일정(Rollout Schedule)
  - 기존 시스템과의 통합(Integration with Legacy System)

- 소프트웨어 아키텍처의 시스템 품질 속성
  - 가용성, 변경 용이성, 성능, 보안성, 사용 편의성, 시험 용이성



#### 소프트웨어 아키텍처 모델

- 계층화 패턴(Layered Pattern)
  - 기능을 분리한 계층
    - 하위 모듈들의 그룹으로 나눌 수 있는 구조화된 프로그램에서 사용할 수 있음.
    - 표현 계층(UI) / 프로세스 계층(서비스) / 비즈니스 논리 계층(도메인) / 데이터 접근 계층(영속)
  - n-Tier(티어) 패턴
  - Layer(계층)는 기능 집단을 논리적으로 분리하는 것이고, Tier는 기능 집단을 물리적으로 분리하는 것임.
    - 1티어 : 3가지 기능을 한 클라이언트 서버 컴퓨터에 설치, 운영하는 경우(종속적)
    - 2티어 : 데이터베이스는 서버 컴퓨터에, 나머지 2개는 클라이언트 컴퓨터에 분리하는 경우
    - 3티어 : 3개의 컴퓨터 시스템에 기능을 각각 분리시켜 운영하는 경우(독립적)
- 클라이언트/서버 패턴
  - 분산 네트워크 시스템으로, 하나의 서버와 여러 개의 클라이언트로 구성됨.
  - 장점 : 병목 현상을 줄일 수 있고, 결합력을 약하게 가질 수 있음.
  - 단점 : 보안이 취약하고 응용 프로그램이 복잡할 수 있음.
- 마스터/슬레이브 패턴
  - 마스터가 슬레이브에게 작업을 분산하면, 슬레이브가 처리한 결과로 최종 결과를 계산하는 패턴.
  - 마스터는 원본, 슬레이브는 복제본을 동기화하는 형태로 활용
  - 실시간 시스템에 적용할 수 있지만 마스터와 슬레이브 간에 Latency 문제가 발생할 수 있음.
  - 마스터/슬레이브의 역할
    - 마스터는 연산, 통신, 조정을 책임짐. 슬레이브 프로세스들을 제어함. 작업을 분리하고 슬레이브에게 분리한 작업을 분배하고 결과를 계산하는 역할을 함.
    - 슬레이브들은 마스터가 요청한 작업만 수행함. 슬레이브가 독립적이므로 공유되는 상태가 존재하지 않음.
- 파이프-필터 패턴(Pipe-filter Pattern)
  - 데이터 스트림을 생성하고 처리하는 시스템에서 사용됨.
  - 서브 시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복함.
  - 처리 과정은 필터(Filter)를 통해 이루어지며, 처리되는 데이터 스트림은 파이프(Pipe)를 통해 흐름
  - 파이프는 버퍼링 또는 동기화 목적으로 사용될 수 있음.
  - 컴파일러, 연속한 필터들은 어휘 분석, 파싱 등에 활용됨.

- 브로커 패턴(Broker Pattern)
  - 분산 시스템에서 사용
  - 원격 서비스 실행을 통해 상호 작용
  - 브로커는 컴포넌트 간의 통신을 조정하는 역할
  - 웹 서버, 메시지 브로커 모듈 등에 활용
- 피어 투 피어 패턴
  - 피어는 하나의 서버 또는 클라이언트
  - 피어는 또 다른 피어에게 서비스 요청할 수 있고 서버로서 각 피어에게 서비스를 제공할 수도 있음.
  - 파일 공유 네트워크 등에 활용됨.
- 이벤트-버스 패턴
  - 알림 서비스 등에 활용
  - 이벤트소스/이벤트리스너/채널/이벤트버스
  - 안드로이드 개발에 활용됨
- MVC패턴
  - View, Controller, Model로 구성
  - 사용자 인터페이스로부터 비즈니스 로직을 분리하여 응용 프로그램의 시각적인 요소를 비즈니스 로직의 변화에 영향 없이 쉽게 수정할 수 있도록 지원함.
  - 컨트롤러 : 데이터와 비즈니스 로직 사이의 상호 동작을 관리.
- 블랙보드 패턴
  - 블랙보드 / 지식소스 / 제어 컴포넌트
  - 음성 인식, 차량 식별 및 추적 등에 활용
- 인터프리터 패턴
  - 특정 언어나 명령어를 해석하는 컴포넌트를 설계할 때 사용
  - SQL의 쿼리 언어 등에 활용



### 4.5. 코드 설계

#### 코드(Code)

- 개념 : 프로그램에서 사용하는 특정 데이터를 사용 목적에 따라 그룹으로 분류 및 나열하거나 선별 및 추출 작업을 용이하게 하기 위해 부여한 숫자, 문자 및 기호 체계.
- 코드의 기능
  - 3대 기능 : 식별, 분류, 배열
  - 추가 기능 : 간소화, 표준화, 연상, 암호화, 오류검출
- 코드 설계의 원칙
  - 적은 자릿수 / 고유성 / 정렬과분류의편의성 / 적응성및확장성 / 기계처리의용이성 / 표의성
- 코드의 특성
  - 단순성 / 표의성 / 분류성 / 용이성 / 고유성 / 확장성 / 영속성 / 편리성



#### 코드 설계

- 코드 설계

  - 코드 설계 시 고려사항
    - 체계화 효율성 표준화 호환성 갱신용이 확장용이 일대일대응 등

  - 코드화 대상에 대한 특성 파악의 내용
    - 변경, 변경 주기, 추가 삭제 비율, 사용 범위, 중요성, 기간 단축 연장 여부

- 코드화 방식 결정 시 고려사항

  - 코드 체계 / 체크 디지트 사용 여부 / 코드 자릿수 / 코드화 부여 요령



#### 코드의 유형 분류

- 순차 코드(Sequence Code)
  - 개념 : 일정한 일련번호를 부여하는 방법. 일련번호식 코드, 순서 코드라고도 함
  - 순서 코드의 특징
    - 단순 명료, 자릿수가 적게 듦.
    - 새자료 추가 용이함.
    - 정렬되어 있는 경우 검색이 빠르나 새로운 자료 발생하면 기존 코드의 변화를 요구함
    - 대상 자료의 수가 적고 다시 작성하는 경우가 없을 때 적합함.
- 블록 코드(Block Code)
  - 개념 : 코드화 대상 항목을 미리 공통의 특성에 따라서 임의 크기의 블록으로 구분하고, 각 블록 내에서 순서대로 번호를 부여하는 방식. 구분 순차 코드라고도 함.
  - 특징 : 적은 자릿수로 많은 항목 표시 가능. 프로그램 작성 시 비교 많이 해야 함
- 10진 코드(Decimal Code)
  - 도서관에서 도서 정리를 목적으로 만든 것. 코드 내용이 좌측과 우측으로 분리되어 좌측 부분은 그룹 분류에 따르고, 우측 부분은 10진수의 원칙에 따라 세분화하는 코드.
  - 분류 체제가 명확하지만 구분 시 10개 이상으로 분류할 수 없고 자릿수가 길고 기계 처리가 불편함.
- 그룹 분류 코드(Group Classification Code)
  - 전체 대상을 대분류, 중분류, 소분류로 구분해 놓고 각 분류별로 개개의 대상을 표현하도록 한 후 합쳐 구성하는 방식. 각 그룹 내에서 순차 번호를 부여함. 컴퓨터 처리에 가장 적합한 방식.
  - 다른 코드에 비해 비교적 자릿수가 김.
- 연상 코드(Mnemonic Code)
  - 대상 항목의 명칭 등을 코드에 반영하여 대상에 대한 연상이 가능하도록 한 코드.
  - 표의성이 뛰어남
- 표의 숫자 코드(Significant Digit Code)
  - 대상 항목의 중량, 면적, 용량 등의 물리적 수치를 이용하여 만든 코드.
  - 여러 개의 대상이 물리적인 수치가 모두 같으면 코드값이 중복됨.
  - 같은 종류에 대해서만 코드화할 수 있음. 합판과 컴퓨터 함께 코드화할 수 없음.
- 합성 코드(Combined Code)
  - 2개 이상의 코드를 조합하여 만든 코드.



#### 코드 오류의 종류

- 사본 오류(Transcription) : 기입시 임의의 한자리 잘못 표기
- 전위 오류(Transposition) : 기입시 임의의 연속된 자리가 바뀌어 표기
- 이중 오류(Double Transposition) : 기입시 전위 에러가 중복해서 발생한 경우
- 랜덤 오류(Random) : 규칙없이 오류 발생
- 생략 오류(Omission) : 기입시 한글자 빠뜨리고 기술한 경우
- 첨가 오류(Addition) : 한글자 추가 기술한 경우



### 4.6. 파일 설계

#### 순차(Sequential) 파일

- 순차 파일의 구조 : 입력되는 데이터의 논리적인 순서에 따라 물리적으로 연속된 위치에 기록하는 방식으로 일괄 처리에 많이 사용되는 편성 방식.
- 순차 파일의 종류
  - 엔트리 순차 파일 : 레코드가 추가되는 순서대로 저장되는 파일.
  - 키 순차 파일 : 레코드에 키 값을 두어 키 값의 순서로 저장되는 파일.
- 순차 파일의 특징
  - 기록 밀도가 좋음
  - 처리하는데 불편이 커서 이용도가 낮음.
  - 파일 내용 추가, 수정, 삭제 어려움.
  - 검색 효율이 떨어짐.
  - 순차 파일은 파일 복사나 일괄(Batch) 처리에 많이 사용됨.



#### 인덱스(색인) 순차(Indexed Sequential) 파일

- 인덱스(Index, 색인)
  - 순차 파일에서 원하는 데이터를 빠르게 검색하고 추출할 수 있도록 일정한 순서에 따라 별도로 정리하여 놓은 목록을 의미함.
  - 모든 블록 조회하지 않고 색인화된 인덱스 파일을 검색하여 검색 속도를 향상시킬 수 있음.
  - 인덱스로 구성된 파일에는 인덱스 파일과 데이터 파일이 존재함.
- 인덱스 순차 파일의 구조
  - 인덱스를 추가한 순차 파일
- 인덱스 순차 파일 구성 방법
  - 인덱스 구역 : 트랙 인덱스(소) / 실린더 인덱스(중) / 마스터 인덱스(대)
  - 기본 데이터 구역 : 실제 데이터 기록
  - 오버플로우 구역 : 넘친 데이터 기록
- 인덱스 구성 방법
  - 정적 인덱스 방법
    - 데이터 파일에 레코드 변경 있을 때 인덱스 내용은 변화하지만 인덱스 파일 구조 자체는 변경되지 않음.
    - 추가 레코드 저장 못한 경우에는 오버플로우 구역 사용.
  - 동적 인덱스 방법
    - 인덱스 파일과 데이터 파일을 블록으로 구성함.
    - 각 블록에는 추가되는 레코드 수를 감안하여 일정 비율 이상의 빈 공간을 미리 만들어 놓음.
- 인덱스 순차 파일의 특징
  - 순차 처리와 랜덤 처리를 병행.
  - 액세스 시간 느림. 레코드 추가 삭제 용이함.
- 다중 키를 이용하는 파일
  - 역(Inverted) 파일
    - 데이터 파일의 레코드에 접근할 인덱스를 여러 개 두어 사용하는 파일.
  - 다중 리스트(Multi List) 파일
    - 데이터 파일의 레코드들을 여러 개의 연결 리스트(Linked List)로 구축한 파일.
    - 인덱스 파일을 혼용하여 사용할 수 있음.



#### 랜덤 편성(Random Organization) 파일

- 랜덤 편성의 구조 : 랜덤 편성은 기록 순서나 코드 순서와 같은 논리적 순서와 관계없이 특정한 방법으로 키 변환에 의하여 임의로 자료를 보관하고 처리 시에도 필요한 장소에 직접 접근하여 원하는 정보를 액세스하도록 편성한 방식임.

- 특징
  - 레코드를 키 변환에 따라 직접 처리할 수 있음.
  - 어떤 레코드라도 평균 접근 시간 내에 접근할 수 있음.
  - 키 변환법에 따라 공간의 낭비를 가져올 수 있음.
  - 대화형 처리에 적합함.





## 5. 인터페이스 설계
