[TOC]

<br>

# 2과목 소프트웨어 개발

## 1. 데이터 입출력 구현

### 자료 표현 단위와 진법(하)

### 고정 소수점과 부동 소수점(하)

### 자료 구조(중)

#### 자료 구조 분류

- 단순 구조(Simple)
  - 프로그래밍 언어에서 제공하는 기본 데이터 타입
  - int, float, double, char 등

- 선형 구조(Linear)
  - 데이터들 사이의 선후 관계가 일대일인 구조.
  - 선형 구조는 크게 순차 구조와 연결 구조로 나눌 수 있음
  - 순차 구조는 삽입과 제거가 자주 일어날 때 처리 시간이 가장 많이 소요되는 자료 구조이며, 연결 구조인 연결 리스트는 데이터의 삽입, 삭제가 가장 용이한 방법임.
  - 스택, 큐, 데크, 선형 리스트, 연결 리스트가 있음.

- 비선형 구조(Non-Linear)
  - 데이터들 사이의 선후 관계가 계층 또는 그물 형태를 가지는 구조.
  - 데이터를 저장시키는 데 있어 데이터와 대응되는 다른 데이터가 여러 개 존재하는 경우의 관계성을 1:N, N:M 구조로 저장시키는 형태 구조를 비선형 구조라고 함.
  - 트리 구조, 그래프 구조가 있음.

- 파일 구조(File)
  - 보조 기억 장치에 데이터값이 실제로 기록되는 자료 구조임.
  - 순차 파일, 색인 파일 등이 있음.




#### 스택

- Stack
- 스택의 구조
  - 데이터를 저장하는 기억 장치가 한쪽으로만 입구와 출구가 있음.
  - 데이터가 저장될 때 입력된 데이터의 위치를 스택 포인터(TOP)가 가리키고 있음.
  - 스택 포인터는 데이터가 입력(PUSH)될 때마다 1씩 증가하며 스택 크기보다 큰 값을 갖게 되면 데이터를 더 이상 기억할 수 없는 오버플로우(Overflow) 상태가 됨.
  - 스택에 데이터가 출력(POP)될 때에는 1씩 감소하며 저장된 데이터가 없을 경우에는 스택 포인터는 0값을 기억하게 됨.

- 스택의 특징
  - 데이터의 삽입과 삭제가 같은 쪽에서 이루어지는 구조임.
  - 스택의 자료 삽입 : TOP 포인트가 스택의 크기(N) 이상이면 오버플로우, 아니면 TOP포인트 1 증가하고 스택에 TOP 포인트가 가리키는 곳에 자료 삽입함.
  - 스택의 자료 삭제 : TOP 포인트가 비어 있으면 언더플로우, 아니면 스택에 TOP 포인트가 가리키는 곳에 자료 삭제하고 TOP 포인트 1 감소.
  - 나중에 입력된 데이터가 먼저 출력하는 메모리 사용 방법.
  - 후입선출(LIFO) 구조.
  - 데이터와 데이터 사이는 1:1 관계임.
  - 함수 호출하여 복귀할 때 / 깊이 우선 탐색 / 재귀적 함수를 호출 사용할 때 / 인터럽트 수행 시 현재 수행 중인 프로세스의 복귀 주소를 저장할 때 / 수식을 우선적으로 연산하기 위한 방법으로 / 0-주소 명령어 방법에서 사용됨.




#### 큐

- Queue
- 큐의 구조
  - 한쪽 방향으로 데이터가 삽입되고 반대 방향으로 데이터가 삭제되는 데이터 구조임.
  - 큐는 가장 먼저 삽입된 데이터가 가장 먼저 삭제되므로 선입선출(FIFO) 구조라고도 함.
  - 데이터를 저장하는 기억 장치가 양쪽으로 있으며 한쪽으로는 입구, 다른 한쪽으로는 출구가 있음.
  - 데이터가 저장될 때 입력된 데이터의 위치를 삽입 포인터(Rear)가 가리키고 있고, 출력된 데이터는 삭제 포인터(Front)가 가리키고 있음.
  - 삽입(Rear), 삭제(Front)

- 큐의 구조
  - 프린터 스풀(Spool) / 입출력 버퍼(Buffer) / 은행 번호표 서비스 / 각종 스케줄링 / 동영상 버퍼 / 인터넷에서 동영상을 실시간으로 받아보는 스트리밍 서비스
  - 키보드를 입력하면 바로 CPU로 전달되지 않고 큐 구조의 버퍼에 대기했다가 CPU에 전달됨.




#### 트리

- Tree

- 트리의 구조
  - 그래프의 특수한 형태로 노드(Node)와 선분(Branch)으로 되어 있고, 정점 사이에 사이클(Cycle)이 형성되어 있지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조임.
  - 트리 구조는 나무를 뒤집은 모습으로 계층 구조를 표현하기에 적합함.
  - 트리는 프로그램의 에러를 찾아내는 구문 분석에서 필요한 기본 이론을 제공함.

- 트리의 용어
  - 노드(Node) : 원
  - 간선(Edge), 링크(Link) : 노드와 연결된 선
  - 루트(Root) 노드 : 뿌리가 되는 노드
  - 단노드 단말노드(Terminal) : 자식이 없는 노드
  - 간노드(Nonterminal) : 자식이 있는 노드
  - 노드의 차수(Degree) : 자식 노드의 개수
  - 노드의 레벨(Level) : 특정 깊이를 가지는 노드 집합. 루트 노드는 1레벨.
  - 노드의 크기(Size) : 자신을 포함한 자식 노드의 수. 차수+1.
  - 노드의 깊이(Depth) : 루트에서 거쳐 간 간선의 수. 레벨-1.
  - 노드의 높이(Height) : 루트에서 가장 깊은 노드. 레벨.
  - 부노드 부모노드(Parent) : 부모 노드
  - 자노드 자식노드(Children) : 자식 노드
  - 제노드(Sibling) : 형제 노드
  - 숲(Forest) : 루트를 제외한 나머지 부분
  - 서브 트리(Sub Tree) : 부분 집합 트리




#### 이진 트리 순회

- 중위 순회 방법(In-order) : 좌근우
- 전위 순회 방법(Pre-order) : 근좌우
- 후위 순회 방법(Post-order) : 좌우근
- 순회 방법 3가지



#### 폴리쉬 표기법

- 중위식(Infix) : 수학식처럼 연산자가 중간에 있는 것.
- 전위식(Prefix) : 연산자가 앞에 있는 것.
- 후위식(Postfix) : 연산자가 뒤에 있는 것.
- 전위식은 CPU 명령어 형식, 후위식은 프로그램의 문법 에러를 확인하는데 주로 사용됨.



### 검색(하)

#### 검색의 시간 복잡도

- 일반적인 알고리즘에서 시간 복잡도는 O(log_2n)이 가장 빠르고 O(n!)이 가장 느림.
- 입력 자료의 개수가 무한히 크다고 가정하는 경우
  - O(long_2n) : 로그형. 이진 검색, 이진 트리 검색에 해당함
  - O(n) : 선형. 수열이나 순차 검색에 해당함
  - O(nlog_2n) : 로그 선형. 퀵 정렬, 힙 정렬, 합병 정렬 시 비교 횟수에 해당함.
  - O(n^2) : 2차형. 선택 정렬, 버블 정렬 시 자료 비교 횟수에 해당함.
  - O(n^3) : 3차형. 행렬 곱셈 알고리즘에 해당함.



#### 이진 검색

- 이분 검색. Binary Search.
- 이진 검색을 하려면 검색 대상의 전체 자료의 수를 알고 있어야 하고, 검색 대상의 자료들이 정렬되어 있어야 함.
- 시간 복잡도는 O(log_2n) 로그형.



#### 이진 트리 검색

- Binary Tree Search
- 검색 대상의 자료를 이진 트리로 변형한 뒤 검색하는 방법.
- 처음 자료는 근노드가 되고 두 번째 자료는 근노드와 비교해서 작으면 왼쪽으로 크면 오른쪽에 연결함.
- 시간 복잡도는 O(log_2n) 로그형.



#### AVL 트리 검색

- Adelson, Velskii, Landis. 균형 이진 트리
- 이진 트리 검색의 효율을 높이기 위해 구성함.
- 트리의 좌우 균형이 맞지 않으면 균형이 맞도록 균형 인수를 +-1이나 0으로 맞추는 트리.
- 노드가 삽입되거나 삭제될 때 트리의 모양이 변함.
- 균형을 측정할 때는 절대적 개수가 아니라 레벨을 비교함.



#### 해싱 검색

- 자료를 찾는 특별한 규칙으로 검색 대상의 자료를 저장하여 자료를 찾음.
- 특별한 규칙이란 해싱 함수를 말하며 해싱 함수의 결과로 자료들의 저장 위치(주소)가 결정됨.
- 해싱 함수로 계산된 저장 위치가 중복될 때에는 충돌이라고 하며 충돌에 대비한 조치가 필요함.
- 서로 다른 탐색키가 해싱 함수를 통해 동일한 해시 주소로 사상될 수 있음.
- 충돌이 발생하지 않는 해싱 함수를 사용한다면 시간 복잡도는 O(1)임.
- 해싱 함수 종류
  - 제산법(Division) : 레코드 키 값을 소수나 전체 자료수로 나누어 그 나머지 값으로 저장할 위치를 정하는 방법.
  - 폴딩법(Folding) : 레코드 키 값을 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방법.
  - 제곱법(Square) : 레코드 키 값을 제곱한 결과 값의 일부를 선택하여 저장할 위치를 정하는 방법.
  - 중간 제곱법(Mid-Square) : 레코드 키 값을 제곱하고, 이 값의 중간 부분을 취하여 홈 주소로 취하는 해싱 방법.
  - 숫자 분석법(Digit Analysis) : 레코드 키 값을 이루는 숫자들의 분포를 파악해서 분포가 고른 부분을 선택해 저장할 위치를 정하는 방법.
  - 기수 변환법(Radix Transformation) : 레코드 키 값을 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수는 절단하고, 이를 다시 버킷의 개수 범위에 맞게 조정하는 방법.
  - 의사 무작위법(Pseudo-random) : 난수를 발생시킨 후 그 난수를 이용하여 저장할 홈 주소의 위치를 정하는 방법.
- 해싱 함수
  - 홈 주소 : 해싱 함수에 의해서 결정됨. 해싱 주소라고도 함.
  - 버킷 : 자료가 저장될 공간.
  - 슬롯 : 하나의 버킷은 여러 개의 슬롯을 가질 수 있음. 충돌 대비
    - 동거자(Synonym, 동의어) : 서로 다른 키 값이지만 해싱 함수에 의해 같은 버킷에 저장되는 키 값들.
  - 충돌 : 해싱 함수에 의해 서로 다른 키가 같은 홈 주소를 갖게 되는 현상.
  - 오버플로우 : 버킷에 할당된 슬롯 수보다 많이 발생하게 되면 버킷에 더 이상 항목을 저장할 수 없는 경우에 발생함.
  - 프로빙(Probing, 조사법) : 충돌이 발생하여 더 이상 같은 홈 주소를 갖는 버킷을 사용할 수 없을 때 사용하지 않는 다른 버킷을 찾아 저장하는 방법으로 1차 조사법, 2차 조사법 등이 있음.
  - 체인법(Chaining) : 해싱에서 오버플로우 발생 시 이를 해결하기 위한 방법으로 연결 리스트를 사용하며 버킷의 크기에 제한을 두지 않는 기법.

#### 그래프 탐색

- 그래프의 모든 정점을 방문하는 것을 그래프 탐색이라고 함.
- 깊이 우선 탐색(DFS : Depth First Search)
  - 스택(Stack) 구조를 이용하여 운용함.
  - 시작 노드(A)에서 인접한 노드 중 하나를 알파벳순으로 스택에 삽입함.
- 너비 우선 탐색(BFS : Breadth First Search)
  - 큐(Queue) 구조를 이용하여 운용함.
  - 시작 노드(A)에서 인접한 노드를 모두 알파벳순으로 큐에 삽입함.



### 정렬(하)

#### 정렬의 시간 복잡도

|      정렬의 분류       |    평균    |    최상    |    최하    |
| :--------------------: | :--------: | :--------: | :--------: |
|    삽입(Insertion)     |   O(n^2)   |    O(n)    |   O(n^2)   |
|      버블(Bubble)      |   O(n^2)   |   O(n^2)   |   O(n^2)   |
|    선택(Selection)     |   O(n^2)   |   O(n^2)   |   O(n^2)   |
|       쉘(Shell)        |  O(n^1.5)  |    O(n)    |  O(n^1.5)  |
|       퀵(Quick)        | O(nlog_2n) | O(nlog_2n) |   O(n^2)   |
|        힙(Heap)        | O(nlog_2n) | O(nlog_2n) | O(nlog_2n) |
| 이진 병합(2-Way Merge) | O(nlog_2n) | O(nlog_2n) | O(nlog_2n) |
|      버킷(Bucket)      |   O(dn)    |   O(dn)    |   O(dn)    |



#### 선택 정렬

- 첫 번째 위치에 가장 작은 값을 위치시킴.

- Pass 2에서는 첫 번째 위치를 제외한 자리 중 첫 번째 위치에 가장 작은 값을 위치시킴.

  

#### 버블 정렬

- Pass 1 : 1,2 비교 2,3 비교 3,4비교 끝까지
- Pass 2 : 제일 뒤를 제외하고 다시 처음부터 Pass 1 진행함.



#### 삽입 정렬

- Pass 1 : 2를 키값으로 설정하여 1,2 비교
- Pass 2 : 3을 키값으로 설정하여 1,2,3 비교
- 정렬할 자료 일부가 정렬되어 있는 경우에 유리한 방법.



#### 힙 정렬

- 임의의 자료에서 최솟값 또는 최댓값을 구할 경우 가장 적합한 정렬 방법
- 자료를 순서적으로 완전 이진 트리 형태로 만들어 정렬하는 방법.
- 공식을 통해 시작하는 하위 노드 그룹을 결정하고 오름차순 정렬인 경우 자노드가 부노드보다 크면 자료를 교환함. 공식은 k = n/2



#### 퀵 정렬

- 레코드의 키를 기준으로 작은 값은 왼쪽에 큰 값은 오른쪽 서브 파일로 분해하여 정렬하는 방식.
- 정렬 방식 중에서는 가장 빠른 방식이며, 프로그램에서 재귀적 함수를 이용하기 때문에 스택을 필요로 함.



### 모듈 구현(하)



## 2. 통합 구현

### 통합 구현 도구(하)

#### 형상 관리 도구

- 개념
  - Software Configuration Management. 소프트웨어 구성 관리.
  - 소프트웨어의 변경 사항을 체계적으로 추적하고 통제하는 것.
  - 형상 관리는 일반적인 단순 버전 관리 기반의 소프트웨어 운용을 좀 더 포괄적인 학술 분야의 형태로 넓히는 근간을 의미함.
  - 프로그램 소스 코드나 문서의 버전 관리, 이력 관리, 추적, 변경 사항을 체계적으로 관리할 수 있는 기능을 제공하는 프로그램.
  - 동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구.
- 형상 관리 도구 기능
  - check-out : 저장소에서 개발자 PC로 가져오는 기능. PULL. 최신 버전 아닌 원하는 버전으로 체크아웃하는 것도 가능함.
  - check-in : 개발자가 수정한 소스를 저장소로 업로드하는 기능. PUSH.
  - commit : 개발자가 소스를 형상 관리 도구 저장소에 업로드한 후 최종적으로 업데이트가 되었을 때 형상 관리 서버에 반영되도록 하는 기능. COMMIT.
  - update : 변경 사항이 있는 경우 서버 형상을 로컬 형상으로 가져오는 기능. FETCH.
  - import : 아무것도 들어있지 않은 저장소에 맨 처음 소스를 넣는 기능.
  - export : 버전 관리 파일을 뺀 순수한 소스 파일을 받아올 수 있음. 오픈소스 프로젝트의 경우 소스를 압축하여 릴리즈할 때 사용함.
- 형상 관리 도구 종류
  - RCS (Revision Control System)
    - 파일, 잠금 방식으로 소스 파일 수정은 한 명으로 제한하여 버전 관리.
    - 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식.
  - CVS (Concurrent Versions System)
    - 가장 오랫동안 사용한 형상 관리 도구임.
    - 중앙 집중형 서버 저장소에 클라이언트가 접속해서 버전 관리를 실행함.
    - Diff를 통해 이전 버전과 현재 버전을 비교함.
    - 파일 단위로 변경 사항을 관리함.
    - 직관적이고 비교적 단순한 명령 구조.
    - Commit 실패 시 Rollback하지 못함.
  - SVN(Subversion)
    - CVS의 단점을 보완한 방식이며 CVS 사용자도 쉽게 도입하여 사용 가능.
    - Auto Commit을 사용하기 때문에 실패 시 Rollback할 수 있음.
  - Git
    - 공개 소프트웨어 커뮤니티 중심으로 사용하는 개발자가 많이 확대되고 있는 도구.
    - 분산형 저장소 사용함.
    - 중앙 집중 방식으로도 사용할 수 있는 융통성이 있음.
    - Commit은 로컬 저장소에 이루어지고, PUSH 동작에 원격 저장소에 반영됨.
  - Perforce(P4D)
    - 2014 출시. Merge 속도가 빠름.
    - 여러 가지 편리함.
    - CLI가 상대적으로 약함.



### 연계 통합 구현(하)



### 연계 메커니즘(하)



### 연계 장애 및 오류 처리 구현(하)



### 연계 모듈 구현 환경 구성 및 개발(하)



## 3. 제품 소프트웨어 패키징

### 제품 소프트웨어 패키징(하)

#### 제품 소프트웨어 패키징

- 특징

#### 제품 소프트웨어 패키징 도구

- 개념
  - 제품 소프트웨어의 배포를 위한 패키징 시 디지털 콘텐츠의 지적 재산권을 보호하고 관리하는 기능을 제공함
  - 안전한 유통과 배포를 보장하는 도구이자 솔루션임.
  - 불법 복제로부터 디지털 콘텐츠의 지적 재산권을 보호해 주는 사용 권한 제어 기술, 패키징 기술, 라이선스 관리, 권한 통제 기술 등을 포함함.

- 패키징 도구 활용시 고려사항
  - 반드시 암호화 및 보안 기능을 고려한다
  - 다양한 다른 기종 연동을 고려한다
  - 사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려한다
  - 제품 소프트웨어의 종류에 적합한 암호화 알고리즘을 적용한다
  - 지속적인 배포를 고려한다



### 제품 소프트웨어 매뉴얼(하)

#### 제품 소프트웨어 설치 매뉴얼

- 기본 사항

#### 제품 소프트웨어 사용자 매뉴얼

- 준비절차 / 작성절차



### 제품 소프트웨어 버전 관리(하)

#### 제품 소프트웨어 버전 관리

- 버전 관리 항목 : 가져오기 , 체크아웃, 체크인, 커밋, 리파지토리 등

#### 제품 소프트웨어 버전 관리 도구

- 도구 유형 : 공유폴더방식 클라서버방식 분산저장소방식 등

#### 빌드 자동화 도구

- 개념
  - Build, IC(지속적인 통합)
  - 제품 소프트웨어의 실행 파일을 자동으로 만들어 주는 도구.
  - 실행 파일을 한 번 만들어 놓고, 새롭게 추가되는 프로그램이 있으면 자동으로 실행 파일에 추가함.

- 종류
  - Make : 유닉스 계열.
  - Ant : 아파치 앤트. 자바 언어에서 사용.
  - Maven : 아파치 메이븐. 자바 언어에서 사용.
  - Gradle : 오픈소스. 그루비 기반. 안드로이드 환경 적합함. 태스트 단위로 실행함.
  - Jenkins : 오픈소스. 자바기반. 아파치톰캣과 같은 웹 서버 기반.




## 4. 애플리케이션 테스트 관리

### 애플리케이션 테스트(하)

#### 테스트 관련 용어

- 디버그 Debug 디버깅 Debugging
  - 컴퓨터 프로그램의 논리적인 오류를 찾아내는 과정.
  - 문법적 오류는 실행 자체가 안되지만 논리적 오류는 실행은 되지만 실행 결과가 안맞는 오류를 말함.

- 디버거 Debugger
  - 디버그를 돕는 도구
  - 디버깅 하려는 코드에 중단점을 지정하여 프로그램 실행을 중단하고, 코드를 단계적으로 실행하여 저장된 값을 확인할 수 있도록 지원함.

- 워크스루 Walk-Through
  - 소프트웨어 생명주기의 각 단계마다 산출된 명세서를 가지고 오류를 찾아내는 비정형 검토회의
  - 검토회의 전에 요구사항 명세서를 미리 배포하여 사전에 검토한 후 짧은 검토회의를 통해 오류를 조기에 검출하는 데 목적을 두는 요구사항 검토 방법임.

- 정형 기술 검토 FTR
  - 체계적이며 규칙적으로 오류를 찾는 작업.
  - 소프트웨어 개발이 완성된 상태에서 검사함.
  - 개발자와 검토자 모두 많은 준비를 해야 함
  - 검토 지침
    - 제품 검토의 집중성 : 오류 검출에 초점을 두고 해결책은 나중으로 미룸.
    - 사전 준비성
    - 의제의 제한성
    - 안건 고수성
    - 논쟁 반박의 제한성
    - 문제 공개성
    - 참가 인원의 제한성
    - 문서성




#### 테스트의 원칙

- 테스트는 결함이 존재함을 밝히는 것.
- 완벽한 테스트는 불가능함.
- 테스트는 계획 단계부터 해야 함.
- 결함 집중 Defect Clustering 고려해야 함.
- 살충제 패러독스 Pesticide Paradox 고려해야 함. 테스트 케이스 주기적 업데이트.
- 오류 부재의 궤변 Absence of Errors Fallacy 고려해야 함. 사용자 만족이 제일 중요함.
- 테스트는 정황에 의존적임. 정황과 비즈니스 도메인에 따라 테스트를 다르게 수행해야 함.



### 단위 테스트(중)

#### 단위 테스트

- 개념
  - 원시 프로그램의 모듈이나(함수, 프로시저, 독립적인 루틴 등) 컴포넌트 대상으로 화이트박스 테스트를 실시하는 방법.
  - 모듈의 기능 수행 여부를 판정하고 내부에 존재하는 논리적인 오류를 검출함.
  - 개별 모듈을 시험하는 것으로 예정된 기능이 제대로 수행하는지를 점검하는 검사임.
  - 구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트한다.
  - 모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다.
  - 테스트할 모듈을 호출하는 모듈도 있고, 테스트할 모듈이 호출하는 모듈도 있다.


- 종류
  - 정적 테스트
    - 애플리케이션 실행하지 않고, 명세서나 소스코드 대상으로 분석하는 테스트
    - 코드 워크쓰루
    - 인스펙션
  - 동적 테스트
    - 애플리케이션을 직접 실행해 오류를 찾음, 소프트웨어 모든 단계에서 테스트
      - 블랙박스 테스트(기능 테스트)
      - 화이트박스 테스트



#### 화이트박스 테스트

- 개념
  - 단위 테스트의 가장 기본적인 방법.
  - 소스 코드의 모든 문장을 한 번 이상 수행함으로써 진행됨.
  - 소스 코드를 보면서 테스트 케이스를 다양화하게 만들어 테스트함.
  - 모듈의 내부 구현을 자세히 테스트함.
- 화이트박스 테스트의 종류
  - 기초 경로 테스트(Base Path Testing, Structure Testing, 구조 테스트)
  - 루프 테스트(Loop Testing)
  - 데이터 흐름 테스트(Data Flow Testing, 논리흐름도)
  - 조건 커버리지(Condition Coverage, 검증 기준)
- 화이트박스 테스트를 통해 찾을 수 있는 오류
  - 세부적 오류
  - 논리 구조상의 오류
  - 반복문 오류
  - 수행 경로 오류
  - 알고리즘 오류에 따른 원치 않는 결과
  - 무한 루프
  - 틀린 계산 수식에 의한 잘못된 결과



#### 블랙박스 테스트

- 개념
  - 프로그램의 외부 사용자 요구사항 명세를 보면서 테스트함.
  - 프로그램의 동작만으로 오류를 찾아 내는 방법.
  - 주로 구현된 기능을 테스트함.
  - 모듈의 내부 구현보다는 입력과 출력에 의해 기능을 테스트함.
  - 프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정함.
- 블랙박스 테스트의 종류
  - 동등 분할 (균등 분할, 동치 분할) (Equivalence Partitioning)
  - 경계값 분석(Boundary Value Analysis)
  - 오류 예측(Error Forecast)
  - 원인 결과 그래프(Cause and Effect Graphing)
  - 비교 테스트(Compare Testing)
- 블랙박스 테스트를 통해 찾을 수 있는 오류
  - 인터페이스 오류
  - 자료 구조상의 오류
  - 성능 오류
  - 시작과 종결상의 오류
  - 부정확하거나 빠진 오류
  - 비정상적인 자료를 입력해도 오류 처리를 수행하지 않는 경우
  - 정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우
  - 경계값을 입력할 경우 요구된 출력 결과가 나오지 않는 경우



#### 기초 경로 테스트

- Basic Path Testing, Structure Testing(구조 테스트)이라고 함.
- 흐름 도표 작성 -> 복잡도 계산 -> 복잡도 1당 테스트 1번 시행 -> 복잡도 판정
- 복잡도 계산 방법 : 받는 화살표의 수 + 1
- 복잡도 판정 : 5이하 단순, 6~10 구조적&안정적, 20이상 매우 복잡, 50이상 비구조적&불안정 -> 다시 작성
- 모든 프로그램의 복잡도를 6~10 이하로 만들기 위해서는 모듈화가 필수적임.



#### 경계값 테스트

- 개념
  - 범위의 한계 부분을 집중적으로 검사.
  - 해당 경계값 주변에 값들을 입력하여 정상적으로 출력되는지 확인하여 오류가 발생하면 소스 코드를 수정함.



#### 단위 테스트 도구

- 단위 디버깅의 자동화 도구임.

- JUnit : 자바 프로그래밍 언어용.
- CppUnit : C++ 프로그래밍 언어용.
- HttpUnit : 웹 브라우저 없이 웹 사이트 테스트를 수행하는 데 사용되는 오픈 소스 소프트웨어 테스트 프레임워크.
- Unitest : Python 기반의 단위 모듈 테스트, 디버깅 도구.
- NUnit : .NET 플랫폼 기반의 단위 테스트 프레임워크.



### 통합 테스트(하)

#### 통합 테스트

- 개념
  - 통합 테스트는 소프트웨어 각 모듈 간의 인터페이스 관련 오류 및 결함을 찾아내기 위한 체계적인 테스트 기법을 말함.
  - 단위 테스트가 끝난 모듈 또는 컴포넌트 단위의 프로그램이 설계 단계에서 제시한 동일한 구조와 기능으로 구현된 것인지를 확인하는 것.
  - 설계 명세서와 통합된 프로그램과의 차이를 확인하는 것.
- 수행 방법
  - 점증적인 방식 : 드라이버나 스터브를 사용하여 테스트함. 일부 먼저 테스트
    - 상향식 통합 테스트
    - 하향식 통합 테스트
  - 빅뱅 방식(비 점증적) : 한꺼번에. 드라이버나 스터브 없이 실제 모듈로. 단시간 테스트에 적당하고 작은 시스템에 유리함. 장애 위치 파악 어려우며 모든 모듈이 개발되어야 테스트가 가능함.



#### 하향식 통합 테스트

- 메인 제어 모듈로부터 아래 방향으로 제어의 경로를 따라 이동하면서 하향식으로 통합하면서 테스트함.
- 하위 모듈과 최하위 모듈은 깊이우선 또는 너비우선 방식으로 통합됨.(선택 가능)
- 아직 작성되지 않은 하위 제어 모듈 및 모든 하위 컴포넌트를 대신하여 더미 모듈인 스터브(Stub)를 개발함. 테스트 완료되면 스터브는 실제 모듈 또는 컴포넌트로 대치함.
- 주요 제어 모듈은 작성된 프로그램을 사용하고, 주요 제어 모듈의 종속 모듈들은 스텁으로 대체함.
- 테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음.
- 인터페이스가 이미 정의되어 있어 통합이 간단함.
- 레벨이 낮은 데이터 구조의 세부 사항은 설계초기 단계에서 필요함.



#### 상향식 통합 테스트

- 최하위 레벨의 모듈 또는 컴포넌트로부터 위쪽 방향으로 제어의 경로를 따라 이동하면서 테스트함.
- 최하위 레벨의 모듈 또는 컴포넌트들이 하위 모듈의 기능을 수행하는 클러스터(Cluster)로 결합함.
- 상위 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈은 드라이버(Driver)를 작성함.
- 필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 드라이버(Driver)라고 함.
- 통합된 클러스터 단위를 테스트함.
- 테스트할 때 프로그램 전체를 실행할 수 없음 (하향식은 가능)
- 테스트할 때 독립적인 구조를 갖지 못함 (클러스터로 묶어야 함. 하향식은 독립적인 구조 가능)
- Stub 필요없음. Driver 필요함
- 하위 모듈 그룹(클러스터) 형성이 필요함
- 중요 모듈을 우선 테스트할 때 적당함
- 최하위 수준에서 각각의 모듈을 설계하고 이러한 모듈이 완성되면 이들을 결합하여 검사함.
- 인터페이스가 이미 성립되어 있지 않으면 드라이버를 추가해야 함. 쉽지 않음.



### 시스템 테스트(중)

#### V-모델

- 확인
- 검증
- 부하 테스트

#### 인수 테스트

- 수행 방법 : 알파 / 베타

#### 테스트 자동화 도구

- 개념
  - 스크립트 형태로 구현하는 자동화 도구 적용.
  - 휴먼 에러를 줄이고 테스트의 정확성을 유지하면서 테스트 품질 향상시킴.
- 장단점
  - 테스트 데이터의 재입력, 재구성 등 반복 작업을 자동화함으로써 인력 및 시간 절약
  - 향상된 테스트 품질 보장
  - 사용자 요구사항에 대한 일관성 있는 검증 가능
  - 테스트 결과에 대한 객관적 평가 기준 제공 및 그래프 등 다양한 표시 형태로 제공
  - UI 없는 서비스에 대한 테스트도 정밀하게 가능
  - 테스트 자동화 도구의 사용법에 대한 교육 및 학습 필요함.
  - 자동화 도구의 프로세스 단계별 적용을 위한 별도의 시간, 비용, 노력 필요함.

- 정적 분석 도구
  - 프로그램을 실행하지 않고 분석하는 도구
  - 소스 코드의 코딩 표준, 코딩 스타일, 코드 복잡도, 남은 결함 등을 발견하기 위해 사용함.

- 동적 분석 도구
  - 스크립트 언어를 사용하여 테스트
  - 데이터 주도 접근 방식 : 다양한 데이터를 동일한 테스트 케이스로 반복 실행.
  - 키워드 주도 잡근 방식 : 데이터 + 키워드 (다양한 수행 동작)

- 성능 테스트 도구
  - 처리량, 응답 시간, 결과 시간, 자원 사용률 측정

- 테스트 통제 도구
  - 테스트 계획 및 관리, 결함 관리, 형상 관리

- 테스트 하네스
  - 테스트를 위해 생성한 코드 및 데이터.
    - 테스트 스터브
    - 테스트 드라이버
    - 테스트 케이스 : 입력 기능에 대한 기대 결과를 명세한 명세서
    - 테스트 수트 : 테스트 케이스의 집합.(시나리오와 달리 절차 순서 없음)
    - 테스트 스크립트 : 자동화 테스트 절차에 대한 명세
    - Mock Object : 조건에 맞는 상황에 특정 기능이 수행되도록 한 객체


#### 테스트 장치 구성

- 드라이버 / 스터브 / 수트 등

#### 테스트 케이스

- 개념
  - 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서를 의미함.
  - 테스트 케이스의 가장 핵심적인 사항은 테스트 항목의 도출임.
  - 프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는 것이 중요함.
- 테스트 케이스 작성 순서
  1. 테스트 계획 검토 및 자료 확보
  2. 위험 평가 및 우선순위 결정
  3. 테스트 요구사항 정의
  4. 테스트 구조 설계 및 테스트 방법 결정
  5. 테스트 케이스 정의
  6. 테스트 케이스 타당성 확인 및 유지 보수



#### 테스트 오라클

- 개념
  - 테스트 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법 및 활동을 말함.
  - 테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준임.
  - 결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 계산하거나 확인함.
- 특징
  - 제한된 검증
  - 수학적 기법
  - 자동화 가능
- 테스트 오라클의 유형
  - 참 오라클(True Oracle) : 모든 입력값에 대해 기대하는 결과를 생성함으로써 발생한 오류를 모두 검출할 수 있는 오라클.
  - 샘플링 오라클(Sampling Oracle) : 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클.
  - 추정 오라클(Heuristic Oracle) : 샘플링 오라클을 개선한 오라클. 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 추정으로 처리하는 오라클.
  - 일관성 테스트 오라클(Consistent Test Oracle) : 소프트웨어 변경이 있을 때, 수행 전과 수행 후의 결과 값이 동일한지 확인하는 오라클.
- 테스트 오라클의 적용 방안
  - 참 오라클은 주로 항공기, 임베디드, 발전소 소프트웨어 등 작은 실수만으로도 치명적인 결과를 초래하는 업무에 적용함.
  - 샘플링/추정 오라클은 일반, 업무용, 게임, 오락 등의 일반적인 업무에 적용함.



#### 검증(Verification) 확인(Validation)

- 소프트웨어 테스트에서 검증과 확인을 구별하면 찾고자 하는 결함 유형을 명확하게 하는 데 도움이 됨.
- 검증은 소프트웨어 개발 과정을 테스트하는 것이고, 확인은 소프트웨어 결과를 테스트하는 것.
- 검증은 작업 제품이 요구 명세의 기능, 비기능 요구사항을 얼마나 잘 준수하는지 측정하는 작업임



### 테스트 결과 분석(하)

#### 테스트 결과 분석

- 결함 종류 : 오류, 결함, 실패 등



### 연계 테스트 및 검증(하)



### 테스트 커버리지(하)



### 성능 분석 및 품질 평가(중)

#### 테스트 관리 지원 도구

- 소스코드 품질 분석 도구(정적 분석 지원 도구) 종류

#### 품질 목표 항목

- 정확성 / 신뢰성 / 효율성 등등등

#### 외계인 코드



## 5. 인터페이스 구현

### 인터페이스 설계 명세(중)

#### EAI

- 개념
  - Enterprise Application Integration 기업 응용 프로그램 통합
  - 기업서 운영되는 서로 다른 플랫폼 밑 응용 프로그램 간의 정보 전달, 연계, 통합을 가능하게 해주는 솔루션.
- EAI 구축 유형
  - Point-to-Point : 중간에 미들웨어 없음. 솔루션 구매 없이 통합 가능. 변경이나 재사용 어려움
  - Hub & Spoke : 단일 접점 허브 시스템 통해 데이터 전송. 중앙 집중적 방식. 허브 장애 시 전체 시스템 영향 받음.
  - Message Bus : 미들웨어를 통한 통합. 뛰어난 확장성과 대용량 처리 가능
  - Hybrid : 그룹내 허브, 그룹간 메시지버스 방식 사용. 표준 통합 기술.



#### ESB

- 개념
  - Enterprise Service Bus
  - 응용 프로그램보다는 서비스 중심으로 통합을 지향하는 기술.
  - 웹 서비스 중심으로 ESB 통해 서로 다른 앱을 유연하게 통합하는 핵심 플랫폼 기술.
  - 표준화가 미비하고 특정 벤더에 종속되어 있음. 특정 업체의 제품만을 사용하므로 부담될 수 있음.



#### 인터페이스 구현 도구

- 데이터 통신
  - 응용 프로그램 영역에서 인터페이스 형식에 맞춘 데이터 포맷을 인터페이스 대상으로 전송하고 이를 수신측에서 파싱하여 해석하는 방식.
  - JSON 및 XML 형식의 데이터 포맷을 사용하여 인터페이스를 구현함.
- JSON
  - JavaScript Object Notation, 제이슨
  - 속성과 값으로 이루어진 데이터 객체를 전달하기 위해 사용하는 개방형 표준 포맷.
  - AJAX에서 많이 사용되고 XML을 대체하는 주요 데이터 포맷임.
  - 언어 독립형 포맷으로 다양한 프로그래밍 언어에서 사용됨.
- XML
  - eXtensible Markup Language
  - 다 특수한 목적을 갖는 마크업 언어를 만드는 데 사용하도록 권장하는 다목적 마크업 언어.
  - 마크업 언어는 소프트웨어에서 문장이나 표의 배치 방법, 글자 크기와 모양 등에 대한 정보를 나타내는 언어를 말함.
  - 다른 종류의 시스템끼리 데이터를 쉽게 주고받을 수 있음.
- YAML
  - 스페이스 공백을 통해 데이터의 layer을 나누고, 정리하는 정보양식.
  - 띄어쓰기와 '-' 대시를 통해 정보가 나뉘어지고, 사람이 보기 쉽게 정리한 정보 양식임.
- AJAX
  - Asynchronous Javascript And XML
  - 함께 사용하는 기술의 묶음을 지칭하는 용어
  - 자바스크립트를 사용한 비동기 통신 기술로 클라이언트와 서버 간에 XML 데이터를 주고 받는 기술임.
  - 웹 페이지 화면에서 페이지 이동 없이 고속으로 화면 전환 가능.

### 인터페이스 구현 검증(하)

#### 인터페이스 구현 검증 도구

- xUnit / STAF / FitNEsse 등등등

