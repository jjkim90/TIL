[TOC]

<br>

# 4과목 프로그래밍 언어 활용

## 1. 프로그래밍 언어 기초

### 프로그램 언어와 번역(하)

#### 라이브러리

- Library
- 개념
  - 도서관처럼, 필요할 때 찾아서 쓸 수 있도록 모듈화되어 제공되는 부품화된 프로그램임.
  - 일반적으로 내장 함수, 지원 함수, 지원 프로그램 등을 말함.
- 구성
  - 도움말
  - 설치 파일
  - 샘플코드
- 표준 라이브러리
  - 프로그래밍 언어가 기본적으로 가지고 있는 라이브러리를 의미함.
  - 별도의 파일 설치 없이 사용할 수 있음.
- 외부 라이브러리
  - 별도의 파일을 설치해야 함.
  - 누구나 개발 설치 가능하고 인터넷 이용하여 공유할 수도 있음.
- C언어의 대표적인 라이브러리
  - stdio.h : 표준 입출력에 사용되는 함수, scanf, printf 등
  - string.h : 문자열 처리에 사용되는 함수, strlen, strcpy 등
  - math.h : 수학 함수, sqrt, abs 등
  - stdlib.h : 자료형 변환, 난수, 메모리 할당 함수, atoi, rand, malloc 등
  - time.h : 시간 처리 함수, time, clock 등



#### 스크립트 언어

- Script Language
- 원시 코드를 컴파일하지 않고도 실행할 수 있는 프로그래밍 언어.
- 스크립트 언어는 별도의 컴파일 없이 내장된 번역기(interpreter)에 의해 번역되므로 바로 실행할 수 있음.
- 스크립트 언어에는 Javascript, PHP, Basic, Python 등이 있음.



### 자료 객체(하)



## 2. 프로그래밍 언어 활용

### 알고리즘과 코딩(중)

#### 알고리즘 설계 기법

- 동적 계획법
- 탐욕적 알고리즘
- 재귀적 알고리즘
- 근사 알고리즘
- 배낭 알고리즘
- 분할 정복법
- 퇴각 검색법



#### 클린 코드 작성 원칙

- 가독성
- 단순성
- 의존성
- 중복성
- 추상화



#### 표준화된 코딩 형식

- 하나의 명령을 하나의 라인에 코딩함
- 명령어를 구분할 수 있는 줄 바꿈을 적절히 사용함
- 등등



#### C언어 변수명 작성 규칙

- 영문자, 숫자, 밑줄 문자(_)를 사용함.
- 첫 글자는 반드시 영문자로 시작해야 함. 밑줄 문자는 영문자로 취급되어 첫 글자로 사용할 수 있음.
- 영문자는 대소문자를 구분함.
- 공백을 포함하거나 다른 특수 문자를 포함해서는 안 됨.
- 예약어를 변수명으로 사용할 수 없음.



#### C언어의 문자열 함수

- strcpy() : 문자열을 복사함.
- strncpy() : 문자열에서 지정한 부분만큼 복사함.
- strcat() : 두 개의 문자열을 합침.
- strncat() : 두 개의 문자열을 지정한 부분만큼 합침.
- strlen() : 문자열의 길이를 셈.
- strcmp : 문자열 비교. 문자열이 같으면 0 다르면 -1, +1 반환.
- strrev() : 거꾸로 변환. 문자열을 뒤집음.
- strstr() : 문자열 탐색. 



### C언어와 연산자(하)



#### 연산자의 종류

- 단항 : ++, --, -, !, ~, sizeof, &, *
- 산술 : +, -, *, /, %
- 시프트 : <<, >>
- 관계 : <, >, <=, >=, ==, !=
- 비트 논리 : &, |, ^
- 논리 : &&, ||
- 조건 : ? :
- 할당 : =, +=, -=, *=, /=, %=, <<=, >>=



#### ++, -- 연산자

- 전위 연산자 : ++ 연산자가 변수 앞에 있음.
- 후위 연산자 : ++ 연산자가 변수 뒤에 있음.



#### &, * 연산자

- & 연산자는 변수의 절대 번지를 표현하는 번지 지정 연산자임.
- * 연산자는 포인터 변수를 선언하거나 포인터의 내용을 표현하는 간접 연산자임.



#### <<, >> 연산자 (시프트 연산자)

- 변수와 상수를 이진수로 풀어서 비트 하나하나를 대상으로 연산함.
- a << n : 변수 a를 n비트 만큼 좌 시프트함.



#### 관계 연산자

- 참이면 1(True), 거짓이면 0(False) 값을 가짐.



#### 비트 논리 연산자

- 변수와 상수를 이진수로 풀어서 비트 하나하나를 대상으로 연산함.
- a & b : 비트 AND, 대응되는 비트가 한쪽이라도 0이면 0임.
- a | b : 비트 OR, 대응되는 비트가 한쪽이라도 1이면, 1임.
- a ^ b : 비트 XOR, 대응되는 비트가 같으면 0, 다르면 1임.



#### 논리 연산자

- a && b : 한쪽이라도 거짓이면 거짓으로 0이 됨.
- a || b : 한쪽이라도 참이면 참으로 1이 됨.



#### 삼항 연산자

- 조건식 ? A : B
- 조건식이 참이면 A명령문, 거짓이면 B명령문을 수행함.



### C언어의 제어문(하)

#### for문

#### while문

#### do~while문



### C언어의 고급 기법(하)

#### 배열

#### 포인터

#### 구조체

- Structure
- C언어에서 제공되는 변수 구조가 아닌 자신만의 변수 구조를 만들 때 구조체를 사용함.
- 일반적으로 여러 개의 항목(Field)이 존재하는 레코드(Record)를 만들 때 사용함.
- C언어에서는 레코드를 구조체라고 함.

- `struct rec { 내용 }`
  - 구조체 예약어는 struct
  - rec는 구조체를 여러 개 사용할 때 각 구조체를 구분하기 위한 태그(tag)로 프로그래머가 임의로 지정하면 됨.
- `struct rec REC = {1. "김자바". 78};`
- `REC.bun, REC.name, REC.jum`



#### 지원 라이브러리 함수

- 문자열과 숫자 변환 함수
- 수학 함수



#### 메모리 할당 함수 malloc()

- malloc() 함수를 사용하는 동적 할당은 프로그램 실행 중에 힙(Heap) 메모리 공간에 필요한 메모리 크기와 유형(Type)을 지정하여 할당받아 사용하고, 실행 중에 반납(free()) 할 수 있음.



### 파이썬(Python)(하)

#### Python의 기초

- 특징
  - 인간 중심 언어 쉽고 빠르게 배울 수 있음
  - C, C++과 호환성이 좋음.
  - 웹 프로그램을 만들기에 매우 적합한 도구.
  - 데이터 분석에 강점.
  - 인터프리터 방식의 객체지향 언어.
  - 인터프리터가 없는 안드로이드나 iOS 환경에서는 동작하지 않음.
  - 대단히 빠른 속도를 요구하거나 하드웨어를 직접 접근해야 하는 프로그램에는 어울리지 않음.
- 변수 작성 규칙
  - 첫 글자 숫자 X
  - 영문 대소문자, 숫자, 밑줄 문자(_) 사용함.
  - 영문 대소문자를 구분함.
  - 변수 이름 중간에 공백 사용 못함.
  - 예약어 사용 불가.
  - 변수명의 길이에 제한이 없음.
  - 한글도 사용 가능하기는 함.



#### Sequence 데이터 타입

- 리스트(List)
  - 가장 많이 사용되는 연속형 데이터 타입.
  - 굉장히 유연한 구조를 가지고 있어 대부분의 데이터를 편하게 다룰 수 있음.
  - [1, 2, 3]
  - 리스트의 원소는 쉼표로 구분되며, 리스트의 원소는 아무 데이터 타입이나 가능함. 리스트조차 가능함.
  - 수정이 자유로움. 수정을 하면 안되는 경우에는 사용하면 안 됨.
- 튜플(Tuple)
  - 리스트와 2가지 제외 완전 똑같음.
  - 리스트는 []를 사용하고, 튜플은 ()를 사용함.
  - 리스트는 생성 후에 변경이 가능하고(mutable) 튜플은 생성 후에 변경이 불가능함(immutable)
- 문자열(String)



#### 집합 데이터 타입

- 세트 데이터 타입 Set
- 순서 없고 중복 불가능함. null값도 1개.

- 생성은 (), 내용은 {} 사용함.



#### 사전 데이터 타입

- 맵, Map

- key-value 방법을 통해 저장함.
- {}을 이용하여 표현.
- {key : value, key2 : value2, ...}
- key는 중복 불가. 사전에서 key가 될 수 있는 데이터 타입은 immutable이어야 함.



#### 문자열 슬라이싱(Slicing)

- s = "Hello World"
- print(s[1:5]) : ello, 1부터 5까지인데 5 위치는 포함 안됨
- print(s[:4]) : Hell, 문자열 처음부터 4까지인데 4 위치는 포함 안됨
- print(s[-1]) : d, 마지막 위치
- print(s[-3:-1]) : rl, 마지막 1번쨰는 포함 안됨.
- print(s[-3:]) : rld, 마지막에서 문자열의 끝까지



#### 숫자형 슬라이싱

- a=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
- print(a[7:]) : a[7]포함하여 이후 모두 출력. [7, 8, 9]
- print(a[:3]) : a[3] 제외하고 이전 모두 출력.
- print(a[:7:2]) : 2칸씩 띄고 출력. [0, 2, 4, 6]



#### for문

```python
for i in range(10):
    print("i = ", i)
```

- i를 0부터 9까지 1씩 증가하면서 10번 반복함. range(최종치)에서 최종치는 포함되지 않음.
- `for i in rage(1, 11, 3):` : i를 1부터 10까지 3씩 증가시킴. i=1, 4, 7, 10
- `for i in [리스트]` : 리스트 값을 하나씩 출력함.
- 파이썬은 print()하면 자동으로 개행됨.



#### while문

```python
sum = 0
i = 0
while i < 10:
    i = i + 1
    print("i = ", i)
    sum += i
    print("합 = ", sum)
```



#### 반복문의 흐름 제어

- pass : 실행할 코드가 없으므로 명령으로 이동함.
- continue : 반복문의 시작으로 이동함.
- break : 반복문을 멈추고 반복문을 벗어남.



#### Python 클래스와 인스턴스

```python
class Peo:
    def p_init(self):
        self.name = "None"
        self.age = -1
    def p_pro(self):
        self.name = "Java"
        self.age = 20
    def p_prt(self):
        print(self.name, self.age)
p1 = Peo()
p1.p_init()
p1.p_pro()
p1.p_prt()
```

- self는 클래스의 인스턴스를 가리키며 self를 통해 클래스의 메소드와 변수에 접근할 수 있음.
- self 변수명은 반드시 self명을 사용할 필요가 없으며, 다른 변수명을 사용해도 메소드의 첫 번째 위치한 매개 변수명은 자기 자신을 가리키는 self 변수의 의미로 사용됨.



#### Scrapy

- 파이썬 기반의 웹크롤러 프레임워크
- 가볍고 빠르고 확장성이 좋음.



## 3. 객체지향 기술

### 객체지향 기술의 개념(중)

#### 객체

- 객체(Object, 오브젝트)
  - 객체(Object) = 속성(Attribute) + 메소드(Method)
  - 속성과 메소드로 구성된 클래스의 인스턴스(객체 복사품)를 의미함.
- 속성(Attribute, 애트리뷰트)
  - 자료 구조, 변수, 데이터, 성질, 분류, 식별, 수량, 상태를 의미함.
- 메소드(Method)
  - 행위, 기능, 함수, 프로시저, 연산, 메소드는 동사형, 객체는 명사형임.



#### 객체의 구성 요소

- 클래스(Class)
  - 하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 데이터 추상화를 의미함.
  - 객체의 타입을 정의하고 객체를 생성하는 틀을 의미함.
- 객체(Object)
  - 개체(Entity), 속성(Attribute), 메소드(Method)로 구성된 클래스의 인스턴스를 의미함.
- 인스턴스(Instance)
  - 실행 중인 임의의 프로세스, 클래스의 현재 생성된 객체를 가리킴.
  - 클래스로 정의된 객체의 복사본이라고 할 수 있음.
- 메시지(Message)
  - 객체와 객체들 사이의 인터페이스 형식을 메시지라고 하며 메시지를 주고받음으로써 객체 간의 상호 작용을 함.
  - 메시지는 객체에 어떤 행위를 하도록 지시하는 명령임.



#### 캡슐화(Encapsulation)

- 구조적 설계에서 모듈화와 같은 의미.
- 객체를 정의할 때 연관된 속성(자료 구조, 데이터 등)과 방법(함수, 기능 연산 등)을 한 테두리로 묶는 것을 말함.
- 장점
  - 가독성이 좋아 유지보수가 용이함.
  - 재사용성 올라감.
  - 중복 최소화
  - 인터페이스 단순화
  - 정보 은폐로 내부 자료의 일관성이 유지됨
  - 변경이 발생할 때 오류의 파급 효과가 작음.



#### 정보 은폐

- Information Hiding, 정보 은닉
- 캡슐화된 객체 내부에 속성이나 메소드의 기능이 외부에 영향을 받거나 주지 않도록 설계하는 방법.
- 고려하지 않은 영향(Side Effect)들을 최소화하기 위하여 사용됨.
- 모듈이나 객체 사이의 독립성을 유지하는 데 도움이 됨.
- IP 주소와 같은 물리적 코드, 상세 데이터 구조 등 캡슐화된 항목을 다른 객체로부터 은폐해야 함.



#### 추상화

- Abstraction
- 불필요한 것은 제외하고 공통적으로 사용 가능한 큰 틀을 구상함.
- 공통 성질을 추출하여 슈퍼 클래스(부모 클래스)로 구성함.
- 현실 세계를 자연스럽게 표현함. 객체 중심의 안정된 모델을 구축할 수 있음.
- 추상화는 복잡한 문제의 본질을 이해하기 위해 세부 사항은 배제하고 중요한 부분을 중심으로 간략화하는 기법임.
- 객체가 될 수 있는 사람, 새, 말, 사자, 호랑이 등을 대표할 수 있는 객체는 존재하지 않지만 동물이라는 대표성을 가진 추상적인 데이터를 만들어 사용할 수 있음.
- 추상화 기법 종류
  - 제어 추상화
  - 기능 추상화 : 입력 자료를 출력 자료로 변환하는 과정을 추상화하는 방법.
  - 자료 추상화
  - 과정 추상화 : 자세한 수행 과정을 정의하지 않고 전반적인 흐름만 파악할 수 있게 설계하는 방법.
  - 데이터 추상화 : 데이터의 세부적인 용도를 정의하지 않고 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법




#### 다형성

- Polymorphism
- 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질을 다형성이라고 함.
- 동일한 이름의 메소드를 다른 사양으로 정의할 수 있음.
- 다형성은 한 메시지가 객체에 따라 다른 방법으로 응답할 수 있도록 설계해야 함(오버로딩)
- 상이한 클래스들이 동일한 메소드명을 이용하는 능력이 있어야 함(오버라이딩)



### 객체지향 개발 순서(상)

#### 객체지향 개발 순서

- 계획
- 분석(OOA) : 객체 모델링 -> 동적 모델링 -> 기능 모델링
- 설계(OOD) : 객체 설계 -> 시스템 설계
- 구현(OOP)
- 테스트 및 검증 : 단위 테스트 -> 통합 테스트 -> 검증과 시스템 테스트



#### 객체지향 분석

- OOA : Object Oriented Analysis
- 객체지향 분석의 특징
  - 소프트웨어를 개발하기 위한 비즈니스를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석해 내는 기법.
  - E-R 다이어그램은 객체지향 분석의 표기법으로 적합함.
- 객체지향 분석의 순서 (럼바우)
  - 객체 모델링
    - Object Modeling, 객체 모형
    - 문제 영역에서 요구되는 객체를 찾아내고 객체의 속성, 연산을 식별하는 단계.
  - 동적 모델링
    - Dynamic Modeling, 동적 모형
    - 객체 모델링에서 생성된 객체 모형들의 행위, 상태, 조건을 파악하는 단계.
    - 사건(Event)과 상태(State)를 파악하여 상태도를 만듦.
    - 상태 다이어그램(State Diagram)이 활용됨. (UML 행위적 다이어그램 중 하나)
    - 객체가 할 수 있는 일과 없는 일 구분함.
  - 기능 모델링
    - Functional Modeling, 기능 모형
    - 입출력 결정
    - 자료 흐름도(DFD)
    - 기능의 내용을 상세히 기술
    - 제약사항을 결정하고 최소화



#### 객체지향 분석 방법론

- Rumbaugh 방법 (럼바우 방법)
  - 객체 모델링 기법이라고도 함. Object Modeling Technique
  - 가장 일반적으로 사용되는 방법
  - 분석 활동을 **객체모델, 동적모델, 기능모델**로 나누어 수행하는 방법
    - 객체 모델링
      - **객체 다이어그램**(객체 관계)으로 표시.
      - 가장 중요하며 선행되어야할 모델링.
    - 동적 모델링
      - **상태 다이어그램(상태도)**를 이용해 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링.
    - 기능 모델링
      - **자료 흐름도(DFD)**를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리
      - 어떤 데이터를 입력하여 어떤 결과를 구할 것인가를 표현함.
  - 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법
- Booch 방법 (부치 방법)
  - 미시적, 거시적 개발 프로세스를 모두 사용하는 분석 방법
  - 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의함.
- Jacobson 방법
  - Usecase 유스케이스를 사용하여 분석함.
  - 사용자가 제품 또는 시스템과 어떻게 상호 작용하는지를 서술한 시나리오로 접근
- Coad Yourdon 방법 (코드와 이든 방법)

  - 객체지향 분석 방법론 중 E-R 다이어그램을 사용하여 객체의 행위를 모델링함.

  - 객체 식별, 구조 식별, 주체 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성되는 방법임.
- Wirfs-Brock 방법
  - 분석과 설계간 구분 없음
  - 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행함.
  - 고객 명세의 평가로 시작하여 설계로 끝나는 연속적인 프로세스로 접근



#### 객체지향 설계

- OOD, Object Oriented Design
- 객체지향 설계의 원칙
  - 단일 책임의 원칙
    - SRP, Single Responsibility Principle
    - 객체는 하나의 책임만 맡아 처리할 수 있게 해야 함
    - 낮은 결합도, 높은 응집성을 유지할 수 있음.
  - 개방 폐쇄 원칙
    - OCP, Open-Closed Principle
    - 소프트웨어 개체는 확장에는 열고, 수정 시에는 닫혀있게 해야 함.
    - 개체는 객체, 모듈, 함수 등이 있음.
  - 리스코프 치환의 원칙
    - LSP, Liskov Substitution Principle
    - 서브 타입(상속받은 하위 클래스)은 어디에서나 자신의 기반 타입(상위 클래스)으로 교체할 수 있어야 함.
    - 자동 타입 변환
  - 인터페이스 분리의 원칙
    - ISP, Interface Segregation Principle
    - 한 개의 일반적인 인터페이스보다 구체적이고 안전한 여러 개의 인터페이스가 좋음.
    - 클라이언트는 자신이 사용하지 않는 메소드와 의존 관계를 맺으면 안 됨.
    - 클라이언트가 사용하지 않는 인터페이스 때문에 영향을 받아서는 안 됨.
  - 의존성 뒤집기의 원칙
    - DIP, Dependency Inversion Principle
    - 추상화 클래스에 의존하게 되므로, 구체적인 클래스에 의존하지 않도록 해야 함.



### 자바(Java)(하)

#### 접근 지정자 (접근 제어자)

|   접근 영역   | private | default | protected | public |
| :-----------: | :-----: | :-----: | :-------: | :----: |
| 자신의 클래스 |    O    |    O    |     O     |   O    |
|  같은 패키지  |    X    |    O    |     O     |   O    |
|  하위 클래스  |    X    |    X    |     O     |   O    |
|  다른 패키지  |    X    |    X    |     X     |   O    |



#### 오버로딩과 오버라이딩

- 오버로딩(Overloading)
  - 하나의 클래스 안에서 동일한 이름을 가진 메소드를 사용하는 기술.
  - 메소드 이름 같고, 메소드의 인수 개수, 유형이 다르면 오버로딩이 가능함.
- 오버라이딩(Overriding)
  - 추상 클래스에서 동일한 메소드명과 인수를 정의해주면, 메소드 안의 프로그램은 상속받은 클래스에서 다양하고 독립적으로 프로그래밍을 할 수 있도록 한다는 개념.



#### 자바스크립트 프로토타입

- 자바스크립트에는  클래스라는 개념이 없음.
- 기존의 객체를 복사하여(cloning) 새로운 객체를 생성하는 프로토타입 기반의 언어임.
- 객체 원형인 프로토타입을 이용하여 새로운 객체를 만들고 이렇게 생성된 객체 역시 또다른 객체의 원형이 될 수 있음.



### UML 다이어그램(중)

#### UML

- Unified Modeling Language. 객체지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어.
- UML의 특징
  - 가시성
  - 명세화
  - 문서화
- UML 구성 요소
  - 사물 (Things) : 구조사물 / 행위사물 / 그룹사물 / 주석사물
  - 관계 (Relationships)
  - 다이어그램 (Diagrams)



#### 구조 다이어그램

- Structure Diagram, 정적 다이어그램

- 클래스 다이어그램(Class Diagram)
- 객체 다이어그램(Object Diagram)
- 패키지 다이어그램(Package Diagram)
- 컴포넌트 다이어그램(Component Diagram) : 
- 복합 구조 다이어그램(Composite structure Diagram) : 컴포넌트나 클래스의 내부 연결 형태를 표현함.
- 배치 다이어그램(Deployment Diagram) : H/W 자원의 연결 표현, 설계 마지막 단계



#### 행위 다이어그램

- Behavior Diagram, 동적 다이어그램

- 유스케이스 다이어그램(Usecase Diagram)
- 상태 다이어그램(State Machine Diagram)
- 활동 다이어그램(Activity Diagram)
- 시퀀스 다이어그램(Sequence Diagram, 순차 다이어그램)
- 통신 다이어그램(Communication Diagram, Collaboration Diagram, 커뮤니케이션 다이어그램, 협력 다이어그램)
- 상호 작용 다이어그램(Interaction Overview Diagram)
- 타이밍 다이어그램(Timing Diagram)

- UML의 관계
  - 연관 관계(Association)
  - 집합 관계(Aggregation)
  - 포함 관계(Composition)
  - 일반화 관계(Generalization)
  - 의존 관계(Dependency)
  - 실체화 관계(Realization)
- UML 확장 모델의 스테레오 타입
  - 기본적 요소 이외에 새로운 요소를 만들어내기 위한 확장 메커니즘
  - '<<>>'(Guillemet, 길러멧) 기호를 사용하여 표현함.



#### 클래스 다이어그램

- Class Diagram
- 클래스와 클래스, 클래스의 속성 사이의 관계를 표현함
- 객체를 생성하기 위한 도구, 틀임.
- 접근 제어 지정자의 기호
  - \+ : public
  - \- : private
  - \# : protected
  - \~ : package



#### 유스케이스 다이어그램

- 사용자 시각에서 소프트웨어 범위와 기능을 설명하는 설계 표기법
- 구조적 분석 방법론에서는 자료 흐름도(DFD), 객체지향 분석 방법론에서는 유스케이스 다이어그램을 사용함.
- 유스케이스는 사용자 시각으로 본 시스템의 행위를 말함.

- 구성요소
  - Actor : 사람모양. 사용자를 나타냄.
  - Usecase : 타원, 시스템의 행동을 나타냄.
  - Relationship : 액터와 유스케이스 연결
- 관계 표현
  - 연관 관계 : 실선
  - 포함 관계 : <\<include>>
  - 확장 관계 : <\<extends>>
  - 일반화



#### 시퀀스 다이어그램

- Sequence Diagram, 순차 다이어그램
- 액터 간의 상호 작용을 시간 순서에 따른 메시지 전달로 표현함.
- 객체 간에 주고받는 메시지의 순서를 시간의 흐름에 따라 보여줌.
- 구조적 설계 방법론에서는 구조도(Structured Chart), 객체지향 설계 방법론에서는 시퀀스 다이어그램을 사용함.
- 구성 요소
  - 객체 : 액터 + 유스케이스
  - 생명선 : 세로 점선
  - 실행 : 세로 사각형
  - 메시지 : 화살표 위에 메시지, 동기식과 비동기식이 있음.
    - 동기식 (synchronous) : 검은 삼각형 화살표. 상호작용을 계속하기 전에 응답을 필요로 함.
    - 비동기식 (asynchronous) : -> 열린 화살표. 응답 필요없음.
    - Reply or Return Message : 열린 화살표 점선.
  - 시간 : 세로 사각형의 길이가 실행 시간임.



#### UML 다이어그램의 관계 표현

- 연관 관계 (Assiciation)
  - 단방향 연관 관계 : 화살표로 표시
  - 양방향 연관 관계 : 실선으로 표시
  - 다중성 표기 1..* : 1 또는 여러 개
- 일반 관계 (Generalization)
  - 상속 관계에 있을 때 빈 삼각형 화살표로 표시함.
  - 한 클래스가 다른 클래스를 포함하는 상하 관계일 때, 일반화 관계가 존재함.
  - 일반화 관계를 "is kind of" 관계라고 함.
- 집합 관계
  - 집약 관계 (Aggregation) : 빈 마름모. 다른 전체 객체와 공유 가능.
  - 합성 관계 (Composition) : 채워진 마름모. 다른 전체 객체와 공유 불가
- 의존 관계 (Dependency)
  - 연관 관계 : 화살표로 표시. 계속적으로 관계 유지할 경우.
  - 의존 관계 : 점선 화살표로 표시. 일시적으로 관계 유지할 경우.
- 실체 관계 (Realization)
  - 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계
  - 인터페이스 관계에 있을 때 표시함
  - 빈 삼각형 점선 화살표로 표시함.
  - "can do this" 관계라고 함.



### 디자인 패턴(Design Pattern)(중)

#### 디자인 패턴

- 장점
  - 개발자들 간의 원활한 의사소통이 가능함.
  - 소프트웨어의 아키텍처(구조)를 파악하기 용이함.
  - 재사용성과 확장성이 좋아 개발 시간을 단축시킬 수 있음.
  - 설계 변경에 따른 유연성, 이식성이 좋아짐.
- 단점
  - 객체지향 개발 위주로만 사용할 수 있음
  - 초기 비용이 많이 듦.



#### GoF 디자인 패턴

- 개념
  - 디자인 패턴을 목적으로 분류할 때 생성, 구조, 행위로 분류할 수 있음.
  - 행위 패턴은 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의함.

- 생성패턴(Creational Pattern)
  - 추상 팩토리(Abstact Factory)
  - 빌더(Builder)
  - 팩토리 메소드(Factory Method)
  - 프로토타입(Prototype)
  - 싱글톤(Singleton)
- 구조패턴(Structural Pattern)
  - 어댑터(Adapter)
  - 브릿지(Bridge)
  - 컴포지트(Composite)
  - 데코레이터(Decorator)
  - 파싸드(Facade)
  - 플라이웨이트(Flyweight)
  - 프록시(Proxy)
- 행위패턴(Behavioral Pattern)
  - 책임연쇄(Chain of Responsibility)
  - 커맨드(Command)
  - 인터프리터(Interpreter)
  - 반복자(Iterator)
  - 중재자(Mediator)
  - 메멘토(Memento)
  - 옵저버(Observer)
  - 상태(State)
  - 전략(Strategy)
  - 템플릿 메소드(Template Method)
  - 방문자(Visitor)



## 4. 프로그램 개발 환경 구축

### 프로그램 개발 환경(하)

### 배치 프로그램(하)

#### 배치 프로그램

- 개념
  - 사용자와의 상호 작용 없이 특정 작업을 작업 단위로 묶어 주기적으로 반복 수행해보거나 정해진 규칙에 따라 일괄 처리하는 것.
  - 대용량의 데이터를 처리함 / 특정 시간에 실행됨 / 일괄적으로 처리함.

- 필수 요소
  - 대용량 데이터
  - 자동화
  - 견고함
  - 안정성
  - 성능



## 5. 명령어와 주소 지정

### 명령어 수행 순서(하)



### 명령어 형식과 주소 지정(하)



## 6. 운영체제

### 운영체제의 개념(상)

#### UNIX

- 개념
  - 상당 부분 C언어 사용. 이식성이 우수함.
  - Linux는 UNIX의 호환 커널임.
  - 사용자는 하나 이상의 작업을 백그라운드에서 수행할 수 있어 여러 개의 작업을 병행 처리할 수 있음.
  - 두 사람 이상의 사용자가 동시에 시스템을 사용할 수 있어 정보와 유틸리티들을 공유하는 편리한 작업 환경을 제공함.
  - 소스를 누구나 볼 수 있도록 설계된 개방형 시스템임.
  - 트리 구조의 파일 시스템을 갖음
  - 이식성이 높으며 장치 간의 호환성이 높음
  - Multi-User, Multi-Tasking 지원.
- UNIX의 기본 구성
  - 커널(Kernel) : 유닉스 시스템이 부팅될 때 가장 먼저 읽혀지는 운영체제의 핵심 부분. 메모리 관리, 입출력 장치 관리 등 하드웨어와 관련된 작업을 수행하는 것으로 사용자들은 커널에 직접 접근할 수 없음.
  - 쉘(Shell) : 사용자 명령의 입력을 받아 시스템 기능을 수행하는 명령 해석기. 사용자와 시스템 간의 인터페이스를 담당함. 사용자와 커널 사이의 중계자 역할.
  - 유틸리티(Utility) : 문서 편집기, 데이터베이스 관리, 컴파일러, 네트워크 기능 등을 제공함.



#### UNIX 명령어

- fork : 프로세스 생성, 복제
- exit : 프로세스 끝마침.
- ls : 파일 목록 보여줌
- cat : 파일 내용을 화면에 출력함.
- cp : 파일 복사
- chmod : 파일 속성 및 Protection 변경
- mkdir(md) : 디렉토리를 생성함.
- pwd : 현재 디렉토리를 출력함.
- chdir(cd) : 현재 디렉토리를 변경함.
- rmdir : 디렉토리 제거
- umask : 파일이나 디렉토리 생성 시 부여되는 기본 허가권을 지정하는 명령. 666



### 프로세스 관리(중)

#### 프로세스

- 개념
  - Process, Job, Task
  - 실행중인 프로그램.
  - 비동기적 행위를 일으키는 주체
  - 운영체제가 관리하는 실행의 단위
  - PCB를 가진 프로그램
- 용어 정리
  - PCB : 운영체제 내에서 한 프로세스의 존재를 정의함.
  - 디스패치 : 준비 상태에서 대기하고 있는 프로세스 중 하나가 CPU를 할당받아 실행 상태로 변하는 시점.
- 프로세스 상태의 종류
  - 제출(Submit)
  - 접수(Hold)
  - 준비(Ready)
  - 실행(Run)
  - 대기(Wait)
  - 블록(Block)
  - 종료(Terminated)



#### PCB

- Process Control Block
- 운영체제 내에서 한 프로세스의 존재를 정의하는 것.
- 여러 개의 프로세스를 수행하는 다중 프로그래밍 환경하에서 각 프로세스를 구분하기 위한 프로세스 제어 블록.
- PCB 테이블은 프로세스들의 현재 상태를 기록한 정보 테이블이며 각 프로세스의 주기억 장치에 적재된 기억 장치 위치 혹은 포인터와 식별자 등이 PCB 항목으로 기록됨.



#### 문맥 교환

- Context Switching
- 다중 프로그래밍 시스템에서 운영체제에 의하여 CPU가 할당되는 프로세스를 변경하기 위하여 현재 CPU를 사용하여 실행되고 있는 프로세스의 상태 정보를 저장하고, 앞으로 실행될 프로세스의 상태 정보를 설정한 다음에 CPU를 할당하여 실행되도록 하는 작업.



#### 프로세스 스케줄링

- 개념
  - 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에 할당하는 작업을 말함.
  - 비선점
    - 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법.
    - 프로세스 응답시간 예측이 용이함. 일괄 처리 방식에 적합함.
    - 중요하지 않은 작업 때문에 중요한 작업이 기다리는 경우가 발생할 수 있음.
    - FCFS, SJF, HRM 등
  - 선점
    - 하나의 프로세스가 CPU 할당받아 사용하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법.
    - 우선순위가 높은 프로세스를 빠르게 처리 가능함
    - 빠른 응답시간을 요구하는 대화식 시분할 시스템에서 사용함
    - 많은 오버헤드를 초래함
    - 선점이 가능하도록 인터럽트용 타이머 클록이 필요함
    - RR, SRT, MLQ, MLFQ 등
- FIFO
  - FCFS, First Come First Service
  - 준비상태 큐에 도착한 순서에 따라 차례로 CPU 할당함
  - 공평성은 유지되지만 중요한 작업이 중요하지 않은 작업을 기다리게 되는 경우 발생함.
- SJF
  - Shortest Job First
  - 실행시간이 짧은 프로세스에 먼저 CPU 할당
  - 가장 적은 평균 대기시간을 제공함.
- HRN
  - Highest Response-ratio Next
  - 실행시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 기법
  - 대기시간과 실행시간을 이용함
  - 우선순위 계산 결과값이 높은 것부터 우선순위를 부여, 대기시간이 긴 프로세스일 경우 계산 결과값이 높게 나옴.
  - 공식 : (대기시간+서비스시간)/서비스시간
- RR
  - Round Robin
    - FIFO를 선점 형태로 변형한 기법
    - 동일한 시간 할당량을 사용하는 시분할 처리 시스템을 위해 고안됨
    - 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당받는 것은 FIFO와 동일함
    - 각 프로세스는 할당된 시간 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에 CPU를 넘겨주고 큐의 가장 뒤로 배치됨
    - 할당되는 시간이 클 경우 FIFO와 같아지고 작을 경우 문맥교환 및 오버헤드가 자주 발생하게 됨

- SRT
  - Shortest Remaining Time
  - SJF 알고리즘을 선점 형태로 변형한 기법
  - 현재 실행중인 프로세스의 남은 시간과 준비상태 큐에 새로 도착한 프로세스의 실행 시간을 비교
  - 가장 짧은 실행 시간을 요구하는 프로세스에 CPU를 할당함.
- MLQ
  - Multi Level Queue, 다단계큐
  - 혼합형. 우선순위가 가장 높은 큐에서는 비선점형, 우선순위가 낮은 큐에서는 선점형으로 사용됨.
  - 프로세스를 특정 그룹으로 분류할 수 있을 경우 그룹에 따라 각기 다른 준비상태 큐를 사용함.
- MLFQ
  - Multi Level Feedback Queue, 다단계 피드백큐
  - 특정 그룹의 준비상태 큐에 들어간 프로세스가 다른 준비상태 큐로 이동할 수 없는 다단계큐 기법을 이동할 수 있도록 개선한 기법



#### 임계구역

- 개념
  - Critical Section, 위험지구
  - 다중 프로그래밍 기법에서 두 개 이상의 프로세스가 운영될 때 서로 공유하게 되는 자원을 말함.



#### 상호배제

- 개념
  - Mutual Exclusion
  - 임계구역을 어느 시점에서 단지 한 개의 프로세스만이 사용할 수 있도록 함.
  - 다른 프로세스가 현재 사용 중인 임계구역에 대하여 접근하려고 할 때 이를 금지하는 행위.
- 상호배제 알고리즘
  - 데커 알고리즘 Dekker's Algorithm
    - 2개의 프로세스를 위한 최초의 정확한 상호배제 해결법.
    - flag, turn 변수 사용
  - 램퍼드 알고리즘
    - 프로세스 n개의 상호 배제 문제를 해결한 알고리즘.
  - 피터슨 알고리즘 Peterson Algorithm
    - 모든 상호 배제를 위한 추가 조건을 만족하고 데커 알고리즘보다 단순함.



#### 세마포어

- 개념
  - Semaphore
  - 상호배제 원리를 보장하는 알고리즘.
  - 잠자기와 꺠우기의 연산을 이용하여 공유자원의 수를 나타내는 변수를 세마포어 변수 S라고 함.
  - P연산과 V연산을 사용함.



#### 교착상태

- 개념
  - DeadLock
  - 복수의 프로세스가 가능하지 못한 상태를 무한정 기다리고 있는 상태를 말함.
- 교착상태 발생 필요 충분 조건 4가지
  - 상호배제(Mutual Exclusion)
    - 프로세스들은 필요로 하는 자원에 대해 배타적인 통제권을 갖음.
    - 임계구역을 두 개 이상의 프로세스가 동시에 접근하지 못하도록 하는 과정에서 발생할 수밖에 없음.
  - 비선점(Non Preemption)
    - 하나의 프로세스가 공유 자원을 사용하는 중에 중단되었을 때, 중단된 프로세스를 선점할 수 없기 때문에 발생할 수밖에 없음.
  - 환형 대기(Circular Wait, 순환 대기)
    - 서로 물고 물리는 상황.
  - 점유와 대기(Hold and Wait)
    - 점유한 프로세스, 대기하는 프로세스가 존재하는 한 교착상태 발생.
- 교착상태 해결 방안
  - 필요악. 제한된 자원에서 여러 개의 프로세스가 운영되는 상황에서는 당장 사용하지 않는 자원을 다른 프로세스가 사용하도록 해야 컴퓨터 시스템을 효율적으로 사용할 수 있음.
  - 교착상태 예방 Prevention
    - 상호배제 부정
    - 비선점 부정 : 가장 현실적이고 실현 가능.
    - 점유와 대기 부정
    - 환형 대기 부정
  - 교착상태 회피 Avoidance
    - 프로세스가 자원을 요구할 때 시스템이 안전 상태를 유지할 수 있는 프로세스의 자원 요구만을 할당하여 주는 방안.
    - 자원 분배를 교착상태가 발생하지 않는 범위 내에서 하는 방안.
    - 은행원 알고리즘이 가장 대표적임.
  - 교착상태 발견 Detection
    - 컴퓨터 중단 원인이 교착상태인지 아니면 다른 이유인지를 파악하는 방안.
    - 자원들과 프로세스들을 인접 행렬로 표현하여 파악함.
  - 교착상태 회복 Recovery
    - 교착상태가 발생한 프로세스 중에 희생양을 정하는 일. 희생양이 정해지면 그 프로세스를 잠시 중단시키고 점유하고 있던 자원을 빼앗음.



#### 은행원 알고리즘



### 기억 장치 관리(중)

#### 고정 분할 할당 기법 (정적 분할)

#### 가상 기억 장치

- 사용하지 않는 프로그램을 외부기억 장치로 옮김으로써 주기억 장치의 실제 크기보다 큰 프로그램을 실행할 수 있게 하는 기억 장치.
- 프로그램을 분할하여 당장 필요한 것만 주기억 장치에 적재하거나 교체하면서 실행할 수 있음.
- 가상 기억 장치 기술의 등장으로 사용자 프로그램의 크기에 제한이 없어짐.
- 프로그램을 작은 크기로 분할할 때, 분할 크기가 모두 똑같다면 페이지(Page), 서로 다르면 세그먼트(Segment)라고 함.
- 



#### 페이징 기법 (Paging)

- 개념
  - 주기억 장치는 4개의 페이지를 적재할 수 있는 공간(페이지 프레임)만 있음.
  - 가상 기억 장치에 있는 프로그램 파일은 50K로 총 13개의 페이지로 분할되었음.
  - 하나의 페이지 크기가 4K이므로 50K/4K=12개, 나머지 2K의 자투리 페이지가 1개 있으므로 총 13개임.
  - 교체되는 페이지 정보는 페이지 사상표에서 갱신됨. (페이지 사상 테이블)
- 관련 용어
  - 스와핑 (Swapping)
  - 페이지 부재 (Page Fault) : 프로그램에서 접근하려고 하는 페이지가 주기억 장치에 없을 때 발생하는 현상. 없으면 디스크 드라이브에게 페이지를 가져오게 하고 페이지 사상표를 갱신하는 작업을 수행함. 이는 오류가 아니라 의도적으로 발생시키는 정상적인 행위임.
  - 스레싱 (Thrashing) : 하나의 프로세스가 작업 수행 과정 중 지나치게 페이지 부재가 발생함으로 인하여 전체 시스템의 성능이 저하되는 현상. 잦은 스와핑으로 프로그램 성능 저하되는 것.
  - 구역성 (Locality) : 어느 한순간에 특정 부문을 집중적으로 참조하는 프로그램의 순차적인 성질. 한 번 호출된 자료나 명령이 곧바로 다시 사용될 가능성을 말함. 페이지를 주기억 장치에 적재할 때 구역성을 고려하면 페이지 부재를 최소화할 수 있음.
  - 작업 집합 (Working Set) : 실행 중인 프로세스가 일정 시간 동안 참조하는 페이지들의 집합임. 자주 참조되는 페이지의 집합으로 주기억 장치에 고정 배치하여 교체 대상에서 제외함으로 교체 성능을 높이는 방법.



#### 반입 전략 (Fetch)

- 프로그램/데이터를 주기억 장치로 가져오는 시기(When) 결정 전략.
- 요구 반입 (Demand Fetch) : 새로 반입된 데이터나 프로그램 언제 주기억 장치로 가져올 것인가 결정하는 방법.
- 예상 반입 (Anticipatory Fetch) : 앞으로 요구될 가능성이 큰 데이터 또는 프로그램을 예상하여 주기억 장치로 미리 옮기는 방법.



#### 배치 전략 (Placement)

- 프로그램/데이터를 주기억 장치 내의 어디로 위치(Where) 시킬 것인가를 결정하는 전략.
- 최초 적합(First Fit)
  - 입력된 작업을 주기억 장치 내에서 그 작업을 수용할 수 있는 첫 번째 공백에 배치.
  - 초기 결정력이 가장 빠름.
  - 운영체제 다음부터가 시작점임.
  - 처음부터 순차적으로 검색하여 적재될 수 있는 공백이면 배치함.
- 최적 적합(Best Fit)
  - 입력된 작업을 주기억 장치 내의 공백 중에서 그 작업에 가장 잘 맞는 공백에 배치함.
  - 내부 단편화가 가장 작거나 없는 공백에 배치함.
  - 가장 잘 맞는 공백을 찾아야 하므로 결정력이 느림.
- 최악 적합(Worst Fit)
  - 입력된 작업을 주기억 장치 내에서 가장 잘 맞지 않는 공백, 즉 가장 큰 공백에 배치함.
  - 내부 단편화가 가장 큰 공백에 배치함.
  - 가장 잘 맞지 않는 공백을 찾아야 하므로 결정력이 느림.
- 최초 적합과 최적 적합 모두 시간 효율성과 공간 효율성 측면에서 최악 적합보다 좋다는 것이 입증되어 있으며, 최악 적합은 잘 사용되지 않음
- scaning time의 유무에 의해 일반적으로 최초 적합이 최적 적합보다 뛰어난 성능을 보여줌.
- 내부단편화 : 남은 공간이 작업보다 커서 프로그램의 사용 공간을 할당 후 사용되지 않고 남게 되는 작은 부분.
- 외부단편화 : 작업보다 많은 공간이 남아 있더라도 실제로 그 작업을 받아 들이지 못하는 경우.



#### 교체 전략 (Replacement, 페이지 교체 알고리즘)

- 개념

  - 주기억 장치에 적재된 페이지들을 대상으로 새롭게 적재될 페이지와 교체할 페이지를 선택하는 전략.

- 적재 예시

  - 처음 페이지가 적재될 때는 페이지 부재가 발생함.

- 종류

  - OPT
    - OPTimal replacement, 최적화 교체 전략
    - 앞으로 가장 오랫동안 사용되지 않을 페이지와 교체함.
    - 페이지 부재 횟수가 가장 적으므로 페이지 적중률이 가장 높음.
    - 실제 알고리즘에서는 미리 확인이 어려움. 이상적이지만 실현 가능성이 희박함

  - FIFO
    - First In First Out 교체 전략
    - 가장 오래 있던 페이지와 교체함
    - 가장 간단한 알고리즘.
    - 페이지 부재 가장 많이 발생함.

  - LRU
    - Least Recently Used 교체 전략
    - 계수기(시간 기억 영역)을 두어 가장 오랫동안 사용하지 않은 페이지를 교체할 페이지로 선택하는 방법.
    - 사용한 지 가장 오래된 페이지를 대상으로 교체함.

  - LFU
    - Least Frequently Used 교체 전략
    - 사용한 횟수가 가장 적은 페이지와 교체함

  - NUR
    - Not Used Recently 교체 전략
    - 최근에 호출하지도 사용하지도 않은 페이지를 제거함.
    - 두 개의 하드웨어 비트인 참조 비트(Referenced Bit)와 변형 비트(Modified Bit)를 사용함

  - Second Chance
    - 이차 기회
    - 가장 오래된 페이지가 최근에 사용할 가능성이 클 것이라는 가정하에 가장 오래된 페이지는 교체 대상에서 제외하고 사용한 것으로 취급함.
    - FIFO의 2차 기회 부여 방법. 2번째로 오래 된 페이지 교체.


  - PFF
    - Page Fault Frequency
    - 워킹 셋에 존재하는 페이지들을 관찰하여 최근에 자주 사용되고 있지 않은 페이지와 워킹 셋에 속하지 않은 페이지 중에 최근에 자주 사용하는 페이지와 교체함.



### 디스크 관리(하)

#### FCFS

- First Come First Service , FIFO
- 디스크 대기 큐에 가장 먼저 들어온 트랙에 대한 요청을 먼저 서비스.
- 디스크 오버헤드가 적을 때 효율적, 프로그래밍 쉬움.
- 헤드 이동 거리가 상당히 길어질 수 있음



#### SSTF

- Shortest Seek Time First
- 현재 헤드 위치에서 가장 가까운 작업부터 먼저 수행.
- 평균 탐색 시간이 짧음. 처리량이 많은 일괄 처리 시스템에 유용함.
- 가까운 트랙 서비스 요청 계속 발생하면 먼 거리 트랙 서비스는 무한정 기다려야 하는 기아 상태가 발생할 수 있음.
- 응답 시간 편차가 커서 대화형 시스템에는 부적합함.



#### SCAN

- 디스크 스케줄링 기본 전략
- 현재 헤드 위치에서 진행 중인 방향으로 탐색 거리가 짧은 순서에 따라 그 방향의 모든 요청을 서비스하고, 끝까지 이동한 후 역방향의 요청 사항을 서비스함.
- 지나는 길에 있는 대기 요청 + 새로운 요청까지 수행함.
- 응답시간 편차 줄일 수 있음.
- 오버헤드가 작을 경우 가장 효율적인 기법임.



#### C-SCAN

- 바깥쪽에서 안쪽으로 이동하면서 수행함.
- 끝까지 이동한 후 안쪽에 더 이상의 요청이 없으면 헤드는 가장 바깥쪽으로 이동한 후 다시 안쪽으로 이동하면서 요청을 서비스함.
- 처음과 마지막 트랙을 인접시킨 것과 같은 원형 형태로 디스크를 처리함.



#### FCB

#### FAT

- 호환성 우수
- 단순성
- 저용량 볼륨 최적화
- 보안 취약
- 대용량 볼륨 비효율적



#### NTFS

- 대용량 볼륨 지원
- 효율적 사용
- 강력한 보안
- 자동 압축 및 안전성
- 향상된 파일이름 저장 및 파일길이 지원
- 암호화기능 지원
- 윈도우 NT계열 운영체제 외에는 호환 불가
- 저용량 볼륨에서 FAT보다 속도 저하



### 분산 운영체제(하)

#### 스레드 (Thread)

- 프로세스 내에서의 작업 단위 / 경량 프로세스 / 독립적인 스케줄링의 최소 단위 / 실행될 명령어들의 연속.
- 다중 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당 받지만 다중 스레드는 하나의 스레드 내에서 각각 Stack만 따로 할당받고, Code, Data, heap 영역은 공유함.
- 사용자 수준의 스레드
  - 커널 개입이 작음
  - 런타임 시스템이 필요함
  - 속도가 빠름
  - 문맥 교환이 적음
  - 독자적 알고리즘이 필요함
  - 대형 시스템에 적당함
  - 구현이 어려움
  - 커널을 스스로 호출하지 못함
  - CPU 사용을 해제하지 못하면 시스템이 중단됨.
- 커널 수준의 스레드
  - 커널 개입이 큼
  - 런타임 시스템이 필요 없고 커널이 직접함
  - 속도가 느림
  - 문맥 교환이 많음
  - 독자적 알고리즘이 필요 없음
  - 대형 시스템에 부적합함
  - 구현이 쉬움
  - 커널을 스스로 호출함
  - 사용을 해제하지 못하면 운영체제가 지원함.

