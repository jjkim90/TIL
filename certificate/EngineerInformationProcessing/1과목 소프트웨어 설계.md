[TOC]

<br>

# 1과목 소프트웨어 설계

## 1. 소프트웨어의 종류 및 개발 방법론

### 소프트웨어 분류 및 특성(중)

#### 시스템 소프트웨어

- 시스템의 기본 요소



#### 플랫폼

- 플랫폼의 성능 특성 분석 항목 : 가용성, 응답 시간 등등등



#### 프레임워크

- 반제품 상태의 제품을 토대로 도메인별로 필요한 서비스 컴포넌트를 사용하여 재사용성 확대와 성능을 보장 받을 수 있게 하는 개발 소프트웨어.
- 설계 관점에 개발 방식을 패턴화시키기 위한 노력의 결과물인 소프트웨어 디자인 패턴을 반제품 소프트웨어 상태로 집적화시킨 것으로 볼 수 있음.
- 프레임워크의 동작 원리를 그 제어 흐름의 일반적인 프로그램 흐름과 반대로 동작한다고 해서 IoC(Inversion of Control)이라고 설명하기도 함.



#### 컴포넌트

- CBD



#### 소프트웨어 공학



### 소프트웨어 개발 방법론(상)



#### 미들웨어

- 개념
  - 미들과 소프트웨어의 합성어
  - 운영체제와 해당 운영체제에서 실행되는 응용 프로그램 사이에서 운영체제가 제공하는 서비스 이외에 추가적인 서비스를 제공하는 소프트웨어
  - 클라이언트와 서버 간의 통신을 담당하는 소프트웨어
  - 시스템 간의 데이터 교환에 일관성을 보장함
  - 여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어
  - 소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공함
  - 여러 컴포넌트를 1대1, 1대다, 다대다 등 여러 가지 형태로 연결이 가능함.
  - 이기종 하드웨어, 소프트웨어, 네트워크, 프로토콜, PC 환경, 운영체제 환경 등에서 시스템 간의 표준화된 연결을 도와주는 소프트웨어임.
- **미들웨어의 종류**
  - DBMS(Database Management System, 데이터베이스)
    - 데이터베이스 벤더에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어
    - DB를 사용해 시스템을 구축하는 경우 보통 2-Tier 아키텍처라고 함
    - 마이크로소프트 ODBC, 볼랜드의 IDAPI, 오라클의 Glue
  - RPC(Remote Procedure Call, 원격 프로시저 호출)
    - 응용 프로그램의 프로시저를 사용해 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어.
    - 이큐브 시스템즈의 Entera, OSF의 ONC/RPC
  - MOM(Message Oriented Middleware, 메시지 지향 미들웨어)
    - 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어
    - 온라인 업무보다 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용됨.
    - IBM의 MQ, 오라클의 Message Q, JPC의 JMS
  - TP-Monitor(Transaction Processing Monitor, TP모니터)
    - 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션을 처리 및 감시하는 미들웨어
    - 사용자 수가 증가하더라도 빠른 응답속도를 유지해야 할 경우 주로 사용됨.
    - 오라클의 tuxedo, 티맥스소프트의 tmax
  - ORB(Object Request Broker, 객체 요청 브로커)
    - 객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현한 미들웨어
    - TP-Monitor의 장점인 트랜잭션 처리와 모니터링을 추가한 제품도 나오고 있음.
  - WAS(Web Application Server, 웹 어플리케이션 서버, 와스)
    - 정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위한 미들웨어
    - 클라이언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어임
    - HTTP 세션 처리를 위한 웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현이 가능함.
    - 오라클의 WebLogic, IBM의 WebSphere



#### DBMS



#### WAS

- 종류



#### 소프트웨어 개발 방법론

- 구조적 방법론
  - 프로세스 중심의 하향식 방법론
  - 복잡한 문제를 다루기 위해 분할과 정복(Divide and Conquer) 원리를 적용함.
  - 구조적 프로그래밍 표현을 위해 나씨-슈나이더만 차트를 사용한다.
- 정보공학 방법론
  - 정보 시스템 개발에 필요한 절차와 작업 기법을 체계화한 방법론
  - 개발주기를 이용해 대형 프로젝트를 수행하는 체계적인 방법론
  - 정보공학 방법론에서 데이터베이스 설계의 표현으로 사용하는 모델링 언어는 E-R 다이어그램
- 객체지향 방법론
  - 객체라는 기본 단위로 시스템을 분석 및 설계하는 방법론
- 컴포넌트 기반 방법론(CBD, Component Based Development)
  - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
  - 개발 기간 단축으로 인한 생산성 향상
  - 새로운 기능 추가가 쉬운 확장성
  - 소프트웨어 재사용이 가능
- 애자일 방법론
  - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론
- 제품 계열 방법론(Product Line Development)
  - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
- 나씨-슈나이더만(Nassi-Shneiderman) 차트
  - 논리의 기술에 중점을 둔 도형식 표현 방법
  - 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현함
  - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합함.



#### 객체지향

- 개념
  - 현실 세계의 개체(Entity)를 기계 부품처럼 하나의 객체(Object)로 만들어, 기계적인 부품들을 조립해 제품을 만들듯이 소프트웨어를 개발할 때에도 객체들을 조립해서 작성할 수 있는 기법
  - 소프트웨어의 재사용 및 확장 용이, 유지 보수 쉬움
  - 복잡한 구조를 단계적 계층적으로 표현
- 객체(Object)
  - 데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 소프트웨어 모듈
  - 데이터 = 속성, 상태, 변수, 상수, 자료구조
  - 함수 = 메소드, 서비스, 동작, 행위
  - 독립적으로 식별 가능한 이름을 가짐
  - 객체가 가질 수 있는 조건 = 상태(State)
- 클래스(Class)
  - 공통된 속성과 연산을 갖는 객체의 집합, 객체의 일반적인 타입을 의미
  - 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
  - 클래스에 속한 각각의 객체 = 인스턴스(Instance)
  - 동일한 클래스에 속한 각각의 개체들은 공통된 속성과 행위를 갖음
- 캡슐화(Encapsulation)
  - 데이터와 데이터를 처리하는 함수를 하나로 묶은 것을 의미
  - 불필요한 기능 최소화
  - 소프트웨어 개발 비용 절감
  - 개발 속도 향상
- 상속(Inheritance)
  - 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려 받는 것
  - 하위 클래스는 상위 클래스로부터 받은 속성과 연산 외에도 새로운 것을 첨가할 수 있음.
  - 소프트웨어의 재사용을 높이는 중요한 개념임
  - 다중 상속 : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속 받는 것
- 다형성(Polymorphism)
  - 하나의 메시지에 대해 여러 가지 형태의 응답이 있는 것.
  - 하나의 메시지에 대해 각 객체가 갖고 있는 고유한 방법대로 응답하는 것을 의미함
  - 하나의 클래스나 메소드가 다양한 방식으로 동작이 가능한 것을 의미함.
  - 오버로딩과 오버라이딩이 존재함.
    - 다형성의 오버라이딩 : 상속 관계에서 상위 클래스 메소드를 하위 클래스에서 재정의하는 것
    - 다형성의 오버로딩 : 하나의 클래스 내에서 같은 이름으로 여러 개 메소드 정의
- 정보은닉(Information Hiding)
  - 캡슐화에서 가장 중요한 개념으로 다른 객체에 자신의 정보를 숨기는 것을 말함.

  - 연산만을 통해 접근을 허용함.

  - 각 객체의 수정이 다른 객체에 주는 Side Effect를 최소화하는 기술임.

  - 필요하지 않은 정보는 접근할 수 없도록 하여 한 모듈 또는 하부 시스템이 다른 모듈의 구현에 영향을 받지 않게 설계되는 것을 의미함.

  - 모듈들 사이의 독립성을 유지시키는 데 도움이 됨.

  - 설계에서 은닉되어야 할 기본 정보로는 IP주소와 같은 물리적 코드, 상세 데이터 구조 등이 있음.
- 추상화(Abstraction)
  - 불필요한 부분을 생략, 객체 속성 중 가장 유용한 것에 중점을 두어 모델화하는 것을 말함.

  - 완전한 시스템 구축 전, 그 시스템과 유사한 모델을 만들어 여러 요인들을 테스트할 수 있음.



#### 객체지향 5 원칙 SOLID

- 단일 책임 원칙
  - SRP, Single Responsibility Principle
  - 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙.
- 개방 폐쇄의 원칙
  - OCP, Open Close Principle
  - 소프트웨의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원리.
  - 요구사항의 변경이나 추가사항이 발생하더라도 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다는 뜻.
- 리스코프 교체의 원칙
  - LSP, Liskov Substitution Principle, 리스코프 치환 원칙
  - 서브 타입은 언제나 기반 타입으로 교체될 수 있어야 한다는 원칙.
  - 부모 객체와 이를 상속한 자식 객체가 있을 때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 원칙.
  - 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙.
  - 상속되는 객체는 반드시 부모 객체를 완전히 대체해도 아무런 문제가 없도록 권고함.
  - 가급적 부모 객체의 일반 메소드를 그 의도와 다르게 오버라이딩 하지 않는 것이 중요함.
  - 특정 메소드가 상위 타입을 인자로 사용할 때, 그 타입의 하위 타입도 문제 없이 작동해야 함.
- 인터페이스 분리 원칙
  - ISP, Interface Segregation Principle
  - 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다는 원칙.
  - 구현할 객체에게 무의미한 메소드의 구현을 방지하기 위해 반드시 필요한 메소드만을 상속/구현하도록 권고함
  - 인터페이스 분리 원칙은 객체가 반드시 필요한 기능만을 가지도록 제한하는 원칙임.
  - 불필요한 기능의 상속/구현을 최대한 방지함으로써 객체의 불필요한 책임을 제거함.
  - 큰 규모의 객체는 필요에 따라 인터페이스로 잘게 나누어 확장성을 향상시킴.
- 의존관계 역전의 원칙
  - DIP, Dependency Inversion Principle
  - 객체는 저수준 모듈보다 고수준 모듈에 의존해야한다는 원칙.
  - 고수준 모듈은 인터페이스와 같은 객체의 형태나 추상적 개념을 말하고 저수준 모듈은 구현된 객체를 말함.
  - 객체는 객체보다 인터페이스에 의존해야 함.
  - 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있음.
  - 상위 계층이 하위 계층에 의존하는 전통적인 의존 관계를 역전시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있음.




#### 애자일

- 개념

  - 애자일 방법론은 소프트웨어 개발방법론의 하나로 개발과 함께 즉시 피드백을 받아서 유동적으로 개발하는 방법

- 특징

  - 프로젝트의 요구사항은 기능 중심으로 정의
  - 절차와 도구보다 개인과 소통을 중요하게 생각
  - 작업 계획을 짧게 세워 요구 변화에 유연하고 신속하게 대응
  - 소프트웨어가 잘 실행되는 데 가치를 둠
  - 고객과의 피드백을 중요하게 생각

- 애자일 선언문

  - 공정과 도구보다 개인과 상호작용
  - 계획을 따르기보다 변화에 대응하기
  - 포괄적인 문서보다 동작하는 소프트웨어
  - 계약 협상보다 고객과의 협력

- 애자일 방법론 유형

  - 익스트림 프로그래밍
    - XP(eXtreme Programming) 기법
    - 애자일 방법 중 제일 많이 알려진 기법
    - 소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법
    - 익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것.
    - 기존의 방법론에 비해 실용성(Pragmatism)을 강조한 것이라고 볼 수 있음.
    - 5가지 핵심가치 (피존의용단)
      - 용기
      - 단순성
      - 의사소통
      - 피드백
      - 존중
    - XP 개발 프로세스
      - 사용자 스토리
      - 릴리즈 계획 수립
      - 스파이크 : 간단한 프로그램. 처리할 문제 외의 다른 조건 모두 무시
      - 주기(Iteration) : 1~3주 정도의 기간으로 진행.
      - 승인 검사(인수 테스트) : 고객이 직접 수행. 오류 발견시 다음 이터레이션에 포함
      - 소규모 릴리즈
    - XP의 주요 실천 방법
      - Pair Programming(짝 프로그래밍) : 책임 분산
      - Test-Driven Development(테스트 주도 개발)
      - Whole Team(전체 팀)
      - Continuous Integration(계속적인 통합) : 모듈 하나 마무리될 때마다 지속적 통합
      - Design Improvement(Refactoring, 리팩토링) : 기능 변경 없이 재구성
      - Small Release(소규모 릴리즈)
      - 40-Hour Work
      - On Site Customer(고객 상주)
      - Collective Ownership(공통 코드 소유)
  - 스크럼(SCRUM)
    - 팀이 중심이 되어 개발의 효율성을 높인다
    - 제품 책임자(PO, Product Owner) : 개발 의뢰자, 백로그 작성
    - 스크럼 마스터(SM, Scrum Master) : 조언. 진행 사항 점검. 장애 요소 공론화. 스크럼 프로세스를 따르고 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할 등을 맡음.
    - 개발팀(DT, Development Team) : PO, SM 제외한 모든 팀원, 백로그 우선순위x
    - 스크럼 개발 프로세스
      - 제품 백로그(Product Backlog)
      - 스프린트 계획회의(Sprint Planning Meeting)
      - 스프린트(Sprint)
      - 일일 스크럼 회의(Daily Scrum Meeting)
      - 스프린트 검토 회의(Sprint Review)
      - 스프린트 회고(Sprint Retrospective)
    - 제품 백로그 : 스크럼 팀이 해결해야 하는 목록. 소프트웨어 요구사항, 아키텍처 정의 등이 포함될 수 있음.
    - 스프린트 : 실제 개발을 2~4주간 진행하는 과정. 
    - 속도(Velocity) : 한 번의 스프린트에서 한 팀이 어느 정도의 제품 백로그를 감당할 수 있는지에 대한 추정치로 볼 수 있음.

  - 린(LEAN)
    - 도요타의 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론
    - 린의 7가지 원칙(낭품지 확인사전)
      - 낭비제거
      - 품질 내재화
      - 지식 창출
      - 늦은 확정
      - 빠른 인도
      - 사람 존중
      - 전체 최적화



#### 테일러링

- 필요성 내부기준 외부기준



#### 보안 개발 방법론

- MS-SDL, Seven Touchpoints 등



### 프로젝트 관리 및 생명주기 모형(상)

#### 인적 자원

- 개발자팀 구성
  - 책임 프로그래머팀 : 1인 독재 체제. 다수는 1인을 위해 보조 역할 담당.
  - 민주주의식팀 : 다수 책임 체제. 개개인의 담당 분야가 독립적으로 존재함.
  - 혼합형팀 : 책임 프로그래머팀과 민주주의식팀의 장점을 결합한 팀 구성.
- 책임 프로그래머팀의 구성
  - 책임 프로그래머(Chief Programmer)
  - 보조 프로그래머(Back-up Programmer) : 책임 프로그래머를 보좌, 기술적인 자문
  - 프로그래머(Programmer) : 책임 프로그래머의 지시에 따라 원시 코드 작성, 검사, 디버깅 및 문서 작성 등을 담당함.
  - 프로그램 사서(Program Librarian) : 프로그램 리스트, 설계 문서, 검사 계획서 등의 문서를 관리함.

- 책임 프로그래머팀
  - 중앙 집중형
  - 소규모 소프트웨어 개발에 유리함
  - 이직률이 높음
  - 단기적인 소프트웨어 개발에 유리함
  - 쉬운 프로젝트에 유리함
  - 스타형 구조
- 민주주의식팀
  - 분산형
  - 대규모 소프트웨어 개발에 유리함
  - 팀원들 대다수 만족도 높음
  - 이직률 낮음
  - 장기적인 소프트웨어 개발에 유리함
  - 복잡한 프로젝트에 유리함
  - 링형 구조



#### 위험 분석

- 개념
  - Risk Analysis
  - 프로젝트 추진 과정에서 예상되는 각종 돌발 상황을 예상하고 이에 대한 적절한 대책을 수립하는 일련의 활동.
- 위험 분석 절차
  - 위험 식별(Identification) : 위험 요소가 될 사항들을 파악함.
  - 위험 분석 및 평가 : 위험의 비중과 영향력을 파악함.
  - 위험 관리 계획 : 문서화.
  - 위험 감시 및 조치 : 위험을 항상 관찰하고, 발생 시 조치함.
- 위험 감시
  - Risk Monitoring
  - 위험 요소 징후들을 계속적으로 인지하는 것.
- 위험 회피
  - Risk Avoidance
  - 예상할 수 있는 위험을 회피하는 것. 상책.



#### PERT 차트

- Project Evaluation and Review Technique
- 작업과 시간을 매핑하고 추적하는 데 사용되는 시각적 프로젝트 관리 도구.
- Gantt 차트와의 차이점
  - 갠트 차트는 막대 그래프이고 PERT 차트는 자유 형식임
  - PERT 차트는 작업 종속성을 보여주지만 갠트 차트는 그렇지 않음.
- 전체 작업의 상호 관계를 표시하는 네트워크
- 개발 경험이 없어 소요 기간 예측이 어려운 프로젝트 일정 계획에 사용함.
- 작업 예측치 계산 공식 = (비관치 + 4x기대치 + 낙관치) / 6



#### CPM

- Critical Path Method, 임계 경로 기법
- 작업을 나열하고 작업에 필요한 소요 기간을 예측하는 데 사용하는 기법.
- 노드와 간선으로 구성된 네트워크.
- 원형 노드는 작업을 의미하고 작업 이름과 소요 기간을 표시함
- 박스 노드는 이정표를 의미하며 이정표 이름과 예상 완료 시간을 표시함.
- 간선을 나타내는 화살표의 흐름에 따라 각 작업이 진행됨.
- 전 작업이 완료되어야 다음 작업을 진행할 수 있음.
- 소요 기간이 확실한 경우에 유리함.



#### Gantt Chart

- 간트 차트, 갠트 차트, 시간선 차트
- 프로젝트 작업 일정을 막대 그래프를 이용하여 표시하는 프로젝트 일정표
- 프로젝트를 이루는 소작업 별로 언제 시작되고 언제 끝나야 하는지를 한 눈에 볼 수 있도록 도와줌.
- 자원 배치 계획에 유용하게 사용됨.
- CPM 네트워크로부터 만드는 것이 가능함.
- 중간 목표 미달성 시 그 이유와 기간을 예측할 수 있게 함.
- 활동이 다른 활동과 겹치는 부분과 그 정도를 한 눈에 볼 수 있음
- 이정표 / 작업 일정 / 작업 기간 / 산출물
- 수평 막대의 길이는 각 작업의 기간을 나타냄



#### 비용 측정

- 인월 : 한 사람이 1개월 동안 작업할 양. Man Month
- LOC : Line Of Code
- 생산성 : LOC / 인월
- 개발 기간 : 인월 / 개발 비용
- 개발 비용 : 인월 x 단위 비용



#### 비용 측정 방법론의 분류

- 하향식 : 전문가 측정, 델파이식 측정 (Delphi)
- 상향식 : LOC 측정, 단계별 인월, Walston 모형, COCOMO 모형, Putnam 모형, 기능 점수 모형, 간이 기능 점수



#### LOC 측정

- 예측치 = (낙관치 + (4x기대치) + 비관치) / 6



#### COCOMO 모형

- Basic COCOMO
- 유형
  - 유기형(Organic)
    - 기관 내부에서 개발된 중소 규모의 소프트웨어.
    - 일괄 처리나 과학기술 계산용, 비즈니스 자료 처리용
    - 5만 라인 이하의 소프트웨어를 평가하는 유형
  - 준 분리형(Semi-Detached)
    - 트랜잭션 처리 시스템이나 운영체제, 데이터베이스 관리 시스템 등
    - 30만 라인 이하의 소프트웨어를 평가하는 유형
  - 내재형(Embedded)
    - 초대형 규모의 트랜잭션 시스템이나 운영체제 등의 소프트웨어를 평가하는 유형
  - 규모 커질수록 MM 증가.



#### Putnam 모형

- 대형 프로젝트에서 이용되는 기법.
- Rayleigh-Norden 곡선의 노력 분포도 곡선으로 그려짐.
- 개발 기간이 연장될수록 프로젝트 적용 인원의 노력이 감소하므로 대형 프로젝트의 노력 분포 산정에 용이함.
- 개발 기술 지수는 임의로 부여할 수 있는 값으로 최악 환경 12000 보통 환경 8000 최상 환경 5000 등



#### 형상 관리

- 개념
  - Software Configuration Management
  - 소프트웨어의 변경 사항을 체계적으로 추적하고 통제하는 것
  - 단순 버전 관리보다 더 포괄적인 개념
  - 형상 관리를 통해 가시성과 추적성을 보장함으로써 소프트웨어의 생산성과 품질을 높일 수 있음.
- 형상 관리 절차
  - 형상 식별 -> 형상 통제 -> 형상 감사 -> 형상 기록/보고
  - 형상 식별
    - 형상 관리의 대상들을 구분하고 관리 목록의 번호를 정의하여 부여하는 과정
    - 형상 관리 계획을 근거로 형상관리의 대상이 무엇인지 식별하는 과정.
    - 형상 관리 대상 : 계획서, 매뉴얼, 명세서, 설계서, 소스코드
  - 형상 통제
    - 소프트웨어 형상 변경 제안을 검토, 현재 소프트웨어 기준선에 반영하도록 통제
    - 형상 통제가 이루어지기 위해서는 형상 통제 위원회 CCB의 승인을 통한 변경 통제가 이루어짐
  - 형상 감사
    - 형상 항목의 변경이 계획에 따라 제대로 이뤄졌는지 검토, 승인하는 것
    - 개발자, 유지보수 담당자가 아닌 제 3자의 객관적인 확인 및 검증 과정을 통해 새로운 형상의 무결성을 확보하는 활동.
    - 형상 관리 계획대로 형상관리가 진행되고 있는지, 형상 항목의 변경이 요구 사항에 맞도록 제대로 이뤄졌는지 등을 살펴보는 활동.
  - 형상 기록/보고
    - 소프트웨어 개발 상태에 대한 보고서를 제공하는 것.
    - 베이스라인 산출물에 대한 변경과 처리 과정에서의 변경을 상태 보고에 모두 기록.



#### 소프트웨어 생명주기

- Software Life Cycle
- 폭포수 모형(Waterfall)
  - 이전 단계를 확실히 마무리하고 다음 단계로 진행
  - 가장 오래됐고 폭넓게 사용
  - 선형 순차적 모델
  - 매뉴얼 작성 필수
  - 결과물 명확
- 프로토타입 모형(Prototype, 원형 모형)
  - 시제품을 만들어 최종 결과물 예측
  - 사용자와 시스템 사이 인터페이스에 중점
- 나선형 모형(Spiral)
  - 폭포수모형+프로토타입모형+위험분석 기능
  - 나선을 따라 돌듯이 여러 번의 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어 개발
  - 위험 관리 및 최소화가 목적
  - 누락되거나 추가된 요구사항을 첨가할 수 있음
  - 정밀하고 유지보수 과정이 필요 없음
  - 요구사항이나 아키텍처를 이해하기 어렵다거나 중심이 되는 기술에 문제가 있는 경우 적합한 모델임.
- V 모형 (V Model)
  - 요구분석1 -> 시스템 설계2 -> 상세 설계3-> 코딩 -> 단위 검사(3대응) -> 통합 검사(2대응) -> 시스템 검사(1대응) -> 인수/설치 / 1에서 모듈 검증 / 2에서 인터페이스 검증 / 3에서 요구분석 검증
  - Perry에 의해 제안되었으며 세부적인 테스트 과정으로 구성되어 신뢰도 높은 시스템을 개발하는데 효과적임.
  - 개발 작업과 검증 작업 사이의 관계를 명확히 들어내 놓은 폭포수 모델의 변형이라고 볼 수 있음.
  - 폭포수 모델이 산출물 중심이라면 V 모델은 작업과 결과의 검증에 초점을 둠.

- 애자일 모형(Agile)
  - 고객 요구사항 변화에 빠르고 유연하게 대응
  - 일정한 주기를 반복하며 진행
  - 고객과의 소통에 초점을 맞춘 모든 방법론을 통칭
  - 스프린트 또는 이터레이션이라 불리는 짧은 개발 주기 반복
  - 반복되는 주기마다 결과물에 대한 평과와 요구 수용



#### 테일러링을 위한 품질 관리

- ISO 12207 표준
  - 소프트웨어와 관련된 이해관계자들이 각자의 입장에서 수행해야 할 일을 정의하고 지속적으로 개선시키기 위한 활동임.
  - 기본 공정 : 공급, 획득, 개발, 운영, 유지보수
  - 지원 공정 : 문서화, 형상 관리, 문제 해결, 품질 보증, 검증, 확인, 합동 검토, 감리
  - 조직 공정 : 관리, 기반 구조, 개선, 교육 훈련

- ISO/IEC
  - ISO/IEC 9126 : 소프트웨어 품질 특성과 척도에 관한 표준 지침서
    - 기능성 : 적합성 / 정확성 / 상호 운용성 / 보안성 / 준수성
    - 신뢰성 : 성숙성 / 결함 허용성 / 회복성
    - 사용성 : 이해성 / 학습성 / 운용성 / 호감성
    - 효율성 : 시간 반응성 / 자원 효율성
    - 유지보수성 : 분석성 / 변경성 / 안정성 / 시험성
    - 이식성 : 적응성 / 설치성 / 상호공존성 / 대체성

  - ISO/IEC 12119 : 패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준.
  - ISO/IEC 29119 : 국제 표준.
  - ISO/IEC 25000 : SQuaRE. ISO/IEC 9126과 ISO/IEC 12119, ISO/IEC 14598 통합. 품질평가 통합모델 표준.
    - 2500n : 개요 및 품질 관리
    - 2501n : 품질 모델
    - 2502n : 품질 측정
    - 2503n : 품질 요구
    - 2504n : 품질 평가
    - 2505n : 확장 분야

- CMM 모델
  - Capability Maturity Model
  - 5가지 성숙 단계
    - 초기 단계
    - 반복 단계
    - 정의 단계
    - 관리 단계
    - 최적 단계

- SPICE 모델
  - Software Process Improvement and Capability dEtermination
  - 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준.
  - 수준 0 불안정 단계
  - 수준 1 수행 단계
  - 수준 2 관리 단계
  - 수준 3 확립 단계
  - 수준 4 예측 단계
  - 수준 5 최적화 단계

- CMMI 모델
  - CMM의 후속 모델
  - CMMI의 프로세스 영역
    - 프로세스 관리 영역
    - 프로젝트 관리 영역
    - 엔지니어링 영역
    - 지원 영역

  - CMMI 모델의 종류
    - SW-CMM
    - SECM
    - IPD-CMM
    - People-CMM
    - SA-CMM
    - SECAM




## 2. 요구사항 확인

### 현행 시스템 파악(하)

#### 현행 시스템 파악 개념

#### 저장 장치

- DAS
  - Direct Attached Storage
  - 하드 디스크와 같은 데이터 저장 장치를 호스트 버스 어댑터에 직접 연결하는 방식.
  - 저장 장치와 호스트 기기 사이에 네트워크 디바이스가 없음.
  - 서버 장비에 직접 연결하여 운용하는 방식.
  - RAID : 하드디스크를 여러 개 연결해 용량 확장. 신뢰성 보장.

- NAS
  - Network Attached Storage
  - 서버와 저장 장치를 네트워크로 연결하는 방식. 구성 설정이 간편함.
  - 별도의 운영체제를 가진 서버 한 곳에서 파일을 관리하기 때문에 서버 간에 스토리지 및 파일 공유가 용이함.

- SAN
  - Storage Area Network
  - DAS의 빠른 처리와 NAS의 스토리지 공유 장점을 합친 방식.
  - 케이블과 광채널 스위치를 통해 근거리 네트워크 환경을 구성하여 빠른 속도로 데이터를 처리할 수 있음.
  - 파이버 채널 스위치로 서버들과 스토리지들을 연결함.

- SDS
  - Software Defined Storage
  - 기존의 저장 장치(스토리지) 시스템의 한계점(데이터의 폭증, 예측 불가능한 데이터 등)을 극복하기 위한 소프트웨어 시스템.
  - 하드웨어와 소프트웨어 분리, 가상화, 클라우드 시스템을 포함하는 개념.




#### 모듈화

- 79p



### 요구사항 정의(상)

#### 요구사항 정의

- 개념
  - 어떠한 문제를 해결하기 위해 필요한 조건이나 제약사항을 요구하는 것.
- 요구사항의 유형
  - 기능적 요구사항(Functional)
    - 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항
    - 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지, 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사항
    - 시스템이 반드시 수행해야 하는 기능
    - 사용자가 시스템을 통해 제공받기를 원하는 기능
  - 비기능적 요구사항(Non-functional)
    - 시스템 장비 구성 요구사항
    - 성능 요구사항
    - 인터페이스 요구사항
    - 데이터 요구사항
    - 테스트 요구사항
    - 보안 요구사항
    - 품질 요구사항
    - 제약 사항
    - 프로젝트 관리 요구사항
    - 프로젝트 지원 요구사항


#### 요구사항 개발 프로세스

- 도출(Elicitation) -> 분석(Analysis) -> 명세(Specification) -> 확인(Validation)
- 요구사항 도출(Elicitation, 요구도출, 요구수집, 요구추출)
  - 시스템, 사용자, 그리고 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항이 어디에 있는지, 어떻게 수집할 것인지를 식별하고 이해하는 과정
  - 요구사항 도출 단계에서 개발자와 고객 사이의 관계가 만들어지고 이해관계자가 식별됨.
  - 프로젝트 계획 단계에 정의한 문제의 범위 안에 있는 사용자의 요구를 찾는 단계.
  - 주요 기법
    - 인터뷰
    - 설문
    - 브레인스토밍
    - 프로토타이핑
    - 유스케이스 : 사용자의 요구 사항을 기능 단위로 표현하는 것
- 요구사항 분석(Analysis, 요구분석)
  - 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정
  - 소프트웨어가 무엇을 해야하는가를 추적하여 요구사항 명세를 작성하는 작업.
  - 사용자의 요구를 추출하여 목표를 정하고 어떤 방식으로 해결할 것인지 결정하는 단계
  - 소프트웨어 개발의 출발점이면서 실질적인 첫 번째 단계
- 요구사항 명세(Specification, 문서화)
  - 요구사항 분석 후 승인될 수 있도록 문서화하는 것
- 요구사항 확인(Validation, 검증)
  - 개발 자원을 요구사항에 할당하기 전에 요구사항 명세서가 정확하고 완전하게 작성되었는지 검토하는 활동
  - 요구사항 문서는 이해관계자들이 검토해야 함



#### 자료 흐름도(DFD)

- Data Flow Diagram
- 4가지 구성 요소
  - 처리Process : 원
  - 자료 흐름Data Flow : 화살표
  - 자료 저장소Data Store : 평행선
  - 단말Terminal : 사각형



#### 자료 사전(DD)

- Data Dictionary
- 자료, 자료들의 집합, 자료의 흐름, 자료 저장소와 그들간의 관계, 범위, 단위들을 구체적으로 명시.
- 사용 기호
  - = : is composed of
  - \+ : and
  - () : optional
  - {} : iteration
  - [] : selection
  - | : or
  - @ : key field
  - \* : comment
  - \** : no comment



#### 요구사항 검증

- 개념
- 절차

#### 요구사항 검토

- Peer Review
  - 동료 검토
  - 2~3명 정도의 검토 담당자가 수행하는 검토.
  - 다수의 이해관계자에게 요구사항 명세서 작성자가 명세서를 설명하면 이해관계자들이 설명을 들으면서 결함을 발견하는 형태로 진행됨.

- Walk Through
  - 소프트웨어 개발 단계마다 실시하는 비정형 검토회의
  - 오류 조기 검출이 목적
  - 검토 자료를 회의 전에 배포하고 사전 검토한 후 짧은 시간 동안 회의를 진행함
  - 사용사례를 확장하여 명세하거나 설계 다이어그램, 원시코드, 테스트 케이스 등에 적용할 수 있음.
  - 복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용함.
  - 단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해 보는 것임.

- Inspection
  - 소프트웨어 개발에 참여하지 않은 다른 전문가에 의해 오류를 찾아내는 공식적 검토 방법임.
  - 프그램을 수행시켜 보는 것 대신에 읽어보고 눈으로 확인하는 방법.
  - 코드 품질 향상 기법 중 하나
  - 결함과 함께 코딩 표준 준수 여부, 효율성 등의 다른 품질 이슈를 검사하기도 함.
  - 순서는 계획 - 사전교육 - 준비 - 인스펙션 회의 - 수정 - 후속조치
  - 
- Prototype
  - 프로토타입.
  - 검증하려는 주요 기능이나 일부분을 임시적으로 개발하여 이해관계자나 고객을 대상으로 시연하면서 요구사항을 검증함.
- Re-Factoring
  - 리펙토링.
  - 오류를 제거하고 새로운 기능을 추가하는 것이 아니라 결과의 변경 없이 프로그램 소스의 구조를 재조정하는 것.
  - 리펙토링은 가독성을 높이고 유지보수를 편하게 함



#### CASE

- 개념
  - Computer Aided Software Engineering, 분석 자동화 도구
  - 요구사항을 자동으로 분석, 요구사항 명세서를 기술하도록 개발된 요구사항 분석을 위한 자동화 도구

- 주요 기능
  - 그래픽 지원
  - SW 생명주기 전 단계 연결
  - 다양한 SW 개발 모형 지원
  - 표준화된 개발환경 구축
  - 문서 자동화 기능 제공
  - 작업과정, 데이터 공유로 작업자간 커뮤니케이션 증대

- 종류
  - SADT : Softtech사 개발
  - PSL/PSA : 미시간 대학
  - SREM = RSL/REVS : 실시간
  - TAGS




## 3. 화면 설계

### UI 요구사항 확인(하)

#### 사용자 인터페이스(UI)

- 3가지 분야
  - 물리적 제어
  - 기능적 제어
  - 전체 구성 제어
- UI의 특징
  - SW 영역 중 변경이 가장 많이 발생
  - 사용자의 만족도에 가장 큰 영향을 미침
  - 수행 결과의 오류를 줄임
  - 작업 시간 단축, 업무에 대한 이해도 높임
  - 편리성과 가독성 높임
  - 사용자 인터페이스 설계를 위해선 소프트웨어 아키텍처를 반드시 숙지해야 함
- UI의 종류
  - CLI(Command Line Interface) : 명령과 출력이 텍스트 형태
  - GUI(Graphic User Interface) : 아이콘이나 마우스 사용하는 그래픽 형태
  - NUL(Natural User Interface) : 사용자의 말이나 행동으로 기기 조작 형태
  - OUI(Organic User Interface) : 평면 아닌 화면 조작 형태
- UI의 설계 지침
  - 사용자 중심 / 일관성 / 단순성 / 결과 예측 가능 / 가시성 / 표준화 / 접그성 / 명확성 / 오류 발생 해결 등
- UI 요소
  - Text box
  - Password box
  - Radio button
  - Checkbox button
  - Select box
  - Textarea box
  - submit button
  - reset button
  - Toggle button



### UI 설계(하)

#### UI 설계

- UI 설계 원칙
  - 직관성 : 누구나 쉽게 이해, 사용
  - 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 함
  - 학습성 : 누구나 쉽게 배워야
  - 유연성 : 사용자 요구사항 최대한 수용하고 실수 최소화
- UI 개발 필수 기능
  - 사용자 명령을 받아들일 프롬프트 기능
  - 사용자 명령 입력의 검증 기능
  - 에러 처리와 에러 메시지 처리 기능
  - 도움말 지원 기능



#### 오류 메시지, 경고

- 메시지는 이해하기 쉬워야 함
- 오류로부터 회복을 위한 구체적인 설명이 제공되어야 함
- 오류로 인해 발생될 수 있는 부정적인 내용을 적극적으로 사용자들에게 알려야 함.



#### UI 설계 도구

- 와이어프레임 (Wireframe)
  - 기획 단계의 초기에 제작하는 것.
  - 페이지에 대한 개략적인 레이아웃이나 UI 요소 등에 대한 뼈대를 설계하는 단계
  - 개발자나 디자이너 등이 레이아웃을 협의하거나 현재 진행 상태 등을 공유하기 위해 사용함.
  - 각 페이지의 영역 구분, 콘텐츠, 텍스트 배치 등을 화면 단위로 설계함.
  - 와이어프레임 툴 : 손그림, 파워포인트, 키노트, 스케치, 일러스트, 포토샵 등
- 목업 (Mockup)
  - 디자인, 사용 방법 설명, 평가 등을 위해 와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형
  - 시각적으로만 구성 요소를 배치하는 것으로 일반적으로 실제로 구현되지는 않음.
  - 목업 툴 : 파워 목업, 발사믹 목업 등
- 스토리보드 (Story Board)
  - 와이어프레임 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가한 문서.
  - 디자이너와 개발자가 최종적으로 참고하는 작업 지침서.
  - 정책, 프로세스, 콘텐츠 구성, 와이어프레임, 기능 정의 등 서비스 구축을 위한 모든 정보가 들어 있음.
  - 스토리보드 구성
    - 상단이나 우측 : 제목, 작성자
    - 좌측 : UI 화면
    - 우측 : 디스크립션(Description)
  - 스토리보드 툴 : 파워포인트, 키노트, 스케치, Axure 등
- 프로토타입 (Prototype)
  - 와이어프레임이나 스토리보드 등에 인터랙션을 적용함으로써 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형
  - 사용성 테스트나 작업자 간 서비스 이해를 위해 작성하는 샘플
  - 작성 방법에 따라 페이퍼 프로토타입과 디지털 프로토타입으로 나뉨.
  - 프로토타입 툴 : HTML/CSS, Axure, Flinto, 네이버 프로토나우, 카카오 오븐 등
- 유스케이스 (Usecase)
  - 사용자 측면에서의 요구사항.
  - 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술함.
  - 자연어로 작성된 사용자의 요구사항을 구조적으로 표현한 것.
  - 일반적으로 다이어그램 형식으로 묘사함.
  - 유스케이스 다이어그램이 완성되면 각각의 유스케이스에 대해 유스케이스 명세서 작성함.



## 4. 애플리케이션 설계

### 공통 모듈(중)

#### 모듈

- 개념
  - SW구조를 이루며, 다른 것들과 구별할 수 있는 독립적인 기능을 갖는 단위
  - 서로 모여 하나의 완전한 프로그램으로 만들어질 수 있음.
  - 추상화되어 재사용 및 공유 가능한 수준으로 만들어진 기능 단위를 모듈로 규정함.
  - 다른 것들과 구별될 수 있는 독립적인 기능을 가진 단위(Unit)
  - 독립적인 컴파일이 가능하며 유일한 이름을 가져야 함.
- 모듈의 기본 요소
  - 입력 요소, 파라미터
  - 출력 요소 RETURN
  - 기능 요소
  - 기관 요소 : 모듈 내부의 알고리즘을 의미
  - 내부 자료 요소 : 모듈 내부의 기억 장소를 의미

- 모듈의 공유도(Fan-in)와 제어도(Fan-out)
  - 공유도는 얼마나 많은 모듈이 주어진 모듈을 호출하는가를 나타내는 척도. 상위 모듈의 수. 공통 모듈화 측면에서 잘 설계되어 있으나, 단일 실패점이 발생할 수 있으므로 중점 관리 및 더 많은 테스트를 통한 검증이 필요함.
  - 제어도는 주어진 모듈이 호출하는 모듈의 개수, 하위 모듈의 수. 불필요한 기능을 호출하고 있지 않은지 추가 검토를 진행하고 업무 로직을 단순화시킬 수 있는지에 대해서도 검토.

- 모듈의 개수 및 비용 간 상관도
  - x축은 모듈 개수, y축은 노력 비용
  - 모듈 별 개발 비용 : 모듈의 개수가 많을수록 노력 비용 감소(반비례)
  - 모듈 통합 비용 : 모듈의 개수가 많을수록 모듈 통합 비용 증가(비례)
  - 전체 SW 개발 비용 : 모듈 통합 비용과 모듈 개발 비용이 교차되는 부분의 영역이 최소 노력 비용이 됨(두 그래프가 교차되는 지점)



#### 공통 모듈

- 원칙

- 공통 모듈의 재사용 범위 따른 분류



#### 재공학

- 소프트웨어 재사용의 2가지 기본 기술 : 생성 중심, 합성 중심 120p

- 소프트웨어 재사용의 이점



### 모듈의 평가(상)

#### 모듈의 평가 기준

- 결합도
  - 결합도 낮음(높은 품질)
  - 결합도 높음(낮은 품질)

- 응집도
  - 응집도 낮음(낮은 품질)
  - 응집도 높음(높은 품질)




#### 모듈 결합도

- 자료 결합도 -> 스탬프 결합도 -> 제어 결합도 -> 외부 결합도 -> 공통 결합도 -> 내용 결합도

- 자료 결합도
  - Data Coupling
  - 두 모듈 간의 인터페이스가 자료 요소만으로 구성된 결합.
  - Call By Value 형태로 가장 좋은 결합 형태.
  - 실인수(호출 시 넘겨주는 변수)와 가인수(호출 시 넘겨받는 변수)의 번지가 독립적으로 사용됨.

- 스탬프 결합도
  - Stamp Coupling, 구조 결합
  - 두 모듈 간에 같은 레코드를 부분적으로 공유함.
  - 모듈 간 독립성은 유지되지만 같은 작업 대상인 자료로 묶인 결합을 말함.
  - 모듈 간의 인터페이스로 객체나 구조적인 데이터(배열, 레코드 등)가 전달되는 경우임.
  - 모듈 input 자료가 결합되어 있음.

- 제어 결합도
  - Control Coupling
  - 처리하는 방법을 제어 요소로 전달되는 경우임.

- 외부 결합도
  - Extern Coupling
  - 외부 변수에 의해 영향을 받는 두 모듈이 결합된 관계
  - 모듈 외부에서 데이터, 프로토콜, 인터페이스 등을 공유할 때 발생하는 경우.

- 공통 결합도
  - Common Coupling
  - 모듈이 다른 모듈의 내부 자료를 참조하는 형태의 결합된 관계
  - 모듈 외부에 선언되어 있는 전역 변수를 참조하고 상호 작용하는 경우임.
  - Call by Reference 형태임.
  - 실인수와 가인수의 번지가 같음.

- 내용 결합도
  - 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 형태의 결합된 관계
  - 가장 좋지 않은 결합으로 내용 결합도를 갖는 모듈들은 다시 설계해야 함.
  - 모듈 내부에 있는 변수나 기능을 다른 모듈에서 직접적으로 사용하는 경우임.




#### 모듈 응집도

- 우연적 응집도 -> 논리적 응집도 -> 시간적 응집도 -> 절차적 응집도 -> 통신적 응집도 -> 순차적 응집도 -> 기능적 응집도

- 우연적 응집도
  - Coincidental Cohesion
  - 모듈 내부의 루틴들이 뚜렷한 관계없이 묶인 경우로 응집도가 가장 약하고 가장 좋지 않은 모듈 설계임.
  - 서로 간에 어떠한 의미 있는 연관 관계도 지니지 않은 기능 요소로 구성되는 경우임.

- 논리적 응집도
  - Logical Cohesion
  - 모듈 내부의 루틴들이 같은 범주에 속하는 기능끼리 묶인 모듈
  - 오류 처리 모듈, 출력 처리 모듈, 파일 모듈


- 시간적 응집도
  - Temporal Cohesion
  - 모듈 내부의 루틴들이 시간적으로 수행 시기가 같은 기능끼리 묶인 모듈.
  - 여러 파일 OPEN 모듈, CLOSE 모듈, 변수 초기화 모듈
- 절차적 응집도
  - Procedure Cohesion
  - 모듈 내부의 루틴들이 수행 시기가 순위가 있는 기능끼리 묶인 모듈
  - 모듈 안의 구성 요소들이 순차적으로 수행할 경우
  - 재시작 모듈(총계 출력 -> 화면 지움 -> 메뉴 표시)
- 통신적 응집도
  - Communication Cohesion, 정보적, 교환적
  - 모듈 내부의 루틴들 중 작업 대상이 같은 기능끼리 묶인 모듈.
  - 일반적으로 하나의 파일을 대상으로 갱신 작업을 하는 루틴끼리 묶인 모듈이 여기에 속함.
  - 같은 입력 자료를 사용하여 A를 계산한 후 B를 계산하는 경우.

- 순차적 응집도
  - Sequential Cohesion
  - 모듈 내부의 루틴들이 이전의 명령어로부터 나온 출력 결과를 그 다음 명령어의 입력 자료로 사용하는 경우의 응집도
  - 행렬 입력 후 그 행렬의 역행렬을 구해서 이를 출력하는 경우임
- 기능적 응집도
  - Functional Cohesion, 함수적 응집도
  - 모듈 내부가 하나의 단일 기능으로 존재하는 경우로 프로그램 언어에서 지원받는 라이브러리가 모두 이에 속함.
  - 구조도 최하위 모듈(트리 구조의 단노드)에서 많이 발견됨.
  - 응집도 중 가장 강하고 좋은 모듈이라고 할 수 있음



### 설계 모델링(하)

#### N-S 도표

- NS Chart, Nassi Shneiderman Chart, 상자 도표
- 논리의 기술에 중점을 둔 도형을 이용한 표현 방법
- 순차, 선택, 반복으로 표현함
- 임의의 제어 이동이 어려움 (goto 구조가 어려움)
- 조건이 복합되어 있는 곳의 처리를 명확히 식별하기에 적합함. (if문 여러 개일 때)



#### HIPO 도표

- Hierarchical Input Process Output
- 인풋 - 프로세스 - 아웃풋으로 이루어진 모듈을 계층적으로 나타낸 도표.
- 가시적 도표 Visual Table of Contents : 시스템의 전체적인 기능과 흐름을 보여주는 Tree 형태의 구조도.
- 총체적 도표 Overview Diagram : 프로그램을 구성하는 기능을 기술한 것으로 입력-처리-출력에 대한 전반적인 정보를 제공하는 도표
- 세부적 도표 Detail Diagram : 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표. 총체적 도표와 모양은 같지만 내용이 좀 더 복잡하게 들어감.
- 세 가지가 모두 모여야만 HIPO 도표라고 하는 것은 아님. 가시적 도표를 이야기하는 경우가 많음.



### 소프트웨어 아키텍처(하)

#### 시스템 아키텍처

- 개념
  - HW와 SW를 포함하는 시스템 전체에 대한 논리적인 기능 체계.
  - 시스템이 어떻게 작동하는지를 설명하는 프레임워크.
- 시스템 아키텍처 설계
  - 소프트웨어 아키텍처 설계에 제약을 하는 상위 설계임.
  - 시스템 아키텍처 설계 -> 소프트웨어 아키텍처 설계 -> 소프트웨어 상세 설계



#### 소프트웨어 아키텍처

- 개념
  - 소프트웨어의 골격이 되는 기본 구조로 소프트웨어 전체에 대한 큰 밑그림임.
  - 소프트웨어 구성 요소의 유기적인 결합 형태와 전체 구조임.
  - 소프트웨어를 이루고 잇는 구성 요소인 모듈이나 컴포넌트를 다룸.
- 소프트웨어 아키텍처 설계 과정
  - 설계 목표 설정
  - 시스템 타입 결정
  - 아키텍처 패턴 적용 (스타일 적용 및 커스터마이즈)
  - 서브시스템 구체화 (서브시스템의 기능, 인터페이스 동작 작성)
  - 아키텍처 설계 검토
- 아키텍처 드라이버
  - 요구사항 중 아키텍처에 영향을 주는 요구사항을 아키텍처 드라이버라고 함.
  - 아키텍처 드라이버를 입력물로 태스크에 의해 아키텍처 설계가 진행되고 그 결과물로 아키텍처 문서와 아키텍처 가이드라인이 출력됨.
- 소프트웨어 아키텍처의 시스템 품질 속성
  - 가용성(Availability) : 인가된 사용자가 원하는 시간이나 장소에서 필요 정보에 접근할 수 있고 사용할 수 있도록 보장하는 성질.
  - 변경 용이성(Modifiability) : 기능 추가, 변경에 부담 없이 변경할 수 있어야 함.
  - 성능(Performance) : 처리량, 응답 시간, 사용 가능도 등을 측정함.
  - 보안성(Security) : 권한 없는 사용자 데이터나 프로그램 사용할 수 없도록 함.
  - 사용 편의성(Usability) : 쉽게 사용할 수 있는가정도 
  - 시험 용이성(Testability) : 쉽게 검사할 수 있는가의 정도



#### 아키텍처 계층

- 소프트웨어 아키텍처 모델의 하나

- 표현 계층(Presentation Layer) : UI 계층
- 프로세스 계층(Process Layer) : 서비스 계층
- 비즈니스 논리 계층(Business Logic Layer) : 도메인 계층
- 데이터 접근 계층(Data Access Layer) : 영속 계층(Persistence Layer)



#### 마스터 슬레이브 패턴

- Master Slave Pattern
- 소프트웨어 아키텍처 모델의 하나
- 마스터가 슬레이브에게 작업을 분산하면 슬레이브가 처리한 결과로 최종 결과를 계산하는 패턴.
- 마스터 데이터베이스는 원본 데이터를 가지고 있고, 슬레이브는 복제본을 동기화하는 형태로 활용할 수 있음.
- 일반적으로 실시간 시스템에서 사용됨.
- 실시간 시스템에 적용할 수 있지만 마스터와 슬레이브 간에 Latency 문제가 발생할 수 있음.
- 마스터 프로세스는 일반적으로 연산, 통신, 조정을 책임짐.
- 마스터 프로세스는 슬레이브 프로세스들을 제어할 수 있음.
- 슬레이브 프로세스들은 마스터가 요청한 작업만을 수행함.



#### 파이프 필터 패턴

- Pipe filter Pattern
- 소프트웨어 아키텍처 모델의 하나
- 데이터 스트림을 생성하고 처리하는 시스템에서 사용됨.
- 서브 시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복함.
- 처리 과정은 필터(Filter)를 통해 이루어지며, 처리되는 데이터 스트림은 파이프(Pipe)를 통해 흐름.
- 파이프는 버퍼링 또는 동기화 목적으로 사용될 수 있음.
- 컴파일러, 연속한 필터들은 어휘 분석, 파싱 등에 활용됨.
- 단방향, 양방향 모두 구현할 수 있으며, 필터 이동 시 오버헤드가 발생함.



### 코드 설계(하)

#### 코드의 기능

- 3대 기능, 추가 기능

#### 순차 코드

#### 표의 숫자 코드

#### 코드 오류의 종류

- 사본오류 전위오류 이중오류 등등



### 파일 설계(하)



## 5. 인터페이스 설계

### 인터페이스 요구사항(하)

#### 인터페이스 송신 시스템



### 인터페이스 설계(하)